<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unity之SpriteAtlas详解</title>
      <link href="/2020/03/29/unity-zhi-spriteatlas-xiang-jie/"/>
      <url>/2020/03/29/unity-zhi-spriteatlas-xiang-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Unity之SpriteAtlas详解"><a href="#Unity之SpriteAtlas详解" class="headerlink" title="Unity之SpriteAtlas详解"></a>Unity之SpriteAtlas详解</h1><p>Unity官方介绍：<a href="https://docs.unity3d.com/Manual/class-SpriteAtlas.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/class-SpriteAtlas.html</a></p><p>SpriteAtlas Inspector面板如下图：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdatrsnat1j30i20pqjtb.jpg" alt></p><p>创建方法：</p><p>1、Project面板鼠标右键Create-&gt;Sprite Atlas</p><p>2、菜单栏Asset-&gt;Create-&gt;Sprite Atlas</p><h2 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍:"></a>属性介绍:</h2><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><pre><code>SpriteAtlas有两种类型，Master或者Variant，默认类型是MAster；Variant是变体类型，创建一个变体图集，并声明它是项目中一个现有SpriteAtlas的变体，如下图，变体图集将复制母版图集的纹理，然后根据scale调整变体图集的大小。</code></pre><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdaukgd3y3j30ks09k3z3.jpg" alt></p><h3 id="Include-in-Build"><a href="#Include-in-Build" class="headerlink" title="Include in Build"></a>Include in Build</h3><pre><code>选中此复选框以将Sprite Atlas资产包含在当前版本中。默认情况下启用此选项。</code></pre><h3 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h3><pre><code>变体图集缩放数值，值可以从0.1到1</code></pre><h3 id="Allow-Rotation"><a href="#Allow-Rotation" class="headerlink" title="Allow Rotation"></a>Allow Rotation</h3><pre><code>是否允许Unity将打包到SpriteAtlas中的Sprite进行旋转，如果允许，可以最大化提高图集中Sprite的密度，默认允许旋转。如果是在UGUI中使用SpriteAtlas，应该禁用旋转</code></pre><h3 id="Tight-Packing"><a href="#Tight-Packing" class="headerlink" title="Tight Packing"></a>Tight Packing</h3><pre><code>根据Sprite轮廓而不是默认的矩形轮廓打包Sprite，进一步提高图集中Sprite的密度，默认是启用的，在UGUI中使用SpriteAtlas应该禁用</code></pre><h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><pre><code>图集中各个Sprite之间的像素距离，避免图集中彼此相邻的Sprite发生像素重叠。默认为4像素，支持2、4、8三种选择。</code></pre><h3 id="Objects-For-Packing"><a href="#Objects-For-Packing" class="headerlink" title="Objects For Packing"></a>Objects For Packing</h3><pre><code>Unity将此列表中的所有内容打包成一个图集。支持拖入一个文件夹或者一个单独的Sprite。</code></pre><h2 id="Sprite-Packer"><a href="#Sprite-Packer" class="headerlink" title="Sprite Packer"></a>Sprite Packer</h2><pre><code>SpritePacker默认是关闭的状态，在Edit -&gt; Project Settings -&gt; Editor中将SpritePacker Mode更改为Enable，Always Enabled选项始终打开。打开后回到SpriteAtlas Inspector面板，点击Pack Preview按钮就可以在预览窗口看到图集了。</code></pre><h2 id="Late-Binding"><a href="#Late-Binding" class="headerlink" title="Late Binding"></a>Late Binding</h2><pre><code>从语义来看称之为后期绑定，也就是说在运行时以不引用图集的形式启动，并且在绑定图集之前将显示为空白。如果在启动过程中图集来源于网络下载，这样就允许用户进行后期绑定了。</code></pre><h2 id="Late-Binding-via-callback"><a href="#Late-Binding-via-callback" class="headerlink" title="Late Binding via callback"></a>Late Binding via callback</h2><p>1、Sprite打包到SpriteAtlas中，SpriteAtlas未选中Include In Build，sprite在场景中就不可见</p><p>2、SpriteAtlas.atlasRequested这个委托方法提供一个告知上层逻辑要绑定的图集标签和包含SpriteAtlas资产的Action，通过这个委托，上层逻辑根据图集标签自行加载管理图集，并将加载好的图集通过第二个参数Action告知给底层。至于如何根据图集标签加载图集，不在本篇文章范围内。<br>SpriteAtlas.atlasRequested的第一个参数string类型的tag就是需要加载的图集文件名，SpriteAtlas本身无法指定Tag。</p><h2 id="SpriteAtlas-amp-AssetBundle"><a href="#SpriteAtlas-amp-AssetBundle" class="headerlink" title="SpriteAtlas &amp; AssetBundle"></a>SpriteAtlas &amp; AssetBundle</h2><p>取消Inclue in build选项打包，运行时使用SpriteAtlas.atlasRequested回调得到需要加载的图集Tag，使用自己项目中的资源模块进行SpriteAtlas加载后并执行回调传给底层。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://forum.unity.com/threads/about-include-in-build-behaviour.481433/" target="_blank" rel="noopener">https://forum.unity.com/threads/about-include-in-build-behaviour.481433/</a></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> SpriteAtlas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityTips——Unity小技巧集合</title>
      <link href="/2020/03/28/unitytips-unity-xiao-ji-qiao-ji-he/"/>
      <url>/2020/03/28/unitytips-unity-xiao-ji-qiao-ji-he/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h1><h2 id="RequiredAttribute"><a href="#RequiredAttribute" class="headerlink" title="RequiredAttribute"></a>RequiredAttribute</h2><p>效果图如下：当引用类型的property为空时，使用红色提示。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYTQ2am9taHUxZzMwa2UwODg3d2ouZ2lm" alt></p><p>代码如下：</p><p>1、RequiredAttribute.cs</p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">using</span> UnityEngine<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequiredAttribute</span> <span class="token punctuation">:</span> PropertyAttribute<span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>2、RequiredDrawer.cs</p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">using</span> UnityEditor<span class="token punctuation">;</span><span class="token keyword">using</span> UnityEngine<span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token function">CustomPropertyDrawer</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>RequiredAttribute<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequiredDrawer</span> <span class="token punctuation">:</span> PropertyDrawer<span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">void</span> <span class="token function">OnGUI</span><span class="token punctuation">(</span>Rect position<span class="token punctuation">,</span> SerializedProperty property<span class="token punctuation">,</span> GUIContent label<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Color c <span class="token operator">=</span> GUI<span class="token punctuation">.</span>backgroundColor<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>property<span class="token punctuation">.</span>propertyType <span class="token operator">==</span> SerializedPropertyType<span class="token punctuation">.</span>ObjectReference <span class="token operator">||</span> property<span class="token punctuation">.</span>propertyType <span class="token operator">==</span> SerializedPropertyType<span class="token punctuation">.</span>ExposedReference<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> property<span class="token punctuation">.</span>objectReferenceValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            GUI<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> Color<span class="token punctuation">.</span>red<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        EditorGUI<span class="token punctuation">.</span><span class="token function">PropertyField</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> property<span class="token punctuation">)</span><span class="token punctuation">;</span>        GUI<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3、测试脚本RequiredAttributeDemo.cs</p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">using</span> UnityEngine<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequiredAttributeDemo</span> <span class="token punctuation">:</span> MonoBehaviour<span class="token punctuation">{</span>    <span class="token punctuation">[</span>Required<span class="token punctuation">]</span> <span class="token keyword">public</span> Transform _transform<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><h2 id="Debug-Log日志点击"><a href="#Debug-Log日志点击" class="headerlink" title="Debug.Log日志点击"></a>Debug.Log日志点击</h2><p>Debug.Log 官方文档介绍地址：<a href="https://docs.unity3d.com/ScriptReference/Debug.Log.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/Debug.Log.html</a></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYTQ3ZXVkY3d1ZzMwZDIwYjZxdjUuZ2lm" alt></p><h2 id="脚本改类名，同时修改文件名"><a href="#脚本改类名，同时修改文件名" class="headerlink" title="脚本改类名，同时修改文件名"></a>脚本改类名，同时修改文件名</h2><p>Rider、VS使用快捷键Ctrl+R+R，弹出改名框</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYTQ3bm55bzdnZzMwOHcwNHVucGQuZ2lm" alt></p><h2 id="离开编辑模式，进入运行模式时，保存Scene和Assets"><a href="#离开编辑模式，进入运行模式时，保存Scene和Assets" class="headerlink" title="离开编辑模式，进入运行模式时，保存Scene和Assets"></a>离开编辑模式，进入运行模式时，保存Scene和Assets</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYTQ4MTR2enRoZzMwOWEwYmdoYWQuZ2lm" alt></p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">using</span> UnityEditor<span class="token punctuation">;</span> <span class="token keyword">using</span> UnityEditor<span class="token punctuation">.</span>SceneManagement<span class="token punctuation">;</span> <span class="token keyword">using</span> UnityEngine<span class="token punctuation">;</span> <span class="token punctuation">[</span>InitializeOnLoad<span class="token punctuation">]</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AutoSave</span> <span class="token punctuation">{</span>     <span class="token keyword">static</span> <span class="token function">AutoSave</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>         EditorApplication<span class="token punctuation">.</span>playModeStateChanged <span class="token operator">+</span><span class="token operator">=</span> SaveOnPlay<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">SaveOnPlay</span><span class="token punctuation">(</span>PlayModeStateChange state<span class="token punctuation">)</span>     <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> PlayModeStateChange<span class="token punctuation">.</span>ExitingEditMode<span class="token punctuation">)</span>         <span class="token punctuation">{</span>             Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Exiting Edit Mode,Auto Save..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             EditorSceneManager<span class="token punctuation">.</span><span class="token function">SaveOpenScenes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             AssetDatabase<span class="token punctuation">.</span><span class="token function">SaveAssets</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><h2 id="Unity多语言修改"><a href="#Unity多语言修改" class="headerlink" title="Unity多语言修改"></a>Unity多语言修改</h2><p>起因：群友想修改AudioSource组件的Inspector面板中Volume字段的提示内容。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYTRwcXlidmh2ajMwaTgwankwdXUuanBn?x-oss-process=image/format,png" alt></p><p>然后我一查Editor脚本，<a href="https://github.com/Unity-Technologies/UnityCsReference/blob/2019.3/Editor/Mono/Inspector/AudioSourceInspector.cs" target="_blank" rel="noopener">https://github.com/Unity-Technologies/UnityCsReference/blob/2019.3/Editor/Mono/Inspector/AudioSourceInspector.cs</a></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYTRwc2t4b2RlajMxbTQwaHVhamguanBn?x-oss-process=image/format,png" alt></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYTRwc3h0ZWJpajMweHMwOTJkaTkuanBn?x-oss-process=image/format,png" alt></p><p>这写死了，，，怎么改。。。</p><p>后来群友提醒到Unity现在支持多语言，那就下载一个中文包看看。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYTRwdHRxMDN0ajMwemswYWdnb2cuanBn?x-oss-process=image/format,png" alt></p><p>中文包下载下来是上图中的一个.po文件</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYTRwdWs4ampiajMxZGkwbHM0M2guanBn?x-oss-process=image/format,png" alt></p><p>看样子是以一个msgid对应一个msgstr，msgid就是英文的内容，msgstr就是各语言的内容了。</p><p>接着找”Sets the overall volume of the sound.”</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYTRwdzNmam1sajMwdjgwNzZ3ZnQuanBn?x-oss-process=image/format,png" alt></p><p>对应的中文内容就是上面了。。</p><p>那么.po文件自己修改后，重启Unity后就可以应用上去了。</p><p>测试以下:</p><p>msgstr “设置声音的整体音量。”</p><p>修改成</p><p>msgstr “设置声音的整体音量。（修改版）”</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYTRweXFheDh3ajMwaTQwNndhYWkuanBn?x-oss-process=image/format,png" alt></p><p>如上图，修改成功。</p><p>那么，回到那位群友的问题，如果只修改那个Volume的提示文本呢，很简单，把.po文件的其他内容都删掉，文件头的内容别删了，只留下这个msgid和msgstr，别的都id和str都删了，这样就实现了修改Volume的提示文本了。</p><p>如下图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYTRxMTN1M2MxajMwaGEwYjQwdGkuanBn?x-oss-process=image/format,png" alt></p><p>不过中文的.po文件 是用的 中文的字体，总之，看着就是别扭。。。</p><h1 id="添加自定义HeaderGUI"><a href="#添加自定义HeaderGUI" class="headerlink" title="添加自定义HeaderGUI"></a>添加自定义HeaderGUI</h1><p><a href="https://docs.unity3d.com/2019.2/Documentation/ScriptReference/Editor-finishedDefaultHeaderGUI.html" target="_blank" rel="noopener">官方链接说明</a></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2dE5iUndneTFnYTZmeWg5aGJlajMwYWEwMXZ0OHQuanBn?x-oss-process=image/format,png" alt></p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">using</span> UnityEditor<span class="token punctuation">;</span><span class="token punctuation">[</span>InitializeOnLoadAttribute<span class="token punctuation">]</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">EditorHeaderGUID</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token function">EditorHeaderGUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Editor<span class="token punctuation">.</span>finishedDefaultHeaderGUI <span class="token operator">+</span><span class="token operator">=</span> DisplayGUIDIfPersistent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">DisplayGUIDIfPersistent</span><span class="token punctuation">(</span>Editor editor<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>EditorUtility<span class="token punctuation">.</span><span class="token function">IsPersistent</span><span class="token punctuation">(</span>editor<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> guid <span class="token operator">=</span> AssetDatabase<span class="token punctuation">.</span><span class="token function">AssetPathToGUID</span><span class="token punctuation">(</span>AssetDatabase<span class="token punctuation">.</span><span class="token function">GetAssetPath</span><span class="token punctuation">(</span>editor<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> totalRect <span class="token operator">=</span> EditorGUILayout<span class="token punctuation">.</span><span class="token function">GetControlRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> controlRect <span class="token operator">=</span> EditorGUI<span class="token punctuation">.</span><span class="token function">PrefixLabel</span><span class="token punctuation">(</span>totalRect<span class="token punctuation">,</span> EditorGUIUtility<span class="token punctuation">.</span><span class="token function">TrTempContent</span><span class="token punctuation">(</span><span class="token string">"GUID"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>editor<span class="token punctuation">.</span>targets<span class="token punctuation">.</span>Length <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>            EditorGUI<span class="token punctuation">.</span><span class="token function">LabelField</span><span class="token punctuation">(</span>controlRect<span class="token punctuation">,</span> EditorGUIUtility<span class="token punctuation">.</span><span class="token function">TrTempContent</span><span class="token punctuation">(</span><span class="token string">"[Multiple objects selected]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            EditorGUI<span class="token punctuation">.</span><span class="token function">SelectableLabel</span><span class="token punctuation">(</span>controlRect<span class="token punctuation">,</span> guid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="OnValidata数据检查"><a href="#OnValidata数据检查" class="headerlink" title="OnValidata数据检查"></a>OnValidata数据检查</h1><p><a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnValidate.html" target="_blank" rel="noopener">OnValidata官方文档介绍</a></p><p>在编辑器中可以使用 OnValidate() 对输入的数据进行检查。（仅编辑状态下有效）</p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">using</span> UnityEngine<span class="token punctuation">;</span><span class="token keyword">using</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OnValidateExample</span> <span class="token punctuation">:</span> MonoBehaviour <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> validateTestValue<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">OnValidate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//Check validateTestValue</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="拖拽多个元素到-inspector"><a href="#拖拽多个元素到-inspector" class="headerlink" title="拖拽多个元素到 inspector"></a>拖拽多个元素到 inspector</h1><p>可以拖拽元素直接加到 inspector 中去，但是选择多个元素的时候就不容易做到了，其实有一个方法，就是先锁定 inspector，就可以轻易的将多个元素（对象）拖拽到 inspector 中了。</p><h1 id="使用代码移动Component在Inspector中的顺序"><a href="#使用代码移动Component在Inspector中的顺序" class="headerlink" title="使用代码移动Component在Inspector中的顺序"></a>使用代码移动Component在Inspector中的顺序</h1><pre class=" language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//上移</span>UnityEditorInternal<span class="token punctuation">.</span>ComponentUtility<span class="token punctuation">.</span><span class="token function">MoveComponentUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下移</span>UnityEditorInternal<span class="token punctuation">.</span>ComponentUtility<span class="token punctuation">.</span><span class="token function">MoveComponentDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>拓展讲解ComponentUtility</p><pre class=" language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//组件拷贝</span>UnityEditorInternal<span class="token punctuation">.</span>ComponentUtility<span class="token punctuation">.</span><span class="token function">CopyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//组件粘贴values</span>UnityEditorInternal<span class="token punctuation">.</span>ComponentUtility<span class="token punctuation">.</span><span class="token function">PasteComponentValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//作为新组件粘贴</span>UnityEditorInternal<span class="token punctuation">.</span>ComponentUtility<span class="token punctuation">.</span><span class="token function">PasteComponentAsNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果两组件不同就替换</span>UnityEditorInternal<span class="token punctuation">.</span>ComponentUtility<span class="token punctuation">.</span><span class="token function">ReplaceComponentsIfDifferent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据自定义匹配规则删除组件</span>UnityEditorInternal<span class="token punctuation">.</span>ComponentUtility<span class="token punctuation">.</span><span class="token function">DestroyComponentsMatching</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>以上这几个接口在unity官方文档里没找到介绍。。。</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。<br>本主题持续更新。。。</p>]]></content>
      
      
      <categories>
          
          <category> UnityTips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UnityTips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GameFramework框架源码解读（一）：Editor篇</title>
      <link href="/2020/03/28/gameframework-kuang-jia-yuan-ma-jie-du-yi-editor-pian/"/>
      <url>/2020/03/28/gameframework-kuang-jia-yuan-ma-jie-du-yi-editor-pian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>笔记目录<br>@[toc]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将使用StarForce案例，结合源码和Editor界面介绍一下GF中所有的Editor界面（包括Inspector），持续更新。</p><p>StarForce地址：<a href="https://github.com/EllanJiang/StarForce" target="_blank" rel="noopener">https://github.com/EllanJiang/StarForce</a><br>GameFramework地址：<a href="https://github.com/EllanJiang/GameFramework" target="_blank" rel="noopener">https://github.com/EllanJiang/GameFramework</a><br>UnityGameFramework地址：<a href="https://github.com/EllanJiang/UnityGameFramework" target="_blank" rel="noopener">https://github.com/EllanJiang/UnityGameFramework</a><br>GameFramework官方网站：<a href="http://gameframework.cn/" target="_blank" rel="noopener">http://gameframework.cn/</a></p><p>本文所讲解的内容如与你使用的框架版本有所差异，请阅读源码，源码即文档。。</p><h1 id="菜单栏Game-Framework"><a href="#菜单栏Game-Framework" class="headerlink" title="菜单栏Game Framework"></a>菜单栏Game Framework</h1><h2 id="Open-Folder"><a href="#Open-Folder" class="headerlink" title="Open Folder"></a>Open Folder</h2><p>待续</p><h2 id="Scenes-in-Build-Settings"><a href="#Scenes-in-Build-Settings" class="headerlink" title="Scenes in Build Settings"></a>Scenes in Build Settings</h2><p>待续</p><h2 id="Log-Scripting-Define-Symbols"><a href="#Log-Scripting-Define-Symbols" class="headerlink" title="Log Scripting Define Symbols"></a>Log Scripting Define Symbols</h2><p>待续</p><h2 id="AssetBundle-Tools"><a href="#AssetBundle-Tools" class="headerlink" title="AssetBundle Tools"></a>AssetBundle Tools</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZneTFnOGFkOTdqZjJ6ajMwcDgwOHdhanIuanBn?x-oss-process=image/format,png" alt></p><h3 id="AssetBundle工具相关配置"><a href="#AssetBundle工具相关配置" class="headerlink" title="AssetBundle工具相关配置"></a>AssetBundle工具相关配置</h3><p>AB的XML配置一共有三个，分别是AssetBundleEditor.xml、AssetBundleCollection.xml、AssetBundleBuilder.xml<br>在StarForce案例中，它们在Assets/GameMain/Configs文件中，然而配置的默认路径并不在这里，这个路径是可以自定义的。</p><pre class=" language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//AssetBundleEditorController.cs文件中</span><span class="token keyword">public</span> <span class="token function">AssetBundleEditorController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            m_ConfigurationPath <span class="token operator">=</span> Type<span class="token punctuation">.</span><span class="token generic-method function">GetConfigurationPath<span class="token punctuation">&lt;</span>AssetBundleEditorConfigPathAttribute<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span><span class="token operator">?</span> Utility<span class="token punctuation">.</span>Path<span class="token punctuation">.</span><span class="token function">GetCombinePath</span><span class="token punctuation">(</span>Application<span class="token punctuation">.</span>dataPath<span class="token punctuation">,</span> <span class="token string">"GameFramework/Configs/AssetBundleEditor.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//...省略</span><span class="token punctuation">}</span></code></pre><pre class=" language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//AssetBundleCollection.cs文件中</span><span class="token keyword">public</span> <span class="token function">AssetBundleCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    m_ConfigurationPath <span class="token operator">=</span> Type<span class="token punctuation">.</span><span class="token generic-method function">GetConfigurationPath<span class="token punctuation">&lt;</span>AssetBundleCollectionConfigPathAttribute<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span><span class="token operator">?</span> Utility<span class="token punctuation">.</span>Path<span class="token punctuation">.</span><span class="token function">GetCombinePath</span><span class="token punctuation">(</span>Application<span class="token punctuation">.</span>dataPath<span class="token punctuation">,</span> <span class="token string">"GameFramework/Configs/AssetBundleCollection.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    m_AssetBundles <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SortedDictionary</span><span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> AssetBundle<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    m_Assets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SortedDictionary</span><span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> Asset<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//AssetBundleBuilderController.cs文件中</span><span class="token keyword">public</span> <span class="token function">AssetBundleBuilderController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    m_ConfigurationPath <span class="token operator">=</span> Type<span class="token punctuation">.</span><span class="token generic-method function">GetConfigurationPath<span class="token punctuation">&lt;</span>AssetBundleBuilderConfigPathAttribute<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span><span class="token operator">?</span> Utility<span class="token punctuation">.</span>Path<span class="token punctuation">.</span><span class="token function">GetCombinePath</span><span class="token punctuation">(</span>Application<span class="token punctuation">.</span>dataPath<span class="token punctuation">,</span> <span class="token string">"GameFramework/Configs/AssetBundleBuilder.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...省略</span><span class="token punctuation">}</span></code></pre><p>从上面摘抄的源码中可以看出，会先通过Type.GetConfigurationPath接口（AssetBundleEditorConfigPathAttribute、AssetBundleCollectionConfigPathAttribute、AssetBundleBuilderConfigPathAttribute）找到本地定义的路径，如果没有找到，则使用后面的默认路径。<strong>【注：Type.GetConfigurationPath接口自行看源码】</strong></p><p>而在StarForce案例中，GameFrameworkConfigs.cs案例中定义了这几个路径</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZneTFnOGFkaWZnOWZzajMxeXkwaHVuMnYuanBn?x-oss-process=image/format,png" alt></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZneTFnOGFkajUxaW9majMwbnUwZW8wdjguanBn?x-oss-process=image/format,png" alt></p><h4 id="AssetBundleEditor-xml"><a href="#AssetBundleEditor-xml" class="headerlink" title="AssetBundleEditor.xml"></a>AssetBundleEditor.xml</h4><p>配置格式介绍</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>UnityGameFramework</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>AssetBundleEditor</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Settings</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--配置资源搜索的根目录，可以从Assets根部全部查找，可以配置成子目录--></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SourceAssetRootPath</span><span class="token punctuation">></span></span>Assets/GameMain<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>SourceAssetRootPath</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!--配置资源搜索的子目录，相对于根目录的路径，支持配置多个子目录，如果为空，则搜索所有子目录--></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SourceAssetSearchPaths</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SourceAssetSearchPath</span> <span class="token attr-name">RelativePath</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>SourceAssetSearchPaths</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!--筛选并包含的资源类型--></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SourceAssetUnionTypeFilter</span><span class="token punctuation">></span></span>t:Scene t:Prefab t:Shader t:Model t:Material t:Texture t:AudioClip t:AnimationClip t:AnimatorController t:Font t:TextAsset t:ScriptableObject<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>SourceAssetUnionTypeFilter</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!--筛选并包含的标签类型--></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SourceAssetUnionLabelFilter</span><span class="token punctuation">></span></span>l:AssetBundleInclusive<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>SourceAssetUnionLabelFilter</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!--筛选并排除的资源类型--></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SourceAssetExceptTypeFilter</span><span class="token punctuation">></span></span>t:Script<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>SourceAssetExceptTypeFilter</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!--筛选并排除的标签类型--></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SourceAssetExceptLabelFilter</span><span class="token punctuation">></span></span>l:AssetBundleExclusive<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>SourceAssetExceptLabelFilter</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!--编辑器中资源列表的排序，可以是Name(资源文件名），Path（资源全路径），Guid（资源Guid）--></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>AssetSorter</span><span class="token punctuation">></span></span>Path<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>AssetSorter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Settings</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>AssetBundleEditor</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>UnityGameFramework</span><span class="token punctuation">></span></span></code></pre><p>AssetBundleEditorController.cs中的ScanSourceAssets就是通过以上配置搜索筛选的资源。</p><pre class=" language-csharp"><code class="language-csharp">        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ScanSourceAssets</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            m_SourceAssets<span class="token punctuation">.</span><span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            m_SourceAssetRoot<span class="token punctuation">.</span><span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceAssetSearchPaths <span class="token operator">=</span> m_SourceAssetSearchPaths<span class="token punctuation">.</span><span class="token function">ToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            HashSet<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">></span> tempGuids <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//AssetDatabase.FindAssets接口返回的是搜索到的资源列表的guid数组，在Project的搜索栏中输入t:prefab也是进行这个接口的操作</span>            <span class="token comment" spellcheck="true">//筛选并包含指定类型的资源</span>            tempGuids<span class="token punctuation">.</span><span class="token function">UnionWith</span><span class="token punctuation">(</span>AssetDatabase<span class="token punctuation">.</span><span class="token function">FindAssets</span><span class="token punctuation">(</span>SourceAssetUnionTypeFilter<span class="token punctuation">,</span> sourceAssetSearchPaths<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//筛选并包含指定标签的资源</span>            tempGuids<span class="token punctuation">.</span><span class="token function">UnionWith</span><span class="token punctuation">(</span>AssetDatabase<span class="token punctuation">.</span><span class="token function">FindAssets</span><span class="token punctuation">(</span>SourceAssetUnionLabelFilter<span class="token punctuation">,</span> sourceAssetSearchPaths<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//筛选并排除指定类型的资源</span>            tempGuids<span class="token punctuation">.</span><span class="token function">ExceptWith</span><span class="token punctuation">(</span>AssetDatabase<span class="token punctuation">.</span><span class="token function">FindAssets</span><span class="token punctuation">(</span>SourceAssetExceptTypeFilter<span class="token punctuation">,</span> sourceAssetSearchPaths<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//筛选并排除指定标签的资源</span>            tempGuids<span class="token punctuation">.</span><span class="token function">ExceptWith</span><span class="token punctuation">(</span>AssetDatabase<span class="token punctuation">.</span><span class="token function">FindAssets</span><span class="token punctuation">(</span>SourceAssetExceptLabelFilter<span class="token punctuation">,</span> sourceAssetSearchPaths<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> assetGuids <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">></span><span class="token punctuation">(</span>tempGuids<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token keyword">string</span> assetGuid <span class="token keyword">in</span> assetGuids<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">string</span> fullPath <span class="token operator">=</span> AssetDatabase<span class="token punctuation">.</span><span class="token function">GUIDToAssetPath</span><span class="token punctuation">(</span>assetGuid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>AssetDatabase<span class="token punctuation">.</span><span class="token function">IsValidFolder</span><span class="token punctuation">(</span>fullPath<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Skip folder.</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">string</span> assetPath <span class="token operator">=</span> fullPath<span class="token punctuation">.</span><span class="token function">Substring</span><span class="token punctuation">(</span>SourceAssetRootPath<span class="token punctuation">.</span>Length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> splitPath <span class="token operator">=</span> assetPath<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                SourceFolder folder <span class="token operator">=</span> m_SourceAssetRoot<span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> splitPath<span class="token punctuation">.</span>Length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    SourceFolder subFolder <span class="token operator">=</span> folder<span class="token punctuation">.</span><span class="token function">GetFolder</span><span class="token punctuation">(</span>splitPath<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    folder <span class="token operator">=</span> subFolder <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> folder<span class="token punctuation">.</span><span class="token function">AddFolder</span><span class="token punctuation">(</span>splitPath<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> subFolder<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                SourceAsset asset <span class="token operator">=</span> folder<span class="token punctuation">.</span><span class="token function">AddAsset</span><span class="token punctuation">(</span>assetGuid<span class="token punctuation">,</span> fullPath<span class="token punctuation">,</span> splitPath<span class="token punctuation">[</span>splitPath<span class="token punctuation">.</span>Length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                m_SourceAssets<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>asset<span class="token punctuation">.</span>Guid<span class="token punctuation">,</span> asset<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><p>目前官方没有提供这个配置的编辑工具，需手动编辑xml文件。<br>打开AssetBundleEditor窗口后，根据以上配置筛选资源形成界面的右侧树状图。</p><h4 id="AssetBundleCollection-xml"><a href="#AssetBundleCollection-xml" class="headerlink" title="AssetBundleCollection.xml"></a>AssetBundleCollection.xml</h4><p>这个文件是通过AssetBundleEditor工具编辑好AB后，生成的文件。里面用来记录包含了哪些AB，AB中分别又包含了哪些资源，也就是对应了AssetBundleEditor窗口的左侧列表。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZneTFnOGFlMXc4ejdtajMwanEweWN0YnkuanBn?x-oss-process=image/format,png" alt></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZneTFnOGFlMzBrZ2JtajMwenUwZ2tkbmUuanBn?x-oss-process=image/format,png" alt></p><p>其中看一下AssetBundle和Asset中包含的内容：</p><p>AssetBundle：<br>（1）Name：AB的名称，主持路径<br>（2）LoadType：AB的加载方式，对应下面的枚举</p><pre class=" language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">/// &lt;summary></span>    <span class="token comment" spellcheck="true">/// 资源加载方式类型。</span>    <span class="token comment" spellcheck="true">/// &lt;/summary></span>    <span class="token keyword">public</span> <span class="token keyword">enum</span> AssetBundleLoadType    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/// &lt;summary></span>        <span class="token comment" spellcheck="true">/// 从文件加载。</span>        <span class="token comment" spellcheck="true">/// &lt;/summary></span>        LoadFromFile <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">/// &lt;summary></span>        <span class="token comment" spellcheck="true">/// 从内存加载。</span>        <span class="token comment" spellcheck="true">/// &lt;/summary></span>        LoadFromMemory<span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">/// &lt;summary></span>        <span class="token comment" spellcheck="true">/// 从内存快速解密加载。</span>        <span class="token comment" spellcheck="true">/// &lt;/summary></span>        LoadFromMemoryAndQuickDecrypt<span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">/// &lt;summary></span>        <span class="token comment" spellcheck="true">/// 从内存解密加载。</span>        <span class="token comment" spellcheck="true">/// &lt;/summary></span>        LoadFromMemoryAndDecrypt<span class="token punctuation">,</span>    <span class="token punctuation">}</span></code></pre><p>（3）Variant：变体<br>（4）ResourceGroups：资源组</p><p>Asset:<br>（1）Guid：资源的guid<br>（2）AssetBundleName：配置中上面所记录的AssetBundleName<br>（3）AssetBundleVariant：变体</p><p>打开AssetBundleEditor窗口后，解析该配置，形成窗口左侧的树状图。</p><h4 id="AssetBundleBuilder-xml"><a href="#AssetBundleBuilder-xml" class="headerlink" title="AssetBundleBuilder.xml"></a>AssetBundleBuilder.xml</h4><p>该配置用来存储AB打包配置。界面如下图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZneTFnOGJtMnptd2M4ajMwenUwdTBqdzguanBn?x-oss-process=image/format,png" alt></p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>UnityGameFramework</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>AssetBundleBuilder</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Settings</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!--内部资源版本号（Internal Resource Version）建议每次自增 1 即可，Game Framework 判定资源包是否需要更新，是使用此编号作为判定依据的。--></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>InternalResourceVersion</span><span class="token punctuation">></span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>InternalResourceVersion</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!--打包平台--></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Platforms</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Platforms</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!--Zip All AssetBundles是否勾选，true为勾选，false为不勾选--></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ZipSelected</span><span class="token punctuation">></span></span>True<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ZipSelected</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!--以下几个配置分别对应AssetBundleOptions的几个Option是否勾选，true为勾选，false为不勾选--></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>UncompressedAssetBundleSelected</span><span class="token punctuation">></span></span>False<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>UncompressedAssetBundleSelected</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>DisableWriteTypeTreeSelected</span><span class="token punctuation">></span></span>False<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>DisableWriteTypeTreeSelected</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>DeterministicAssetBundleSelected</span><span class="token punctuation">></span></span>True<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>DeterministicAssetBundleSelected</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ForceRebuildAssetBundleSelected</span><span class="token punctuation">></span></span>False<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ForceRebuildAssetBundleSelected</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>IgnoreTypeTreeChangesSelected</span><span class="token punctuation">></span></span>False<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>IgnoreTypeTreeChangesSelected</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>AppendHashToAssetBundleNameSelected</span><span class="token punctuation">></span></span>False<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>AppendHashToAssetBundleNameSelected</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ChunkBasedCompressionSelected</span><span class="token punctuation">></span></span>True<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ChunkBasedCompressionSelected</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!--Package输出路径是否勾选，True表示勾选即输出，False表示不勾选即不输出--></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>OutputPackageSelected</span><span class="token punctuation">></span></span>True<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>OutputPackageSelected</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!--Full输出路径是否勾选，True表示勾选即输出，False表示不勾选即不输出--></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>OutputFullSelected</span><span class="token punctuation">></span></span>False<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>OutputFullSelected</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!--Packed输出路径是否勾选，True表示勾选即输出，False表示不勾选即不输出--></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>OutputPackedSelected</span><span class="token punctuation">></span></span>False<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>OutputPackedSelected</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!--Build Event Handler类型名称--></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BuildEventHandlerTypeName</span><span class="token punctuation">></span></span>StarForce.Editor.StarForceBuildEventHandler<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>BuildEventHandlerTypeName</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!--AB输出路径--></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>OutputDirectory</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>OutputDirectory</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Settings</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>AssetBundleBuilder</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>UnityGameFramework</span><span class="token punctuation">></span></span></code></pre><h3 id="AssetBundle-Editor"><a href="#AssetBundle-Editor" class="headerlink" title="AssetBundle Editor"></a>AssetBundle Editor</h3><p>菜单路径：Game Framework/AssetBundle Tools/AssetBundle Editor<br>界面分为三个部分:<br>AssetBundleList、AssetBundleContent、Asset List<br>AssetBundleList是通过读取解析AssetBundleCollection.xml，Asset List是通过AssetBundleEditor.xml里的配置筛选资源而来，而AssetBundleContent部分在是选中AssetBundleList里的一个AB后显示被选中的AB里包含的资源。<br>这三个部分下面都有对应的工具菜单。</p><p><a href="https://gameframework.cn/uncategorized/%e4%bd%bf%e7%94%a8-assetbundle-%e7%bc%96%e8%be%91%e5%99%a8/" target="_blank" rel="noopener">官方文档：使用 AssetBundle 编辑工具</a></p><ol><li><p>AssetBundleList<br>（1）以AssetBundles为根结点<br>（2）这些AB的结点层级路径表示打包后的资源相对路径<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZneTFnOGJvaGwyMTI5ajMxcTkwdTBkeW8uanBn?x-oss-process=image/format,png" alt><br>（3）AB的层级路径参考AssetBundle的Name属性，也就是AssetBundleCollection.xml配置中的AssetBundle的Name<br>（4）AB结点的名称前缀[Packed]表示其Packed，参考AssetBundleEditor脚本中的DrawAssetBundleItem函数<br>（5）AB结点的名称后面 “.{变体名}”，例如StarForce例子中的Dictionaries.en-us这个AB中的en-us表示其变体名<br>（6）通过选中AB后，点击下方的Rename按钮，在第一个输入框中输入层级名称，即可更改其相对路径，第二个输入框是变体名。点击后面ok按钮或者按回车均可改名。<br>（7）不支持多选、不支持拖拽修改相对路径。</p></li><li><p>AssetBundleContent<br>（1）显示左侧选中的AB里所包含的资源清单<br>（2）All：全部选中<br>（3）None：全部不选中<br>（4）AssetSorterType枚举下拉框</p><pre class=" language-csharp"><code class="language-csharp"> <span class="token keyword">public</span> <span class="token keyword">enum</span> AssetSorterType <span class="token punctuation">{</span>     Path<span class="token punctuation">,</span>     Name<span class="token punctuation">,</span>     Guid<span class="token punctuation">,</span> <span class="token punctuation">}</span></code></pre><p>除了修改排序外，还会修改这个界面显示的内容，Path对应资源路径，Name对应资源名，Guid自然是资源的Guid。<br>（5）右边的 0 &gt;&gt; 按钮，数字表示勾选的资源数量，&gt;&gt; 表示将选中的资源移除这个AB，还给右侧的Asset List。（又没有借，哪来的还。。不过&gt;&gt;很形象嘛。。）</p></li><li><p>Asset List<br>资源树状视图，支持多选<br>（1）资源如果包含在某个AB里，其后面会有AssetBundle Name<br>（2）&lt;&lt;0 按钮：同理，数字表示选中的资源数量。功能在于将选中的资源 给左侧选中的A版中，如果此前资源已经在别的AB中，则会先移出。未选中资源 和 未选中AB 这两种情况均无法点击该按钮。<br>（3）&lt;&lt;&lt; 0 按钮：同理，数字表示选中的资源数量。那么与上面按钮有什么区别呢？（不就多了一个 &lt; 吗，难道一个 &lt;&lt; 表示移到中间的Asset List，多了一个 &lt; 还能移到 AssetBundleList 中吗。。）这个按钮用于批量添加AB，将选中的一个或多个资源作为 AssetBundle 名来创建 AssetBundle，并将自身加入到对应的 AssetBundle 里。<br>（4）Hie Assigne：隐藏已经存在于 AssetBundle 中的资源，只列出尚未指定 AssetBundle 的资源。<br>（5）Clean：从所有的 AssetBundle 中清理无效的资源，并移除所有空的 AssetBundle。建议 Save 前总是点一下 Clean 按钮，因为构建 AssetBundle 的时候，Unity 不允许存在无效的资源或者空的 AssetBundle。空的AB在左侧中会显示成灰色，会导致打包失败。<br>（6）Save：保存当前所有 AssetBundle 和资源的状态。<strong>注意保存</strong></p></li></ol><h3 id="AssetBundle-Analyzer"><a href="#AssetBundle-Analyzer" class="headerlink" title="AssetBundle Analyzer"></a>AssetBundle Analyzer</h3><p>待续。</p><h3 id="AssetBundle-Builder"><a href="#AssetBundle-Builder" class="headerlink" title="AssetBundle Builder"></a>AssetBundle Builder</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZneTFnOGJuZ211OGlsajMxZjcwdTB3bDIuanBn?x-oss-process=image/format,png" alt></p><p>界面分为以下几个部分：</p><p>Environment Information：工程的基本信息<br>（1）ProductName：PlayerSettings.productName<br>（2）Company Name：PlayerSettings.companyName<br>（3）Game Identifier：</p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">string</span> GameIdentifier<span class="token punctuation">{</span>    <span class="token keyword">get</span>    <span class="token punctuation">{</span><span class="token preprocessor property">#<span class="token directive keyword">if</span> UNITY_5_6_OR_NEWER</span>        <span class="token keyword">return</span> PlayerSettings<span class="token punctuation">.</span>applicationIdentifier<span class="token punctuation">;</span><span class="token preprocessor property">#<span class="token directive keyword">else</span></span>        <span class="token keyword">return</span> PlayerSettings<span class="token punctuation">.</span>bundleIdentifier<span class="token punctuation">;</span><span class="token preprocessor property">#<span class="token directive keyword">endif</span></span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（4）Applicable Game Version：Application.version<br>以上这些数据在File-&gt;Build Settings-&gt;Player Settings中可以看到</p><p>Platforms：打包平台勾选，支持多选<br>如果一个平台都不勾选，界面下方会出现红色警告：Platform undefined.</p><p>AssetBundle Options：参考UnityEditor.BuildAssetBundleOptions枚举<br>官方文档介绍：<a href="https://docs.unity3d.com/ScriptReference/BuildAssetBundleOptions.html，此处不再赘述" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/BuildAssetBundleOptions.html，此处不再赘述</a><br>AssetBundleBuilderController.cs脚本中的GetBuildAssetBundleOptions函数会将这里勾选的选项转换为BuildAssetBundleOptions</p><pre class=" language-csharp"><code class="language-csharp"><span class="token keyword">private</span> BuildAssetBundleOptions <span class="token function">GetBuildAssetBundleOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    BuildAssetBundleOptions buildOptions <span class="token operator">=</span> BuildAssetBundleOptions<span class="token punctuation">.</span>None<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>UncompressedAssetBundleSelected<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        buildOptions <span class="token operator">|</span><span class="token operator">=</span> BuildAssetBundleOptions<span class="token punctuation">.</span>UncompressedAssetBundle<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>DisableWriteTypeTreeSelected<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        buildOptions <span class="token operator">|</span><span class="token operator">=</span> BuildAssetBundleOptions<span class="token punctuation">.</span>DisableWriteTypeTree<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>DeterministicAssetBundleSelected<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        buildOptions <span class="token operator">|</span><span class="token operator">=</span> BuildAssetBundleOptions<span class="token punctuation">.</span>DeterministicAssetBundle<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ForceRebuildAssetBundleSelected<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        buildOptions <span class="token operator">|</span><span class="token operator">=</span> BuildAssetBundleOptions<span class="token punctuation">.</span>ForceRebuildAssetBundle<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>IgnoreTypeTreeChangesSelected<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        buildOptions <span class="token operator">|</span><span class="token operator">=</span> BuildAssetBundleOptions<span class="token punctuation">.</span>IgnoreTypeTreeChanges<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>AppendHashToAssetBundleNameSelected<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        buildOptions <span class="token operator">|</span><span class="token operator">=</span> BuildAssetBundleOptions<span class="token punctuation">.</span>AppendHashToAssetBundleName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ChunkBasedCompressionSelected<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        buildOptions <span class="token operator">|</span><span class="token operator">=</span> BuildAssetBundleOptions<span class="token punctuation">.</span>ChunkBasedCompression<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> buildOptions<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个BuildAssetBundleOptions最终是传给了BuildPipeline.BuildAssetBundle函数。由于构建过程需要对生成的 AssetBundle 名称进行处理，故这里不允许使用 Append Hash To AssetBundle Name 选项。</p><p>Zip All AssetBundles : 压缩所有 AssetBundles（Zip All AssetBundles）用于指定构建 AssetBundle 后，是否进一步使用 Zip 压缩 AssetBundle 包。</p><p>Build部分:</p><p>Build Event Handler：<br>这里会显示一个实现了IBuildEventHandler接口的所有TypeName的下拉框，例如StarForce工程中StarForceBuildEventHandler类<br>接口包含以下部分：<br>（1）ContinueOnFailure：获取当某个平台生成失败时，是否继续生成下一个平台。<br>（2）PreprocessAllPlatforms：所有平台生成开始前的预处理事件<br>（3）PostprocessAllPlatforms：所有平台生成结束后的后处理事件<br>（4）PreprocessPlatform：某个平台生成开始前的预处理事件<br>（5）PostprocessPlatform：某个平台生成结束后的后处理事件<br>大家可以根据自己的需求定义不同的Handler。例如：StarForce案例中：<br>PreprocessAllPlatforms函数中清空了StreamingAssets文件夹。<br>PostprocessPlatform函数中把outputPackagePath里的文件给拷贝到工程的StreamingAssets目录下。</p><p>Internal Resource Version:<br>内部资源版本号（Internal Resource Version）建议每次自增 1 即可，Game Framework 判定资源包是否需要更新，是使用此编号作为判定依据的。</p><p>Resource Version:<br>资源版本号（Resource Version）根据当前 App 版本号和内部资源版本号自动生成，并不会存储在AssetBundleBuilder.xml中。</p><p>Output Directory：<br>输出目录（Output Directory）用于指定构建过程的结果输出目录，绝对路径，支持直接输入（记得回车）,右边Browse按钮可以选择路径。<br>如果路径无效，下方会提示Output directory is invalid.</p><p>Output Directory选中后，下方会出现Working Path、Output Package Path、Output Full Path、Output Packed Path、Build Report Path这五个子路径。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZneTFnOGJuZ211OGlsajMxZjcwdTB3bDIuanBn?x-oss-process=image/format,png" alt></p><p>当这些配置都配好后，就会出现提示：Ready to build.<br>点击Start Build AssetBundles按钮开始打包，点击Save按钮保存配置到AssetBundleBuilder.xml配置中。</p><p>打包成功：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZneTFnOGJua2ZqdjgzajMxNnMwbzg0YjAuanBn?x-oss-process=image/format,png" alt></p><p>打包完后，再来介绍这五个目录:<br>（1）BuildReport：<br>该目录包含了两个文件，BuildLog.txt和BuildReport.xml。BuildLog.txt用来记录打包日志，打包失败的时候可以通过查看该日志来判断是哪一步出现了问题。AssetBundleBuilderController脚本中通过m_BuildReport.LogInfo接口进行日志记录。而BuildReport.xml文件则用来记录本次打包设置、本次打包的AB信息、AB中包含的Asset信息等等。<br>（2）Full:为可更新模式生成的完整文件包<br>（3）Package：为单机模式生成的文件，若游戏是单机游戏，生成结束后将此目录中对应平台的文件拷贝至 StreamingAssets 后打包 App 即可。<br>（4）Packed：为可更新模式生成的文件<br>（5）Working：Unity生成AssetBundle时的工作目录</p><p>请注意：<br>不知道从哪个版本开始，GameResourceVersion_x_x_x.xml文件不再生成。<br>相关数据可以在BuildReport目录下的BuildLog.txt中查看到，如下：</p><pre><code>[15:51:32.383][INFO] Process version list for &#39;MacOS&#39; complete, version list path is &#39;/Users/teitomonari/Documents/WorkSpace/UnityProjects/Study/StarForce/StarForce/AssetBundle/Full/0_1_0_1/MacOS/version.7fe1ca32.dat&#39;, length is &#39;11641&#39;, hash code is &#39;2145503794[0x7FE1CA32]&#39;, zip length is &#39;4100&#39;, zip hash code is &#39;111937434[0x06AC079A]&#39;.</code></pre><h3 id="Build-AssetBundle"><a href="#Build-AssetBundle" class="headerlink" title="Build AssetBundle"></a>Build AssetBundle</h3><p>待续。</p><h2 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h2><p>待续。</p><h2 id="API-Reference"><a href="#API-Reference" class="headerlink" title="API Reference"></a>API Reference</h2><p>待续。</p><h1 id="使用UnityGameFramework编辑器出现的常见问题记录"><a href="#使用UnityGameFramework编辑器出现的常见问题记录" class="headerlink" title="使用UnityGameFramework编辑器出现的常见问题记录"></a>使用UnityGameFramework编辑器出现的常见问题记录</h1><h2 id="1-AssetBundleEditor界面中的Asset列表是空的？"><a href="#1-AssetBundleEditor界面中的Asset列表是空的？" class="headerlink" title="1. AssetBundleEditor界面中的Asset列表是空的？"></a>1. AssetBundleEditor界面中的Asset列表是空的？</h2><p>待续。</p>]]></content>
      
      
      <categories>
          
          <category> GF源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GF源码解读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之二十九：资源弱引用文件选择器</title>
      <link href="/2020/03/28/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-jiu-zi-yuan-ruo-yin-yong-wen-jian-xuan-ze-qi/"/>
      <url>/2020/03/28/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-jiu-zi-yuan-ruo-yin-yong-wen-jian-xuan-ze-qi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>笔记目录<br>@[toc]</p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>AdvancedDropdown只在Unity 2019下才可用。。。</p><h1 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h1><p>文件选择器顾名思义是用来选中文件用的，那么与<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZneTFnN2U3Zmdscms1ajMwOWowMHNtd3ouanBn?x-oss-process=image/format,png" alt><br>上图中Unity自带的点击右边的小圆点 弹出文件搜索框有什么区别呢？</p><p>工具界面如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZneTFnN2U3Z3BtdHE2ajMwYnQwYTc3NHouanBn?x-oss-process=image/format,png" alt></p><p>其中点击Select按钮，弹出文件搜索框（类比Add Component按钮点击后弹出的框）,根据资源类型筛选后形成的资源树状结构显示在下面的框中，点击其中一个结点进入子树，点击右侧的X按钮进行清空。（小声哔哔：看起来好像没啥用）</p><p>gif动图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZneTFnN2U4cnE5Z2JmZzMwYWkwOTRram0uZ2lm" alt></p><h1 id="资源弱引用"><a href="#资源弱引用" class="headerlink" title="资源弱引用"></a>资源弱引用</h1><p>首先说明一下个人理解的资源弱引用：不直接引用游戏资源，通过序列化存储一些用来从资源管理系统中加载资源的参数，来间接引用资源，这些参数可以称之为地址（不要强行沾边Addressable）。使用一个地址来加载资源，资源如何更改，地址都不要变，保证地址唯一性。无论是使用Resources文件夹进行资源加载管理、还是使用AssetBundle进行资源加载管理，都可以使用弱引用。</p><p>弱引用需要存储的数据：</p><ul><li>Guid<br>Editor可使用Guid来加载资源、定位资源，保证资源的路径修改后依然可以定位到资源。</li><li>用来加载的数据<br>取决于你的资源管理系统如何加载资源，如果使用Resources加载，可以存储Resources文件夹下的路径</li></ul><p>WeakReference弱引用基类，其中存储了Guid<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZneTFnN2U3dzFoY25vajMwdmUwcW03OGEuanBn?x-oss-process=image/format,png" alt></p><p>各种资源类型对应的弱引用类型<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZneTFnN2U3eDNyNzVwajMwankwY2l0YWEuanBn?x-oss-process=image/format,png" alt></p><h1 id="文件选择器"><a href="#文件选择器" class="headerlink" title="文件选择器"></a>文件选择器</h1><p>该文件选择器参考的Editor源码中AddComponent部分</p><p><a href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/Inspector/AddComponent/ComponentDropdownItem.cs" target="_blank" rel="noopener">Unity-Technologies Add Component Editor源码地址</a></p><p><a href="https://docs.unity3d.com/ScriptReference/IMGUI.Controls.AdvancedDropdown.html" target="_blank" rel="noopener">AdvancedDropdown官方介绍</a></p><p>AdvancedDropdown部分此文不过多介绍，可能会另外开篇。本例中只存储了guid，其余数据在文件被选择的时候也可以赋值。</p><h1 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h1><p><a href="https://github.com/JingFengJi/AssetReferenceSelectEditor.git" target="_blank" rel="noopener">Github仓库地址</a></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python工具之一：九宫格图片极致裁剪</title>
      <link href="/2020/03/28/python-gong-ju-zhi-yi-jiu-gong-ge-tu-pian-ji-zhi-cai-jian/"/>
      <url>/2020/03/28/python-gong-ju-zhi-yi-jiu-gong-ge-tu-pian-ji-zhi-cai-jian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Python工具之一：九宫格图片极致裁剪"><a href="#Python工具之一：九宫格图片极致裁剪" class="headerlink" title="Python工具之一：九宫格图片极致裁剪"></a>Python工具之一：九宫格图片极致裁剪</h1><h2 id="工具用途"><a href="#工具用途" class="headerlink" title="工具用途"></a>工具用途</h2><p>在读到文章(<a href="https://blog.uwa4d.com/archives/PSD4UGUI.html)时，文章中提到“e.通过设定参数即可自动生成九宫图片，优化九宫图片面积”，引发的思考：如何优化九宫图片面积？九宫图片作为拉伸图片使用，拉伸区域越小越能缩小图片面积，达到优化的目的。进一步找到文章（https://gameinstitute.qq.com/community/detail/103423" target="_blank" rel="noopener">https://blog.uwa4d.com/archives/PSD4UGUI.html)时，文章中提到“e.通过设定参数即可自动生成九宫图片，优化九宫图片面积”，引发的思考：如何优化九宫图片面积？九宫图片作为拉伸图片使用，拉伸区域越小越能缩小图片面积，达到优化的目的。进一步找到文章（https://gameinstitute.qq.com/community/detail/103423</a>)</p><p>文章中提到下图</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzQuc2luYWltZy5jbi9sYXJnZS8wMDZ0TmM3OWd5MWc2MGRiMHZocmdqMzFjcTAzMmpzYS5qcGc" alt></p><p>将连续相同的行（列）裁剪掉，只保留一行（列）即可，依次达到九宫图片面积缩小的目的。</p><p>（ps：讲道理，图片处理软件里应该能精准控制裁剪的，为啥要程序写工具来做这件事？美术表示我不会…）</p><p>本文中并没有写的上文中那么详细，我的最终目的是给Unity中使用的九宫图片做裁剪，因此文章中有部分内容跟Unity沾边，不过不影响工具的使用，工具使用Python开发。</p><p>如下图：Unity中两纯色像素之间有颜色过渡，因此工具没有将图片的连续相同行（列）裁剪到只保留一行（列），而是三行（列）。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzEuc2luYWltZy5jbi9sYXJnZS8wMDZ0TmM3OWd5MWc2MGRmN2I1M2xqMzBjaDBiendlaS5qcGc" alt></p><h2 id="开发思考"><a href="#开发思考" class="headerlink" title="开发思考"></a>开发思考</h2><p>（1）如何加载、保存、读写一个image，本工具使用OpenCV2</p><p>（2）如何判断图片的两行（列）是否完全相同</p><p>（3）如何计算出图片的最佳九宫区域</p><p>（4）如何裁剪九宫区域</p><h2 id="裁剪结果"><a href="#裁剪结果" class="headerlink" title="裁剪结果"></a>裁剪结果</h2><p><img src="https://img-blog.csdnimg.cn/20190815170341740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看起来很像变成了一个圆形，其实四条边上有三行（列）像素是九宫区域</p><h2 id="代码介绍"><a href="#代码介绍" class="headerlink" title="代码介绍"></a>代码介绍</h2><pre><code># 比较两行是否相等# 相等返回true，否则返回falsedef equal_row_pixel(img,row1,row2):    height = img.shape[0]        #将tuple中的元素取出，赋值给height，width，channels    width = img.shape[1]    channels = img.shape[2]    if(row1 &lt; 0 or row1 &gt;= height):        return False    if(row2 &lt; 0 or row2 &gt;= height):        return False    for col in range(width):        for channel in range(channels):            if(img[row1][col][channel] != img[row2][col][channel]):                return False    return True</code></pre><pre><code># 比较两列是否相等# 相等返回true，否则返回falsedef equal_col_pixel(img,col1,col2):    height = img.shape[0]        #将tuple中的元素取出，赋值给height，width，channels    width = img.shape[1]    channels = img.shape[2]    if(col1 &lt; 0 or col1 &gt;= width):            return False    if(col2 &lt; 0 or col2 &gt;= width):        return False    for row in range(height):        for channel in range(channels):            if(img[row][col1][channel] != img[row][col2][channel]):                return False    return True</code></pre><pre><code># 横向是否可以处理九宫# img:图片# continuous_col_num:连续的列数，大于等于这个值判定为横向可以九宫处理def horizontal_slice(img,continuous_col_num):    cur_begin_col_index = 0    cur_end_col_index = 0    slice_begin_col_index = 0    slice_end_col_index = 0    height = img.shape[0]    width = img.shape[1]    channels = img.shape[2]    for col in range(width):        if(col &lt; width - 1):            if(equal_col_pixel(img,col,col+1) == False):                # begin与end指向不是同一列时，判断连续列数是否满足九宫条件                if((cur_begin_col_index != cur_end_col_index) and (cur_end_col_index - cur_begin_col_index &gt;= continuous_col_num) and (cur_end_col_index - cur_begin_col_index &gt; slice_end_col_index - slice_begin_col_index)):                    # 已经达到了连续列数，满足九宫条件                    slice_begin_col_index = cur_begin_col_index                    slice_end_col_index = cur_end_col_index                cur_begin_col_index = col + 1                cur_end_col_index = col + 1            else:                # 相等，end后移一位                cur_end_col_index = col + 1    if(slice_end_col_index - slice_begin_col_index &gt;= continuous_col_num):        return True,slice_begin_col_index,slice_end_col_index    else:        return False,0,0</code></pre><pre><code># 纵向是否可以处理九宫def vertical_slice(img,continuous_row_num):    cur_begin_row_index = 0    cur_end_row_index = 0    slice_begin_row_index = 0    slice_end_row_index = 0    height = img.shape[0]    width = img.shape[1]    channels = img.shape[2]    for row in range(height):        if(row &lt; height - 1):            if(equal_row_pixel(img,row,row+1) == False):                if((cur_begin_row_index != cur_end_row_index) and (cur_end_row_index - cur_begin_row_index &gt;= continuous_row_num) and (cur_end_row_index - cur_begin_row_index &gt; slice_end_row_index - slice_begin_row_index)):                    slice_begin_row_index = cur_begin_row_index                    slice_end_row_index = cur_end_row_index                cur_begin_row_index = row + 1                cur_end_row_index = row + 1            else:                cur_end_row_index = row + 1    if(slice_end_row_index - slice_begin_row_index &gt;= continuous_row_num):        return True,slice_begin_row_index,slice_end_row_index    else:        return False,0,0</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code>#!/usr/bin/python# -*- coding: UTF-8 -*- import cv2from PIL import Imageimport numpy as npimport osimport tkFileDialogimport Tkinterimport tkMessageBox# 比较两行是否相等# 相等返回true，否则返回falsedef equal_row_pixel(img,row1,row2):    height = img.shape[0]        #将tuple中的元素取出，赋值给height，width，channels    width = img.shape[1]    channels = img.shape[2]    if(row1 &lt; 0 or row1 &gt;= height):        return False    if(row2 &lt; 0 or row2 &gt;= height):        return False    for col in range(width):        for channel in range(channels):            if(img[row1][col][channel] != img[row2][col][channel]):                return False    return True# 比较两列是否相等# 相等返回true，否则返回falsedef equal_col_pixel(img,col1,col2):    height = img.shape[0]        #将tuple中的元素取出，赋值给height，width，channels    width = img.shape[1]    channels = img.shape[2]    if(col1 &lt; 0 or col1 &gt;= width):            return False    if(col2 &lt; 0 or col2 &gt;= width):        return False    for row in range(height):        for channel in range(channels):            if(img[row][col1][channel] != img[row][col2][channel]):                return False    return True# 横向是否可以处理九宫# img:图片# continuous_col_num:连续的列数，大于等于这个值判定为横向可以九宫处理def horizontal_slice(img,continuous_col_num):    cur_begin_col_index = 0    cur_end_col_index = 0    slice_begin_col_index = 0    slice_end_col_index = 0    height = img.shape[0]    width = img.shape[1]    channels = img.shape[2]    for col in range(width):        if(col &lt; width - 1):            if(equal_col_pixel(img,col,col+1) == False):                # begin与end指向不是同一列时，判断连续列数是否满足九宫条件                if((cur_begin_col_index != cur_end_col_index) and (cur_end_col_index - cur_begin_col_index &gt;= continuous_col_num) and (cur_end_col_index - cur_begin_col_index &gt; slice_end_col_index - slice_begin_col_index)):                    # 已经达到了连续列数，满足九宫条件                    slice_begin_col_index = cur_begin_col_index                    slice_end_col_index = cur_end_col_index                cur_begin_col_index = col + 1                cur_end_col_index = col + 1            else:                # 相等，end后移一位                cur_end_col_index = col + 1    if(slice_end_col_index - slice_begin_col_index &gt;= continuous_col_num):        return True,slice_begin_col_index,slice_end_col_index    else:        return False,0,0# 纵向是否可以处理九宫def vertical_slice(img,continuous_row_num):    cur_begin_row_index = 0    cur_end_row_index = 0    slice_begin_row_index = 0    slice_end_row_index = 0    height = img.shape[0]    width = img.shape[1]    channels = img.shape[2]    for row in range(height):        if(row &lt; height - 1):            if(equal_row_pixel(img,row,row+1) == False):                if((cur_begin_row_index != cur_end_row_index) and (cur_end_row_index - cur_begin_row_index &gt;= continuous_row_num) and (cur_end_row_index - cur_begin_row_index &gt; slice_end_row_index - slice_begin_row_index)):                    slice_begin_row_index = cur_begin_row_index                    slice_end_row_index = cur_end_row_index                cur_begin_row_index = row + 1                cur_end_row_index = row + 1            else:                cur_end_row_index = row + 1    if(slice_end_row_index - slice_begin_row_index &gt;= continuous_row_num):        return True,slice_begin_row_index,slice_end_row_index    else:        return False,0,0# 标记Sprite的九宫区域def tag_image_slice_area(img,slice_row_begin,slice_row_end,slice_col_begin,slice_col_end,color):    height = img.shape[0]    width = img.shape[1]    channels = img.shape[2]    for row in range(height):    #遍历每一行        for col in range(width): #遍历每一列            if((row &gt;= slice_row_begin and row &lt;= slice_row_end and slice_row_begin != slice_row_end) or (col &gt;= slice_col_begin and col &lt;= slice_col_end and slice_col_begin != slice_col_end)):                alter_image_pixel_color(img,row,col,color)    return img# 修改img指定像素的颜色# img:修改的img# row:行索引# col:列索引# color:颜色rgb数组def alter_image_pixel_color(img,row,col,color):    img.itemset((row, col, 0), color[0])    img.itemset((row, col, 1), color[1])    img.itemset((row, col, 2), color[2])# 九宫区域裁剪def tailor_image_slice_area(img,slice_row_begin,slice_row_end,slice_col_begin,slice_col_end):    height = img.shape[0]    width = img.shape[1]    new_width = width - (slice_col_end - slice_col_begin)    new_height = height - (slice_row_end - slice_row_begin)    target = np.zeros(shape=(new_height,new_width,img.shape[2]), dtype=np.uint8)    # img[0:4,0:3] 第0行-第4行，第0列到第3列的交叉区域    # 左上    roiImg = img[0:slice_row_begin,0:slice_col_begin]    target[0:slice_row_begin,0:slice_col_begin] = roiImg    # 右上    roiImg = img[0:slice_row_begin,slice_col_end:width]    target[0:slice_row_begin,slice_col_begin:new_width] = roiImg    # 左下    roiImg = img[slice_row_end:height,0:slice_col_begin]    target[slice_row_begin:new_height,0:slice_col_begin] = roiImg    # 右下    roiImg = img[slice_row_end:height,slice_col_end:width]    target[slice_row_begin:new_height,slice_col_begin:new_width] = roiImg    return targetdef load_sprite():    continuous_row_num_input_str = continuous_row_num_input.get() #获取文本框内容    continuous_col_num_input_str = continuous_col_num_input.get()    continuous_row_num = 0    continuous_col_num = 0    try:        if continuous_row_num_input_str != &quot;&quot;:            continuous_row_num = float(continuous_row_num_input_str)        if continuous_col_num_input_str != &quot;&quot;:            continuous_col_num = float(continuous_col_num_input_str)    except ValueError:        tkMessageBox.showinfo( &quot;Error&quot;, &quot;无效的线宽输入&quot;)        return    if continuous_row_num &lt;= 0 or continuous_col_num &lt;= 0:        tkMessageBox.showinfo( &quot;Error&quot;, &quot;无效的线宽输入&quot;)        return    fname = tkFileDialog.askopenfilename(title=u&quot;选择文件&quot;)    img1 = cv2.imread(fname,cv2.IMREAD_UNCHANGED)    a1,b1,c1 = horizontal_slice(img1,continuous_col_num)    a2,b2,c2 = vertical_slice(img1,continuous_row_num)    # 九宫区域保留在3像素的宽高    b1 = b1 + 1    c1 = c1 - 1    b2 = b2 + 1    c2 = c2 - 1    if toggle_tailor_hor.get() == 0:        b1 = 0        c1 = 0    if toggle_tailor_ver.get() == 0:        b2 = 0        c2 = 0    new_sprite = tailor_image_slice_area(img1,b2,c2,b1,c1)    cv2.imwrite(fname, new_sprite)    print(fname)root = Tkinter.Tk()root.geometry(&#39;400x300&#39;)root.title(&quot;Sprite九宫区域极致裁剪修改器&quot;)frame = Tkinter.Frame(root)frame.pack()toggle_tailor_hor = Tkinter.IntVar()toggle_tailor_ver = Tkinter.IntVar()Tkinter.Checkbutton(root, text = &quot;是否横向九宫处理&quot;, variable = toggle_tailor_hor,onvalue = 1, offvalue = 0).pack()Tkinter.Checkbutton(root, text = &quot;是否纵向九宫迷宫&quot;, variable = toggle_tailor_ver,onvalue = 1, offvalue = 0).pack()Tkinter.Label(frame, text=&quot;横向最小连续列数&quot;).pack()continuous_row_num_input = Tkinter.Entry(frame)continuous_row_num_input.pack()Tkinter.Label(frame, text=&quot;纵向最小连续行数&quot;).pack()continuous_col_num_input = Tkinter.Entry(frame)continuous_col_num_input.pack()load_sprite_button = Tkinter.Button(root, text=&quot;加载Sprite文件并修改&quot;,command=load_sprite)load_sprite_button.pack()root.mainloop()</code></pre><h2 id="工具界面"><a href="#工具界面" class="headerlink" title="工具界面"></a>工具界面</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzQuc2luYWltZy5jbi9sYXJnZS8wMDZ0TmM3OWd5MWc2MGRxMnRuMmdqMzBtODBodzc2NC5qcGc" alt></p><p>点击按钮”加载Sprite文件并修改“后，打开文件框选中要处理的图片后进行处理，覆盖原图片，可以根据自己的需要进行修改。</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Border自动设置工具</title>
      <link href="/2020/03/28/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-ba-sprite-border-zi-dong-she-zhi-gong-ju/"/>
      <url>/2020/03/28/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-ba-sprite-border-zi-dong-she-zhi-gong-ju/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Unity编辑器拓展之二十八：Sprite-Border自动设置工具"><a href="#Unity编辑器拓展之二十八：Sprite-Border自动设置工具" class="headerlink" title="Unity编辑器拓展之二十八：Sprite Border自动设置工具"></a>Unity编辑器拓展之二十八：Sprite Border自动设置工具</h1><h3 id="1-0-功能介绍"><a href="#1-0-功能介绍" class="headerlink" title="1.0 功能介绍"></a>1.0 功能介绍</h3><p>自动计算出九宫格Sprite 的border数据并直接赋值保存的工具。【纯属偷懒，可能各位觉得没啥用吧，哈哈】</p><p>当需要为一个九宫格Sprite 设置Border数据时，需要打开Sprite Editor，然后输入Border数据。</p><p>工具会直接计算横向、纵向连续完全相同的列数、行数（当然连续区域取最大的），当计算出的九宫区域满足条件时（我设定的条件是连续列数或者行数有个最小值设定），就任务该图可以处理为九宫格Sprite。</p><p>以上九宫格Sprite，又称为 点九图【废话】。</p><h3 id="2-0-源码"><a href="#2-0-源码" class="headerlink" title="2.0 源码"></a>2.0 源码</h3><p>脚本放置在Editor文件夹下</p><pre><code>using System.IO;using UnityEditor;using UnityEngine;public class SpriteImporterTool : UnityEditor.Editor{    public static int continuousColNum = 10; //continuousColNum:连续的列数，大于等于这个值判定为横向可以九宫处理    public static int continuousRowNum = 10; //continuousRowNum:连续的行数，大于等于这个值判定为纵向可以九宫处理    //自动计算Sprite Border数据    [MenuItem(&quot;Assets/SpriteBorder/AutoSetSpriteBorder&quot;, false, 500)]    public static void AutoSetSpriteBorder()    {        foreach (var spriteAsset in Selection.objects)        {            AutoSetSpriteBorder(AssetDatabase.GetAssetPath(spriteAsset));        }    }     //设置Sprite Border为Zero    [MenuItem(&quot;Assets/SpriteBorder/Reset Zero&quot;, false)]    public static void AutoSetSpriteBorderZero()    {        foreach (var spriteAsset in Selection.objects)        {            SetSpriteBorder(AssetDatabase.GetAssetPath(spriteAsset), Vector4.zero);        }    }    private static void AutoSetSpriteBorder(string spriteAssetPath)    {        TextureImporter textureImporter = AssetImporter.GetAtPath(spriteAssetPath) as TextureImporter;        if (textureImporter != null &amp;&amp; textureImporter.textureType == TextureImporterType.Sprite)        {            Sprite sprite = AssetDatabase.LoadAssetAtPath&lt;Sprite&gt;(spriteAssetPath);            Vector4 border = Vector4.zero;            GetBorderSliceInfo(sprite.texture, continuousColNum, continuousRowNum, ref border);            if (border != Vector4.zero)            {                textureImporter.spriteBorder = border;                EditorUtility.SetDirty(sprite);                AssetDatabase.SaveAssets();                AssetDatabase.Refresh();            }        }    }    private static void SetSpriteBorder(string spriteAssetPath, Vector4 border)    {        TextureImporter textureImporter = AssetImporter.GetAtPath(spriteAssetPath) as TextureImporter;        if (textureImporter != null &amp;&amp; textureImporter.textureType == TextureImporterType.Sprite)        {            Sprite sprite = AssetDatabase.LoadAssetAtPath&lt;Sprite&gt;(spriteAssetPath);            textureImporter.spriteBorder = border;            EditorUtility.SetDirty(sprite);            AssetDatabase.SaveAssets();            AssetDatabase.Refresh();        }    }    public static void GetBorderSliceInfo(Texture2D texture, int continuousColNum, int continuousRowNum,        ref Vector4 border)    {        int width = texture.width;        int height = texture.height;        //咳咳，这里的命名规则请忽略，从另一个python工具拷贝过来        int cur_begin_col_index = 0;        int cur_end_col_index = 0;        int slice_begin_col_index = 0;        int slice_end_col_index = 0;        Texture2D readTexture2D = GetReadTexture2D(texture);        for (int col = 0; col &lt; width - 1; col++)        {            if (EqualColPixel(readTexture2D, col, col + 1) == false)            {                if ((cur_begin_col_index != cur_end_col_index) &amp;&amp;                    (cur_end_col_index - cur_begin_col_index &gt;= continuousColNum) &amp;&amp;                    (cur_end_col_index - cur_begin_col_index &gt; slice_end_col_index - slice_begin_col_index))                {                    slice_begin_col_index = cur_begin_col_index;                    slice_end_col_index = cur_end_col_index;                }                cur_begin_col_index = col + 1;                cur_end_col_index = col + 1;            }            else            {                cur_end_col_index = col + 1;            }        }        int cur_begin_row_index = 0;        int cur_end_row_index = 0;        int slice_begin_row_index = 0;        int slice_end_row_index = 0;        for (int row = 0; row &lt; height - 1; row++)        {            if (EqualRowPixel(readTexture2D, row, row + 1) == false)            {                if ((cur_begin_row_index != cur_end_row_index) &amp;&amp;                    (cur_end_row_index - cur_begin_row_index &gt;= continuousRowNum) &amp;&amp;                    (cur_end_row_index - cur_begin_row_index &gt; slice_end_row_index - slice_begin_row_index))                {                    slice_begin_row_index = cur_begin_row_index;                    slice_end_row_index = cur_end_row_index;                }                cur_begin_row_index = row + 1;                cur_end_row_index = row + 1;            }            else            {                cur_end_row_index = row + 1;            }        }        if (slice_end_col_index - slice_begin_col_index &lt; continuousColNum)        {            slice_begin_col_index = 0;            slice_end_col_index = width - 1;        }        if (slice_end_row_index - slice_begin_row_index &lt; continuousRowNum)        {            slice_begin_row_index = 0;            slice_end_row_index = height - 1;        }        //LTRB        //row 是纵向的  T B        //col 是横向的  L R        border = new Vector4(slice_begin_col_index, slice_begin_row_index, width - slice_end_col_index - 1,            height - slice_end_row_index - 1);    }    public static string GetAssetFullPath(UnityEngine.Object asset)    {        return System.Environment.CurrentDirectory + Path.DirectorySeparatorChar +               AssetDatabase.GetAssetPath(asset);    }    public static Texture2D GetReadTexture2D(Texture texture)    {        string textureFilePath = GetAssetFullPath(texture);        FileStream fileStream = new FileStream(textureFilePath, FileMode.Open, FileAccess.Read);        fileStream.Seek(0, SeekOrigin.Begin);        byte[] bytes = new byte[fileStream.Length];        fileStream.Read(bytes, 0, (int) fileStream.Length);        fileStream.Close();        fileStream.Dispose();        Texture2D new_texture = new Texture2D(texture.width, texture.height);        new_texture.LoadImage(bytes);        return new_texture;    }    /// &lt;summary&gt;    /// 比较两行像素是否完全相等    /// &lt;/summary&gt;    /// &lt;param name=&quot;texture&quot;&gt;isReadable为true，可读的texture&lt;/param&gt;    /// &lt;param name=&quot;row1&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;row2&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static bool EqualRowPixel(Texture2D texture, int row1, int row2)    {        Color[] row1Colors = texture.GetPixels(0, row1, texture.width, 1);        Color[] row2Colors = texture.GetPixels(0, row2, texture.width, 1);        for (int i = 0; i &lt; row1Colors.Length; i++)        {            if (!row1Colors[i].Equals(row2Colors[i]))            {                return false;            }        }        return true;    }    /// &lt;summary&gt;    /// 比较两列像素是否完全相等    /// &lt;/summary&gt;    /// &lt;param name=&quot;texture&quot;&gt;isReadable为true，可读的texture&lt;/param&gt;    /// &lt;param name=&quot;col1&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;col2&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static bool EqualColPixel(Texture2D texture, int col1, int col2)    {        Color[] col1Colors = texture.GetPixels(col1, 0, 1, texture.height);        Color[] col2Colors = texture.GetPixels(col2, 0, 1, texture.height);        for (int i = 0; i &lt; col1Colors.Length; i++)        {            if (!col1Colors[i].Equals(col2Colors[i]))            {                return false;            }        }        return true;    }}</code></pre><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之二十七：TextMeshPro的TMP_SpriteAsset图文混排图集快捷更新工具</title>
      <link href="/2020/03/28/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-qi-textmeshpro-de-tmp-spriteasset-tu-wen-hun-pai-tu-ji-kuai-jie-geng-xin-gong-ju/"/>
      <url>/2020/03/28/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-qi-textmeshpro-de-tmp-spriteasset-tu-wen-hun-pai-tu-ji-kuai-jie-geng-xin-gong-ju/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Unity编辑器拓展之二十七：TextMeshPro的TMP-SpriteAsset图文混排图集快捷更新工具"><a href="#Unity编辑器拓展之二十七：TextMeshPro的TMP-SpriteAsset图文混排图集快捷更新工具" class="headerlink" title="Unity编辑器拓展之二十七：TextMeshPro的TMP_SpriteAsset图文混排图集快捷更新工具"></a>Unity编辑器拓展之二十七：TextMeshPro的TMP_SpriteAsset图文混排图集快捷更新工具</h1><h2 id="1-TextMeshPro的SpriteAsset制作"><a href="#1-TextMeshPro的SpriteAsset制作" class="headerlink" title="1.TextMeshPro的SpriteAsset制作"></a>1.TextMeshPro的SpriteAsset制作</h2><p>此文不再赘述，参考此文：<a href="https://blog.csdn.net/qq_37057633/article/details/81120583" target="_blank" rel="noopener">https://blog.csdn.net/qq_37057633/article/details/81120583</a></p><h2 id="2-工具使用场景"><a href="#2-工具使用场景" class="headerlink" title="2.工具使用场景"></a>2.工具使用场景</h2><p>当图文混排图集需要加一个新图时，需要重新按照上文的流程重新打一遍Json(Array)格式和一遍Unity-Texture2D Sprite格式的，打完之后，图集里的图文位置就会发生变化，TMP_SpriteAsset里存储的spriteGlyphTable和spriteCharacterTable并不会自动更新（包括旧的sprite相关数据和新增的sprite数据），而且旧的图文混排图集里的Sprite ID也应该保持不变，如果我们手动修改了Sprite的GlyphMetrics数据，这个数据也会被重打的覆盖掉，使得之前的数据丢失。那么，开发一款快捷更新图文混排的工具就十分有必要。</p><h2 id="3-工具介绍"><a href="#3-工具介绍" class="headerlink" title="3.工具介绍"></a>3.工具介绍</h2><h2 id="3-1-工具界面"><a href="#3-1-工具界面" class="headerlink" title="3.1 工具界面"></a>3.1 工具界面</h2><p><img src="https://img-blog.csdnimg.cn/20190809104416516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-2-工具功能"><a href="#3-2-工具功能" class="headerlink" title="3.2 工具功能"></a>3.2 工具功能</h2><p>1.缓存数据</p><p>主要是缓存旧的图集数据，spriteGlyphTable和spriteCharacterTable</p><p>2.一键打Json格式图集</p><p>使用命令行打图集，此文不再赘述，参考：<a href="https://blog.csdn.net/u014065445/article/details/54289787" target="_blank" rel="noopener">https://blog.csdn.net/u014065445/article/details/54289787</a></p><p>使用命令行打json格式文件</p><p>3.一键打Unity格式图集</p><p>使用命令行打Unity格式图集</p><pre><code>    /// &lt;summary&gt;    /// 打Unity格式图集    /// &lt;/summary&gt;    private void UnitySpriteTexturePacker()    {        curTime = System.DateTime.Now;        //获取打Unity格式的TexturePacker命令        string cmd = TexturePackerCommond.GetPackCommond(arangeSpritesFolderPath,arrangeIconAtlasPngPath,arrangeIconAtlasTpsheetFilePath);        //使用ShellHelper生成一个ShellRequest对象        ShellHelper.ShellRequest request = ShellHelper.ProcessCommand(cmd,null);        EditorUtility.DisplayProgressBar(&quot;批量处理中...&quot;,&quot;Shell脚本生成Json图集信息...&quot;, 0);        //注册命令执行完回调        request.onDone  += ()=&gt;        {            {                //打包结束                EditorUtility.DisplayProgressBar(&quot;批量处理中...&quot;,&quot;Shell脚本执行完毕...开始打图集...&quot;, 0);                AssetDatabase.SaveAssets();                AssetDatabase.Refresh();                CreateUIAtlas();            }        };        //注册命令执行错误的回调        request.onError += ()=&gt;        {            Debug.LogError(&quot;Texture Packer Error!!! Please Check Your Config&quot;);            EditorUtility.ClearProgressBar();        };    }</code></pre><p>4.数据更新</p><p>解析Tpsheet格式文件，从中拿到所有Sprite的GlyphRect数据，【注意】Tpsheet文件中Sprite的GlyphRect数据是以SpriteName区分的，因此TMP_SpriteAsset里的spriteCharacterTable里的name一定要正确，不然数据会错位。</p><p><img src="https://img-blog.csdnimg.cn/20190809104455334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-使用说明"><a href="#4-使用说明" class="headerlink" title="4.使用说明"></a>4.使用说明</h2><p>1.TexturePacker_PATH更改为自己电脑的TexturePacker路径</p><p>2.工具开发环境是mac端，windows端下自行类比修改</p><p>3.需要导入TexturePackerImporter工具配合TexturePacker打出来的图集使用</p><p>4.代码中的路径自行修改</p><h2 id="5-工具仓库地址"><a href="#5-工具仓库地址" class="headerlink" title="5.工具仓库地址"></a>5.工具仓库地址</h2><p><a href="https://github.com/JingFengJi/UpdateSpriteAssetTool.git" target="_blank" rel="noopener">https://github.com/JingFengJi/UpdateSpriteAssetTool.git</a></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之二十六：基于UGUI的Sprite引用查询</title>
      <link href="/2020/03/28/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-liu-ji-yu-ugui-de-sprite-yin-yong-cha-xun/"/>
      <url>/2020/03/28/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-liu-ji-yu-ugui-de-sprite-yin-yong-cha-xun/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="基于UGUI的Sprite引用查询"><a href="#基于UGUI的Sprite引用查询" class="headerlink" title="基于UGUI的Sprite引用查询"></a>基于UGUI的Sprite引用查询</h1><p>使用TexturePacker打的图集，sprite引用查询工具示意图如下。<br><img src="https://img-blog.csdnimg.cn/20190316204950284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>菜单栏：<br>1、选择图集，输入sprite name，一键搜索按钮，导出搜索数据成CSV格式，一键断开所有引用<br>2、界面下方是搜索结果的Tree视图。</p><p>下面是操作示意图。<br><img src="https://img-blog.csdnimg.cn/20190316210635180.gif" alt="在这里插入图片描述"></p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>图片从一个图集更改到别的图集，如果是用Unity的打图集方式（PackingTag），这种场景就方便多了，修改PackingTag即可。使用TexturePacker打的图集，就没办法这样了。</p><h1 id="Code地址"><a href="#Code地址" class="headerlink" title="Code地址"></a>Code地址</h1><p><a href="https://github.com/JingFengJi/SpriteReferenceCheck" target="_blank" rel="noopener">https://github.com/JingFengJi/SpriteReferenceCheck</a></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之二十五：图集SpriteMetaData数据拷贝</title>
      <link href="/2020/03/28/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-wu-tu-ji-spritemetadata-shu-ju-kao-bei/"/>
      <url>/2020/03/28/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-wu-tu-ji-spritemetadata-shu-ju-kao-bei/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="图集SpriteMetaData数据拷贝"><a href="#图集SpriteMetaData数据拷贝" class="headerlink" title="图集SpriteMetaData数据拷贝"></a>图集SpriteMetaData数据拷贝</h1><p>关于SpriteMetaData类：</p><p>用于生成精灵的编辑器数据。<br>官方文档介绍：<a href="https://docs.unity3d.com/2017.2/Documentation/ScriptReference/SpriteMetaData.html" target="_blank" rel="noopener">https://docs.unity3d.com/2017.2/Documentation/ScriptReference/SpriteMetaData.html</a></p><p><img src="https://img-blog.csdnimg.cn/20190316203159839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="工具界面"><a href="#工具界面" class="headerlink" title="工具界面"></a>工具界面</h2><p><img src="https://img-blog.csdnimg.cn/20190316203347915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="工具使用场景"><a href="#工具使用场景" class="headerlink" title="工具使用场景"></a>工具使用场景</h2><p>适用于游戏中存在多套皮肤图集</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>拖入数据源图集的texture、克隆图集的texture，然后点击Copy，就会将clone texture 的Sprite data 拷贝到clone texture 中，对应关系是按照sprite name来对比的。</p><h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><pre><code>using System.Collections.Generic;using UnityEditor;using UnityEngine;namespace Editor.CopyAtlasDataTool{    public class CopyAtlasDataTool : EditorWindow    {        private static CopyAtlasDataTool window = null;        [MenuItem(&quot;Tools/CopyAtlasDataTool&quot;)]        public static CopyAtlasDataTool ShowGameDataEditorWindow()        {            if (window == null)                window = EditorWindow.GetWindow(typeof(CopyAtlasDataTool)) as CopyAtlasDataTool;            window.titleContent = new GUIContent(&quot;CopyAtlasDataTool&quot;);            window.Show();            return window;        }        private UnityEngine.Object _originObject;        private UnityEngine.Object _cloneObject;        private void OnGUI()        {            _originObject = EditorGUILayout.ObjectField(&quot;数据源图集&quot;, _originObject,typeof(Texture));            _cloneObject = EditorGUILayout.ObjectField(&quot;克隆图集&quot;, _cloneObject, typeof(Texture));            if (GUILayout.Button(&quot;Copy&quot;))            {                if (_originObject != null &amp;&amp; _cloneObject != null)                {                    CopyData(_originObject, _cloneObject);                }            }        }        public void CopyData(Object origin, Object clone)        {            string originAssetPath = AssetDatabase.GetAssetPath(origin);            string cloneAssetPath = AssetDatabase.GetAssetPath(clone);            TextureImporter originTi = AssetImporter.GetAtPath(originAssetPath) as TextureImporter;            TextureImporter cloneTi = AssetImporter.GetAtPath(cloneAssetPath) as TextureImporter;            if (originTi != null &amp;&amp; cloneTi != null)            {                //打开读写，才能写入数据                cloneTi.isReadable = true;                List &lt; SpriteMetaData &gt; newData = new List &lt; SpriteMetaData &gt; ();                List&lt;string&gt; hasAddData = new List&lt;string&gt;();                for (int i = 0; i &lt; originTi.spritesheet.Length; i++)                {                    for (int j = 0; j &lt; cloneTi.spritesheet.Length; j++)                    {                        SpriteMetaData oSm = originTi.spritesheet[i];                        SpriteMetaData cSm = cloneTi.spritesheet[j];                        //根绝sprite name进行匹配的                        if (oSm.name == cSm.name)                        {                            cSm.border = oSm.border;                            cSm.pivot = oSm.pivot;                            cSm.alignment = oSm.alignment;                            newData.Add(cSm);                            hasAddData.Add(cSm.name);                        }                    }                }                for (int j = 0; j &lt; cloneTi.spritesheet.Length; j++)                {                    SpriteMetaData cSm = cloneTi.spritesheet[j];                    if (!hasAddData.Contains(cSm.name))                    {                        newData.Add(cSm);                    }                }                cloneTi.spritesheet = newData.ToArray();                AssetDatabase.ImportAsset(cloneAssetPath, ImportAssetOptions.ForceUpdate);                cloneTi = AssetImporter.GetAtPath(cloneAssetPath) as TextureImporter;                if(cloneTi != null)                    cloneTi.isReadable = false;                AssetDatabase.ImportAsset(cloneAssetPath, ImportAssetOptions.ForceUpdate);            }        }    }}</code></pre><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>（1）克隆图集的TextureImporter的isReadable要在复制前打开，不然不能写入数据<br>（2）SpriteMetaData是结构体，要注意结构体和类的区别<br>（3）copy完后，注意检查两个图集的读写是否正确关闭了</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之二十四：基于Unity Node Editor、ScriptableObject的配置化新手引导系统</title>
      <link href="/2019/02/01/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-si-ji-yu-unity-node-editor-scriptableobject-de-pei-zhi-hua-xin-shou-yin-dao-xi-tong/"/>
      <url>/2019/02/01/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-si-ji-yu-unity-node-editor-scriptableobject-de-pei-zhi-hua-xin-shou-yin-dao-xi-tong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>本文主要介绍根据一款Node Editor库开发的新手引导系统<br>git地址如下：<br><a href="https://github.com/luis-l/UnityNodeEditorBase" target="_blank" rel="noopener"> https://github.com/luis-l/UnityNodeEditorBase</a></p><p>一、旧版新手引导做法</p><p>GuideCheckManager负责check各种类型的引导，判断是否达到触发条件，如果达到条件，当前无引导，则直接进行引导，否则存入缓存队列中。</p><p>GuideCheckManager注册跟引导有关的消息通知，等收到通知，做一些check工作。</p><p>一个大步引导包含多个单线的单步引导，每个单步引导又可有check条件，如果中间某一单步引导未check通过，则打断引导。</p><p>缺点：</p><p>（1）配置采用CSV，可读性极差</p><p>使用CSV作为配置，为了将触发条件也配置化，就必须做一些数据解析的工作，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190201142407883.png" alt="在这里插入图片描述"></p><p>然后在程序中定义各种类型trigger的数据解析函数。从CSV中无法很直观的知道这一单步引导具体是引导什么。</p><p>填充数据也较为繁琐。</p><p>二、基于结点编辑的配置化新手引导系统</p><p>（1）基于ScriptableObject、结点编辑的配置</p><p>工具截图如下：<br><img src="https://img-blog.csdnimg.cn/20190201142445605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>GuideNodeGraph：一个结点树称为一个大步引导</p><p>GuideNode：一个结点称为一个单步引导</p><p>一个GuideNodeGraph就是一个ScriptableObject文件</p><p>一个GuideNodeGraph包含多个Node，连接NextStepGuide-&gt; LastStepGuide，形成结点树。</p><p>每个GuideNode，包含一个Input（LastStepGuide，目前无实际作用，只是为了连接结点树，OutPut必与Input连接)，三个Output（NextStepGuide、Trigger、Condition）</p><p>NextStepGuide：用来存储下一个单步引导结点，如果无下一单步引导结点，则当前引导结点完成时，引导结束。</p><p>Trigger：该单步引导结点触发条件，如果有多个Trigger，则只要有一个Trigger Success，则该引导则触发。</p><p>Condition：引导条件结点。单步引导结点可包含多个Condition引导条件，只有当多个Condition均成立时，才会引导。</p><p>Trigger和Condition均为Node 的子类。</p><p>库中ActionTriggerSystem类的setupNodeCreateMenu函数，实现了在NodeEditor中的右键菜单，自行修改可以实现排序，某一类node在前，某一类在后</p><p><img src="https://img-blog.csdnimg.cn/20190201143046251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>根据Guide View界面类型的不同，可以定义多种Guide Node保存数据，一般有对话模式的，以及点击UI模式的，本文主要讲如何使用Node<br>Editor、ScriptableObject进行配置化，如果项目中不是使用ScriptableObject进行配置存储的话，该方案就不适用了。</p><p>可以NodeEditor的优点：<br>配置引导可读性高，并且不存在配置数据解析逻辑，更改引导内顺序也很方便快捷。</p><p>最后感谢作者提供的Node Editor库<br>git地址如下：<br><a href="https://github.com/luis-l/UnityNodeEditorBase" target="_blank" rel="noopener"> https://github.com/luis-l/UnityNodeEditorBase</a></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader编程之一：多颜色条纹背景</title>
      <link href="/2018/12/22/unity-shader-bian-cheng-zhi-yi-duo-yan-se-tiao-wen-bei-jing/"/>
      <url>/2018/12/22/unity-shader-bian-cheng-zhi-yi-duo-yan-se-tiao-wen-bei-jing/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="两种颜色的条纹状背景"><a href="#两种颜色的条纹状背景" class="headerlink" title="两种颜色的条纹状背景"></a>两种颜色的条纹状背景</h1><pre><code>Shader &quot;Custom/Flag&quot;{    Properties    {        [PerRendererData]_MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}        _1stColor(&quot;1stColo&quot;,Color) = (0,0,0,1)        _2ndColor(&quot;2ndColor&quot;,Color) = (1,1,1,1)        _tileNum(&quot;tile num&quot;, Range (2, 20)) = 10    }    SubShader    {        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }        LOD 100        Pass        {            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            // make fog work            #pragma multi_compile_fog            #include &quot;UnityCG.cginc&quot;            struct appdata            {                float4 vertex : POSITION;                float2 uv : TEXCOORD0;            };            struct v2f            {                float2 uv : TEXCOORD0;                float4 vertex : SV_POSITION;            };            sampler2D _MainTex;            fixed4 _1stColor;            fixed4 _2ndColor;            int _tileNum;            v2f vert (appdata v)            {                v2f o;                o.vertex = UnityObjectToClipPos(v.vertex);                o.uv = v.uv;                return o;            }            fixed4 frag (v2f i) : SV_Target            {                //i.uv * _tileNum 将uv放大                //frac函数，取其小数部分                float2 newuv = frac(i.uv*_tileNum);                //step函数小于0.5返回0，否则返回1，再lerp一下，也就是uv.x小于0.5，返回_1stColor，否则返回_2ndColor                fixed4 color = lerp(_1stColor,_2ndColor,step(0.5,newuv.x));                return color;            }            ENDCG        }    }}</code></pre><p>效果图：</p><p><img src="https://img-blog.csdnimg.cn/20181222145228919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> UnityShader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UnityShader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之二十三：基于ObjectField的FileField</title>
      <link href="/2018/12/22/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-san-ji-yu-objectfield-de-filefield/"/>
      <url>/2018/12/22/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-san-ji-yu-objectfield-de-filefield/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>最近在做资源管理模块时，关于资源引用这方面的问题，并不想直接引用某一个asset<br>，比如Prefab、或者sprite、material等资源，当然可以由资源管理模块统一管理，然后对业务层提供获取的接口。由业务层传入文件名、或者AssetBundle<br>Name、path之类的数据，资源管理模块内加载出来然后返回。结合ObjectFiled这个编辑器类来介绍，我们拖入某一个asset，然后序列化存储其guid和asset<br>path，表面上看起来是引用了该asset，实际上只是存住了guid和path（用于load，结合资源管理模块而定），guid用于绝对指向asset资源，就算路径更改，也不怕引用丢失。</p><p><img src="https://img-blog.csdnimg.cn/20181222133749902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20181222133618421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="ObjectField介绍"><a href="#ObjectField介绍" class="headerlink" title="ObjectField介绍"></a>ObjectField介绍</h1><p><a href="https://docs.unity3d.com/2017.2/Documentation/ScriptReference/EditorGUI.ObjectField.html" target="_blank" rel="noopener">https://docs.unity3d.com/2017.2/Documentation/ScriptReference/EditorGUI.ObjectField.html</a></p><h1 id="FileField实现"><a href="#FileField实现" class="headerlink" title="FileField实现"></a>FileField实现</h1><pre><code>private string[] FileField(Rect position, string label, string guid,Type type)    {        string[] guidPath = new string[2];//存储guid和path，这里的path是assetPath，实际存储起来需要做一步处理，处理成资源管理模块能load的path或者别的数据        string path = AssetDatabase.GUIDToAssetPath(guid);        UnityEngine.Object file = AssetDatabase.LoadAssetAtPath(path,type);        EditorGUI.BeginChangeCheck();        {            //编辑器上显示的是ObjectField绘制出来的                                                                                              file = EditorGUI.ObjectField(position, label, file, type, false);        }        if (EditorGUI.EndChangeCheck())        {            path = AssetDatabase.GetAssetPath(file);            guid = AssetDatabase.AssetPathToGUID(path);        }        guidPath[0] = guid;        guidPath[1] = path;        return guidPath;    }</code></pre><p>不算完整的代码：</p><pre><code>using UnityEditor;using UnityEngine;using System;using System.IO;using IdleGames.Core.AssetManagement;[CustomPropertyDrawer(typeof(WeakReferenceAttribute), true)]public class WeakReferenceBaseDrawer : PropertyDrawer{    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)    {        WeakReferenceAttribute attribute = (WeakReferenceAttribute)base.attribute;        Type referenceType = typeof(GameObject);        if (attribute != null)        {            referenceType = attribute.AssetType;        }        SerializedProperty guidProperty = property.FindPropertyRelative(&quot;_guid&quot;);        SerializedProperty pathProperty = property.FindPropertyRelative(&quot;_path&quot;);        Rect guidRect = position;        string[] guidPath = FileField(guidRect, property.displayName, guidProperty.stringValue,referenceType);        guidProperty.stringValue = guidPath[0];        //这里演示的是把path存成了Resources文件夹下的path        if (string.IsNullOrEmpty(guidPath[1]) == false &amp;&amp; guidPath[1].Contains(&quot;Resources/&quot;))        {            int index = guidPath[1].LastIndexOf(&quot;Resources/&quot;) + &quot;Resources/&quot;.Length;            string path = guidPath[1].Substring(index);            path = path.Remove(path.LastIndexOf(&quot;.&quot;));            pathProperty.stringValue = path;        }        property.serializedObject.ApplyModifiedProperties();    }    private string[] FileField(Rect position, string label, string guid,Type type)    {        string[] guidPath = new string[2];        string path = AssetDatabase.GUIDToAssetPath(guid);        UnityEngine.Object file = AssetDatabase.LoadAssetAtPath(path,type);        EditorGUI.BeginChangeCheck();        {                                                                                              file = EditorGUI.ObjectField(position, label, file, type, false);        }        if (EditorGUI.EndChangeCheck())        {            path = AssetDatabase.GetAssetPath(file);            guid = AssetDatabase.AssetPathToGUID(path);        }        guidPath[0] = guid;        guidPath[1] = path;        return guidPath;    }}</code></pre><p>上述代码仅供参考，拖入的object与实际序列化存储的不是同一个东西时，可以用上述类似的思路</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之二十二：基于TexturePacker的一键打图集工具</title>
      <link href="/2018/09/09/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-er-ji-yu-texturepacker-de-yi-jian-da-tu-ji-gong-ju/"/>
      <url>/2018/09/09/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-er-ji-yu-texturepacker-de-yi-jian-da-tu-ji-gong-ju/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Unity编辑器拓展之二十二：基于TexturePacker的一键打图集工具"><a href="#Unity编辑器拓展之二十二：基于TexturePacker的一键打图集工具" class="headerlink" title="Unity编辑器拓展之二十二：基于TexturePacker的一键打图集工具"></a>Unity编辑器拓展之二十二：基于TexturePacker的一键打图集工具</h1><p>NGUI使用TexturePacker打图集是一件频繁且费时的工作，只要美术稍一更新图片，就需要重新打图集，而且每次打图集的操作其实都是一样的重复劳动，基于此，开发工具批量打图集时很有必要的。</p><p>使用TexturePacker打图集，会输出两个文件，一个PNG合图，一个txt图集信息文件，而到Unity中使用UIAtlas，则需要一个Material材质文件和一个Prefab预制体文件，这两个文件也由工具生成。</p><p>鉴于项目不是从一开始就用该工具进行打图集工作的，因此这些文件的命名不具有统一的规范，因此使用一个配置文件来记录每个图集的输出文件信息。</p><p><img src="https://img-blog.csdn.net/20180909133119352?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h3 id="Atlas-ini图集配置文件"><a href="#Atlas-ini图集配置文件" class="headerlink" title="Atlas.ini图集配置文件"></a>Atlas.ini图集配置文件</h3><p>该文件以CSV格式进行配置，共有5列，图片文件夹相对路径、PNG合图输出路径、txt图集信息文件输出路径、UIAtlasPrefab输出路径、Material材质输出路径，后面四个输出路径都是基于Unity工程的Assets目录。</p><h3 id="命令行打图集"><a href="#命令行打图集" class="headerlink" title="命令行打图集"></a>命令行打图集</h3><p>TexturePacker支持使用命令行打图集</p><pre><code>$TexturePacker_PATH $imgDir --max-size 4096 --allow-free-size --format unity --size-constraints POT --shape-padding 2 --border-padding 2 --common-divisor-x 1 --common-divisor-y 1 --disable-rotation --algorithm MaxRects --opt RGBA8888 --scale 1 --scale-mode Smooth --smart-update --sheet $ASSETS_PATH$atlasPng --data $ASSETS_PATH$atlasData</code></pre><p>详细命令行介绍请自行搜索相关文档</p><h3 id="一键批量设置图片资源设置"><a href="#一键批量设置图片资源设置" class="headerlink" title="一键批量设置图片资源设置"></a>一键批量设置图片资源设置</h3><p>PNG合图文件输出到Unity后，通过使用Unity提供的TextureImporter类和TextImporterPlatformSetting类进行图片设置</p><h3 id="生成材质和Prefab问阿金并自动关联引用"><a href="#生成材质和Prefab问阿金并自动关联引用" class="headerlink" title="生成材质和Prefab问阿金并自动关联引用"></a>生成材质和Prefab问阿金并自动关联引用</h3><p>材质使用的Shader是“Unlit/Transparent<br>Colored”，mainTexture则为TexturePacker输出的合图，创建Prefab，并Add UIAtlas<br>Component，给UIAtlas组件导入texture和txt图集信息文件</p><pre><code>NGUIEditorTools.ImportTexture(uiAtlas.texture, false, false, !uiAtlas.premultipliedAlpha);NGUIJson.LoadSpriteData(uiAtlas, atlasTextAsset);</code></pre><h3 id="UIAtlas信息拷贝"><a href="#UIAtlas信息拷贝" class="headerlink" title="UIAtlas信息拷贝"></a>UIAtlas信息拷贝</h3><p>创建图集后，有时需要拷贝另一个图集的border和padding信息，例如两个图集内容其实是一直的，只是皮肤颜色不一样（换肤图集），因此这两个图集的border和padding数据是一样的，提供工具进行数据拷贝。</p><p><img src="https://img-blog.csdn.net/20180909131827960?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h3 id="清理Editor进度条"><a href="#清理Editor进度条" class="headerlink" title="清理Editor进度条"></a>清理Editor进度条</h3><p>为避免Atlas.ini配置错误，导致打图集中断，而EditorUtility.DisplayProgressBar进度条无法清除，提供Editor进度条清理功能，菜单栏Tools-&gt;清理进度条</p><h3 id="工程下载"><a href="#工程下载" class="headerlink" title="工程下载"></a>工程下载</h3><p>GitHub地址： <a href="https://github.com/JingFengJi/CreateAtlas" target="_blank" rel="noopener"> https://github.com/JingFengJi/CreateAtlas</a></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之二十一：拓展Unity模块，打造私人工具库（二）</title>
      <link href="/2018/08/22/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-yi-tuo-zhan-unity-mo-kuai-da-zao-si-ren-gong-ju-ku-er/"/>
      <url>/2018/08/22/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-yi-tuo-zhan-unity-mo-kuai-da-zao-si-ren-gong-ju-ku-er/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="拓展Unity模块，打造私人工具库（二）"><a href="#拓展Unity模块，打造私人工具库（二）" class="headerlink" title="拓展Unity模块，打造私人工具库（二）"></a>拓展Unity模块，打造私人工具库（二）</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>上一篇，实现了基本Unity模块拓展的功能，本篇将介绍如何通过反射来实现导入UnityPackage</p><h2 id="Gif示意图"><a href="#Gif示意图" class="headerlink" title="Gif示意图"></a>Gif示意图</h2><p>![这里写图片描述](<a href="https://img-" target="_blank" rel="noopener">https://img-</a><br>blog.csdn.net/20180822230440180?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</p><h2 id="程序导入UnityPackage"><a href="#程序导入UnityPackage" class="headerlink" title="程序导入UnityPackage"></a>程序导入UnityPackage</h2><p>通过查阅UnityEditor源代码发现，UnityEditor命名空间下有个EditorWindow的子类PackageImport，该类有个静态函数ShowImportPackage如下：</p><pre><code>public static void ShowImportPackage(string packagePath, ImportPackageItem[] items, string packageIconPath, bool allowReInstall){    if (PackageImport.ValidateInput(items))    {        PackageImport window = EditorWindow.GetWindow&lt;PackageImport&gt;(true, &quot;Import Unity Package&quot;);        window.Init(packagePath, items, packageIconPath, allowReInstall);    }}</code></pre><p>该函数除了需要传入package 的路径外，还需要传入<br>ImportPackageItem[]（也就是该package的内容），通过在UnityEditor中搜索ShowImportPackage函数调用，发现在AssetDataBase类中有一个静态函数ImportPackage用来导入Package的，该函数中先调用PackageUtility.ExtractAndPrepareAssetList函数获取到package里内容的列表，然后在调用的导入，当然此处还用到了interactive变量来控制是否打开Import<br>Window。而PackageUtility.ExtractAndPrepareAssetList详细代码则是看不到了。</p><pre><code>public static void ImportPackage(string packagePath, bool interactive){    if (string.IsNullOrEmpty(packagePath))    {        throw new ArgumentException(&quot;Path can not be empty or null&quot;, &quot;packagePath&quot;);    }    string packageIconPath;    bool allowReInstall;    ImportPackageItem[] array = PackageUtility.ExtractAndPrepareAssetList(packagePath, out packageIconPath, out allowReInstall);    if (array != null)    {        if (interactive)        {            PackageImport.ShowImportPackage(packagePath, array, packageIconPath, allowReInstall);        }        else        {            string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(packagePath);            PackageUtility.ImportPackageAssets(fileNameWithoutExtension, array, false);        }    }}</code></pre><p>通过尝试，一次导入多个UnityPackage时，后一个会将前一个覆盖掉（估计是导入资源Unity需要加载并且编译吧），所以目前工具只能单个导入。</p><p>封装一个Package2Folder类，用来导入UnityPackage，只需调用ImportPackageToFolder函数即可。</p><p><img src="https://img-blog.csdn.net/20180822232606973?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><pre><code>public class Package2Folder    {        #region reflection stuff        private delegate AssetsItem[] ImportPackageStep1Delegate(string packagePath, out string packageIconPath);        private static Type assetServerType;        private static Type AssetServerType        {            get            {                if (assetServerType == null)                {                    assetServerType = typeof(MenuItem).Assembly.GetType(&quot;UnityEditor.AssetServer&quot;);                }                return assetServerType;            }        }        private static ImportPackageStep1Delegate importPackageStep1;        private static ImportPackageStep1Delegate ImportPackageStep1        {            get            {                if (importPackageStep1 == null)                {                    importPackageStep1 = (ImportPackageStep1Delegate)Delegate.CreateDelegate(                        typeof(ImportPackageStep1Delegate),                        null,                        AssetServerType.GetMethod(&quot;ImportPackageStep1&quot;));                }                return importPackageStep1;            }        }        private static MethodInfo importPackageStep2MethodInfo;        private static MethodInfo ImportPackageStep2MethodInfo        {            get            {                if (importPackageStep2MethodInfo == null)                {                    importPackageStep2MethodInfo = AssetServerType.GetMethod(&quot;ImportPackageStep2&quot;);                }                return importPackageStep2MethodInfo;            }        }        private delegate object[] ExtractAndPrepareAssetListDelegate(string packagePath, out string packageIconPath,            out bool allowReInstall);        private static Type packageUtilityType;        private static Type PackageUtilityType        {            get            {                if (packageUtilityType == null)                {                    packageUtilityType                        = typeof(MenuItem).Assembly.GetType(&quot;UnityEditor.PackageUtility&quot;);                }                return packageUtilityType;            }        }        private static ExtractAndPrepareAssetListDelegate extractAndPrepareAssetList;        private static ExtractAndPrepareAssetListDelegate ExtractAndPrepareAssetList        {            get            {                if (extractAndPrepareAssetList == null)                {                    extractAndPrepareAssetList                        = (ExtractAndPrepareAssetListDelegate)Delegate.CreateDelegate(                            typeof(ExtractAndPrepareAssetListDelegate),                            null,                            PackageUtilityType.GetMethod(&quot;ExtractAndPrepareAssetList&quot;));                }                return extractAndPrepareAssetList;            }        }        private static FieldInfo destinationAssetPathFieldInfo;        private static FieldInfo DestinationAssetPathFieldInfo        {            get            {                if (destinationAssetPathFieldInfo == null)                {                    Type importPackageItem                        = typeof(MenuItem).Assembly.GetType(&quot;UnityEditor.ImportPackageItem&quot;);                    destinationAssetPathFieldInfo                        = importPackageItem.GetField(&quot;destinationAssetPath&quot;);                }                return destinationAssetPathFieldInfo;            }        }        private static MethodInfo importPackageAssetsMethodInfo;        private static MethodInfo ImportPackageAssetsMethodInfo        {            get            {                if (importPackageAssetsMethodInfo == null)                {                    // ImportPackageAssetsImmediately 是同步的导入5.4以上版本可用                    importPackageAssetsMethodInfo                        = PackageUtilityType.GetMethod(&quot;ImportPackageAssetsImmediately&quot;) ??                          PackageUtilityType.GetMethod(&quot;ImportPackageAssets&quot;);                }                return importPackageAssetsMethodInfo;            }        }        private static MethodInfo showImportPackageMethodInfo;        private static MethodInfo ShowImportPackageMethodInfo        {            get            {                if (showImportPackageMethodInfo == null)                {                    Type packageImport = typeof(MenuItem).Assembly.GetType(&quot;UnityEditor.PackageImport&quot;);                    showImportPackageMethodInfo = packageImport.GetMethod(&quot;ShowImportPackage&quot;);                }                return showImportPackageMethodInfo;            }        }        #endregion reflection stuff        public static void ImportPackageToFolder(string packagePath, string selectedFolderPath, bool interactive)        {            string packageIconPath;            bool allowReInstall;            if (AssetServerType != null &amp;&amp; AssetServerType.GetMethod(&quot;ImportPackageStep1&quot;) != null)                IsOlder53VersionAPI = true;            else                IsOlder53VersionAPI = false;            //IsOlder53VersionAPI = false;            object[] assetsItems = ExtractAssetsFromPackage(packagePath, out packageIconPath, out allowReInstall);            if (assetsItems == null) return;            foreach (object item in assetsItems)            {                ChangeAssetItemPath(item, selectedFolderPath);            }            if (interactive)            {                ShowImportPackageWindow(packagePath, assetsItems, packageIconPath, allowReInstall);            }            else            {                ImportPackageSilently(assetsItems);            }        }        private static bool IsOlder53VersionAPI = false;        public static object[] ExtractAssetsFromPackage(string path, out string packageIconPath,            out bool allowReInstall)        {            if (IsOlder53VersionAPI)            {                AssetsItem[] array = ImportPackageStep1(path, out packageIconPath);                allowReInstall = false;                return array;            }            else            {                object[] array = ExtractAndPrepareAssetList(path, out packageIconPath, out allowReInstall);                return array;            }        }        private static void ChangeAssetItemPath(object assetItem, string selectedFolderPath)        {            if (IsOlder53VersionAPI)            {                AssetsItem item = (AssetsItem)assetItem;                item.exportedAssetPath = selectedFolderPath + item.exportedAssetPath.Remove(0, 6);                item.pathName = selectedFolderPath + item.pathName.Remove(0, 6);            }            else            {                string destinationPath                    = (string)DestinationAssetPathFieldInfo.GetValue(assetItem);                destinationPath                    = selectedFolderPath + destinationPath.Remove(0, 6);                DestinationAssetPathFieldInfo.SetValue(assetItem, destinationPath);            }        }        public static void ShowImportPackageWindow(string path, object[] array, string packageIconPath,            bool allowReInstall)        {            if (IsOlder53VersionAPI)            {                ShowImportPackageMethodInfo.Invoke(null, new object[] { path, array, packageIconPath });            }            else            {                ShowImportPackageMethodInfo.Invoke(null, new object[] { path, array, packageIconPath, allowReInstall });            }        }        public static void ImportPackageSilently(object[] assetsItems)        {            if (IsOlder53VersionAPI)            {                ImportPackageStep2MethodInfo.Invoke(null, new object[] { assetsItems, false });            }            else            {                ImportPackageAssetsMethodInfo.Invoke(null, new object[] { assetsItems, false });            }        }        private static string GetSelectedFolderPath()        {            UnityEngine.Object obj = Selection.activeObject;            if (obj == null) return null;            string path = AssetDatabase.GetAssetPath(obj.GetInstanceID());            return !Directory.Exists(path) ? null : path;        }    }</code></pre><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>【UnityEditor 编辑器间快速复制粘贴】： <a href="https://539go.com/2018/02/04/Unity-QuickCopy/" target="_blank" rel="noopener"> https://539go.com/2018/02/04/Unity-QuickCopy/</a><br>引用了该文章中的UnityPackage导入代码。</p><h2 id="工具下载"><a href="#工具下载" class="headerlink" title="工具下载"></a>工具下载</h2><p>git仓库：</p><p><a href="https://github.com/JingFengJi/UnityCenterTool" target="_blank" rel="noopener"> https://github.com/JingFengJi/UnityCenterTool</a></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之二十：拓展Unity模块，打造私人工具库（一）</title>
      <link href="/2018/08/20/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-tuo-zhan-unity-mo-kuai-da-zao-si-ren-gong-ju-ku-yi/"/>
      <url>/2018/08/20/unity-bian-ji-qi-tuo-zhan-zhi-er-shi-tuo-zhan-unity-mo-kuai-da-zao-si-ren-gong-ju-ku-yi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="拓展Unity模块，打造私人工具库（一）"><a href="#拓展Unity模块，打造私人工具库（一）" class="headerlink" title="拓展Unity模块，打造私人工具库（一）"></a>拓展Unity模块，打造私人工具库（一）</h1><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>经过平时的项目积累，使用以及自己编写的编辑器工具越来越多，有些工具在别的项目中同样用的上，但是不希望每次都重新拷贝新代码到项目中，于是就希望能够拓展Unity模块，实现自己的工具库，方便导入工具到项目中。</p><p>通过查阅资料发现，在Unity的安装目录 Unity2017.3.1f1\Editor\Data\UnityExtensions\Unity<br>(我的版本是2017.3.1f1)下，有一些Unity自带的模块，可以通过在该路径下放入自己的模块，就可以实现Unity新建的项目都拥有该拓展模块的功能。那么，接下来就写一个工具导入模块放入该文件夹中。</p><h2 id="UnityExtensions文件结构基本介绍"><a href="#UnityExtensions文件结构基本介绍" class="headerlink" title="UnityExtensions文件结构基本介绍"></a>UnityExtensions文件结构基本介绍</h2><p>1、ivy.xml文件</p><p>其中：version、unityVersion均为当前Unity的版本号；artifact name 标签为我们的DLL文件的相对路径。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;ivy-module version=&quot;2.0&quot;&gt;  &lt;info version=&quot;2017.3.1&quot; organisation=&quot;Unity&quot; module=&quot;UnityToolCenter&quot; e:packageType=&quot;UnityExtension&quot; e:unityVersion=&quot;2017.3.1f1&quot; xmlns:e=&quot;http://ant.apache.org/ivy/extra&quot; /&gt;  &lt;publications xmlns:e=&quot;http://ant.apache.org/ivy/extra&quot;&gt;    &lt;artifact name=&quot;Editor/UnityToolCenter&quot; type=&quot;dll&quot; ext=&quot;dll&quot; e:guid=&quot;adebbd281f1a4ef3a30be7f21937e02f&quot; /&gt;  &lt;/publications&gt;&lt;/ivy-module&gt;</code></pre><p>2、Editor文件夹<br>放入dll 代码中属于编辑器拓展的代码</p><h2 id="逻辑说明"><a href="#逻辑说明" class="headerlink" title="逻辑说明"></a>逻辑说明</h2><p>工具初版示意图：</p><p><img src="https://img-blog.csdn.net/20180820223019383?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>通过勾选UnityPackage，直接导入到项目中，简单快捷。</p><p>为了不直接将UnityPackage文件放入到Unity安装目录下，因此新增一个config.ini文件，里面配置UnityPackage文件的路径（绝对路径），例如下图：<br><img src="https://img-blog.csdn.net/2018082022321790?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><img src="https://img-blog.csdn.net/2018082022325173?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>通过读取该配置文件，加载配置下所有路径的所有后缀名为unitypackage文件，然后显示在编辑器中。</p><h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><p>将脚本打成dll后，将UnityToolCenter.dll和UnityToolCenter.pdb文件放入安装目录下</p><p><img src="https://img-blog.csdn.net/2018082022350796?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>修改ivy.xml文件为</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;ivy-module version=&quot;2.0&quot;&gt;  &lt;info version=&quot;2017.3.1&quot; organisation=&quot;Unity&quot; module=&quot;UnityToolCenter&quot; e:packageType=&quot;UnityExtension&quot; e:unityVersion=&quot;2017.3.1f1&quot; xmlns:e=&quot;http://ant.apache.org/ivy/extra&quot; /&gt;  &lt;publications xmlns:e=&quot;http://ant.apache.org/ivy/extra&quot;&gt;    &lt;artifact name=&quot;Editor/UnityToolCenter&quot; type=&quot;dll&quot; ext=&quot;dll&quot; e:guid=&quot;adebbd281f1a4ef3a30be7f21937e02f&quot; /&gt;  &lt;/publications&gt;&lt;/ivy-module&gt;</code></pre><p>【注意】版本号，以及dll的路径</p><p>此时，新建另一个Unity工程（同版本），就会发现菜单栏也带有Tools/UnityToolCenter，具体导入UnityPackage逻辑见下期</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://539go.com/2017/10/20/UnityEditor-Unity%E7%9A%84%E6%A8%A1%E5%9D%97/" target="_blank" rel="noopener"> https://539go.com/2017/10/20/UnityEditor-Unity%E7%9A%84%E6%A8%A1%E5%9D%97/</a></p><h2 id="工具终版见下期"><a href="#工具终版见下期" class="headerlink" title="工具终版见下期"></a>工具终版见下期</h2><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之十九：NGUI  UISprite预览图Preview拓展</title>
      <link href="/2018/08/10/unity-bian-ji-qi-tuo-zhan-zhi-shi-jiu-ngui-uisprite-yu-lan-tu-preview-tuo-zhan/"/>
      <url>/2018/08/10/unity-bian-ji-qi-tuo-zhan-zhi-shi-jiu-ngui-uisprite-yu-lan-tu-preview-tuo-zhan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="NGUI-UISprite预览图Preview拓展"><a href="#NGUI-UISprite预览图Preview拓展" class="headerlink" title="NGUI UISprite预览图Preview拓展"></a>NGUI UISprite预览图Preview拓展</h1><h2 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h2><p>1、拓展UISprite的Preview视图，同时显示UIAtlas Texture和Sprite<br>2、支持在UIAtlas上直接点选Sprite<br>3、无需打开Atlas选择框和Sprite选择框两步操作</p><h2 id="Gif示意图"><a href="#Gif示意图" class="headerlink" title="Gif示意图"></a>Gif示意图</h2><p><img src="https://img-blog.csdn.net/20180810224120831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h2 id="逻辑介绍"><a href="#逻辑介绍" class="headerlink" title="逻辑介绍"></a>逻辑介绍</h2><p>1、找到UISpriteInspector脚本，其脚本的OnPreView函数逻辑，源码如下：</p><pre><code>public override void OnPreviewGUI (Rect rect, GUIStyle background){    UISprite sprite = target as UISprite;    if (sprite == null || !sprite.isValid) return;    Texture2D tex = sprite.mainTexture as Texture2D;    if (tex == null) return;    UISpriteData sd = sprite.atlas.GetSprite(sprite.spriteName);    NGUIEditorTools.DrawSprite(tex, rect, sd, sprite.color);}</code></pre><p>其中NGUIEditorTools.DrawSprite函数负责绘制Sprite，包括背景、border line、out line、size<br>label等，如下图所示：</p><p>2、PreView区域为左右两边，分别绘制Atlas Texture和Sprite，并且Atlas<br>Texture在绘制时依然采用sprite的绘制样式，底图背景 + 黑色轮廓，再次基础上使用的Sprite采用绿色轮廓</p><pre><code>public override void OnPreviewGUI (Rect rect, GUIStyle background){    UISprite sprite = target as UISprite;    if (sprite == null || !sprite.isValid) return;    Texture2D tex = sprite.mainTexture as Texture2D;    if (tex == null) return;    float interval = 10f;    float width = (rect.width - interval) / 2;    Rect leftRect = new Rect(rect.x,rect.y,width,rect.height);    Rect rightRect = new Rect(rect.x + width + interval,rect.y,width,rect.height);    UISpriteData sd = sprite.atlas.GetSprite(sprite.spriteName);    NGUIEditorTools.DrawAtlas(tex,leftRect,sd);     NGUIEditorTools.DrawSprite(tex, rightRect, sd, sprite.color);}    static public void DrawAtlas(Texture2D tex,Rect drawRect,UISpriteData sprite)    {        if (!tex) return;        // Create the texture rectangle that is centered inside rect.        Rect outerRect = drawRect;        outerRect.width = tex.width;        outerRect.height = tex.height;        if (tex.width &gt; 0)        {            float f = drawRect.width / outerRect.width;            outerRect.width *= f;            outerRect.height *= f;        }        if (drawRect.height &gt; outerRect.height)        {            outerRect.y += (drawRect.height - outerRect.height) * 0.5f;        }        else if (outerRect.height &gt; drawRect.height)        {            float f = drawRect.height / outerRect.height;            outerRect.width *= f;            outerRect.height *= f;        }        if (drawRect.width &gt; outerRect.width) outerRect.x += (drawRect.width - outerRect.width) * 0.5f;        // Draw the background        NGUIEditorTools.DrawTiledTexture(outerRect, NGUIEditorTools.backdropTexture);        Handles.color = Color.black;        Handles.DrawLine(new Vector3(outerRect.xMin, outerRect.yMin), new Vector3(outerRect.xMin, outerRect.yMax));        Handles.DrawLine(new Vector3(outerRect.xMax, outerRect.yMin), new Vector3(outerRect.xMax, outerRect.yMax));        Handles.DrawLine(new Vector3(outerRect.xMin, outerRect.yMin), new Vector3(outerRect.xMax, outerRect.yMin));        Handles.DrawLine(new Vector3(outerRect.xMin, outerRect.yMax), new Vector3(outerRect.xMax, outerRect.yMax));        if(sprite != null)        {            Handles.color = Color.green;            Rect spriteOutlineRect = outerRect;            float r = outerRect.width / tex.width;            spriteOutlineRect.x = outerRect.xMin + sprite.x * r;            spriteOutlineRect.y = outerRect.yMin + sprite.y * r;            spriteOutlineRect.width = sprite.width * r;            spriteOutlineRect.height = sprite.height * r;            Handles.DrawLine(new Vector3(spriteOutlineRect.xMin, spriteOutlineRect.yMin), new Vector3(spriteOutlineRect.xMin, spriteOutlineRect.yMax));            Handles.DrawLine(new Vector3(spriteOutlineRect.xMax, spriteOutlineRect.yMin), new Vector3(spriteOutlineRect.xMax, spriteOutlineRect.yMax));            Handles.DrawLine(new Vector3(spriteOutlineRect.xMin, spriteOutlineRect.yMin), new Vector3(spriteOutlineRect.xMax, spriteOutlineRect.yMin));            Handles.DrawLine(new Vector3(spriteOutlineRect.xMin, spriteOutlineRect.yMax), new Vector3(spriteOutlineRect.xMax, spriteOutlineRect.yMax));        }        Rect uv = new Rect(0, 0, tex.width, tex.height);        uv = NGUIMath.ConvertToTexCoords(uv, tex.width, tex.height);        GUI.DrawTextureWithTexCoords(outerRect, tex, uv, true);        // Sprite size label        string text = string.Format(&quot;Atlas Size: {0}x{1}&quot;, Mathf.RoundToInt(tex.width), Mathf.RoundToInt(tex.height));        EditorGUI.DropShadowLabel(GUILayoutUtility.GetRect(Screen.width, 18f), text);    }</code></pre><p>示意图如下：<br><img src="https://img-blog.csdn.net/20180810223913392?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>3、点选功能实现</p><pre><code>    public override void OnPreviewGUI (Rect rect, GUIStyle background)    {        UISprite sprite = target as UISprite;        if (sprite == null || !sprite.isValid) return;        Texture2D tex = sprite.mainTexture as Texture2D;        if (tex == null) return;        float interval = 10f;        float width = (rect.width - interval) / 2;        Rect leftRect = new Rect(rect.x,rect.y,width,rect.height);        Rect rightRect = new Rect(rect.x + width + interval,rect.y,width,rect.height);        UISpriteData sd = sprite.atlas.GetSprite(sprite.spriteName);        NGUIEditorTools.DrawAtlas(tex,leftRect,sd);        NGUIEditorTools.DrawSprite(tex, rightRect, sd, sprite.color);        //点选图片        Event e = Event.current;        if(e.type == EventType.MouseDown)        {            //下面函数通过点击的坐标，和texture、texture draw rect等信息计算出被点选的sprite            UISpriteData click = NGUIEditorTools.GetUISpriteData(tex,sprite.atlas,leftRect,e.mousePosition);            if(click != null)            {                sprite.spriteName = click.name;                EditorUtility.SetDirty(sprite);            }        }    }    //获取sprite在preview中的区域    static public Rect GetAreaInPreview(Texture2D tex,Rect drawRect,UISpriteData sprite)    {        // Create the texture rectangle that is centered inside rect.        Rect outerRect = drawRect;        outerRect.width = tex.width;        outerRect.height = tex.height;        if (tex.width &gt; 0)        {            float f = drawRect.width / outerRect.width;            outerRect.width *= f;            outerRect.height *= f;        }        if (drawRect.height &gt; outerRect.height)        {            outerRect.y += (drawRect.height - outerRect.height) * 0.5f;        }        else if (outerRect.height &gt; drawRect.height)        {            float f = drawRect.height / outerRect.height;            outerRect.width *= f;            outerRect.height *= f;        }        if (drawRect.width &gt; outerRect.width) outerRect.x += (drawRect.width - outerRect.width) * 0.5f;        Rect spriteOutlineRect = outerRect;        float r = outerRect.width / tex.width;        spriteOutlineRect.x = outerRect.xMin + sprite.x * r;        spriteOutlineRect.y = outerRect.yMin + sprite.y * r;        spriteOutlineRect.width = sprite.width * r;        spriteOutlineRect.height = sprite.height * r;        return spriteOutlineRect;    }    //根据点击的坐标，循环遍历出哪个Sprite的Area包含了该pos即可    static public UISpriteData GetUISpriteData(Texture2D tex, UIAtlas atlas,Rect drawRect,Vector2 pos)    {        List&lt;UISpriteData&gt; sprites = atlas.spriteList;        if(sprites == null || sprites.Count &lt;= 0) return null;        for (int i = 0; i &lt; sprites.Count; i++)        {            UISpriteData sprite = sprites[i];            Rect area = GetAreaInPreview(tex,drawRect,sprite);            if(area.Contains(pos))            {                return sprite;            }        }        return null;    }</code></pre><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用软件集锦</title>
      <link href="/2018/08/06/chang-yong-ruan-jian-ji-jin/"/>
      <url>/2018/08/06/chang-yong-ruan-jian-ji-jin/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="1、图片查重"><a href="#1、图片查重" class="headerlink" title="1、图片查重"></a>1、图片查重</h1><p>文件查重，如果只是文件名或者md5码的匹配查重，功能就不全面了，尤其是图片查重。图片查重应该更侧重于图片内容相似度查重。最近项目中使用TexturePacker<br>&amp; NGUI，发现存在一些图片重复，新人对业务逻辑不熟悉，导致图片乱放等问题，使得图片存在重复、浪费资源等。因此收集了Windows 和Mac<br>下使用的两款图片查重软件。</p><h4 id="Win"><a href="#Win" class="headerlink" title="Win"></a>Win</h4><p><a href="http://www.newrain.cn/app/info/1" target="_blank" rel="noopener"> http://www.newrain.cn/app/info/1 </a></p><p><img src="https://img-blog.csdn.net/20180806211702519?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>支持修改相似度进行匹配查重</p><h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h4><p>SnapSelect软件</p><p>官网： <a href="https://skylum.com/snapselect" target="_blank" rel="noopener"> https://skylum.com/snapselect </a><br>pojie版请自行下载</p><p><img src="https://img-blog.csdn.net/20180806212314576?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>支持四个级别的相似度查重 （Low、High、、、）</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之十八：NGUI批量替换图集工具 2.0版本</title>
      <link href="/2018/08/04/unity-bian-ji-qi-tuo-zhan-zhi-shi-ba-ngui-pi-liang-ti-huan-tu-ji-gong-ju-2.0-ban-ben/"/>
      <url>/2018/08/04/unity-bian-ji-qi-tuo-zhan-zhi-shi-ba-ngui-pi-liang-ti-huan-tu-ji-gong-ju-2.0-ban-ben/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Unity编辑器拓展之十五：NGUI批量替换图集工具-2-0版本"><a href="#Unity编辑器拓展之十五：NGUI批量替换图集工具-2-0版本" class="headerlink" title="Unity编辑器拓展之十五：NGUI批量替换图集工具 2.0版本"></a>Unity编辑器拓展之十五：NGUI批量替换图集工具 2.0版本</h1><h1 id="1-0版本"><a href="#1-0版本" class="headerlink" title="1.0版本"></a>1.0版本</h1><p><a href="https://blog.csdn.net/qq_26999509/article/details/81256493" target="_blank" rel="noopener"> https://blog.csdn.net/qq_26999509/article/details/81256493</a></p><h1 id="新增内容"><a href="#新增内容" class="headerlink" title="新增内容"></a>新增内容</h1><p>工具1.0版本，同事在使用过程中，发现批量替换图集时，不一定是全部都替换，这样的话，工具就没法使用了。<br>2.0版本新增功能：对于替换图集的Sprite支持可选择性的是否替换。</p><h1 id="工具截图"><a href="#工具截图" class="headerlink" title="工具截图"></a>工具截图</h1><p><img src="https://img-blog.csdn.net/20180804224118848?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>在之前的右下角空白区域，增加了预制体所有UISprite的列表显示，使用的TreeView编写的。</p><h1 id="TreeView介绍"><a href="#TreeView介绍" class="headerlink" title="TreeView介绍"></a>TreeView介绍</h1><p>目前，TreeView我还没有单独写文字来介绍该内容，后续会更新。<br>官方文档： <a href="https://docs.unity3d.com/Manual/TreeViewAPI.html" target="_blank" rel="noopener"> https://docs.unity3d.com/Manual/TreeViewAPI.html</a></p><h1 id="代码Git地址"><a href="#代码Git地址" class="headerlink" title="代码Git地址"></a>代码Git地址</h1><p><a href="https://github.com/JingFengJi/ReplaceAtlas" target="_blank" rel="noopener"> https://github.com/JingFengJi/ReplaceAtlas</a></p><p>欢迎加星</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p><hr><h1 id="2018-8-5日更新"><a href="#2018-8-5日更新" class="headerlink" title="2018.8.5日更新"></a>2018.8.5日更新</h1><h1 id="更新内容"><a href="#更新内容" class="headerlink" title="更新内容"></a>更新内容</h1><p>1、支持Sprite预览</p><h1 id="Gif示例图"><a href="#Gif示例图" class="headerlink" title="Gif示例图"></a>Gif示例图</h1><p><img src="https://img-blog.csdn.net/20180805211815279?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h1 id="重要代码介绍"><a href="#重要代码介绍" class="headerlink" title="重要代码介绍"></a>重要代码介绍</h1><p>Sprite的绘制，是通过查看UISpriteInspector类（NGUI）发现的，该类中在使用OnPreviewGUI接口绘制示意图的时候，调用了NGUIEdiotrTools.DrawSprite接口</p><pre><code>    public override void OnPreviewGUI (Rect rect, GUIStyle background)    {        UISprite sprite = target as UISprite;        if (sprite == null || !sprite.isValid) return;        Texture2D tex = sprite.mainTexture as Texture2D;        if (tex == null) return;        UISpriteData sd = sprite.atlas.GetSprite(sprite.spriteName);        NGUIEditorTools.DrawSprite(tex, rect, sd, sprite.color);    }</code></pre><p><img src="https://img-blog.csdn.net/20180805212237230?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>那里这次更新的内容，也使用该接口进行绘制。详情请看NGUI源码。</p><p>但是，该处PreviewGUI在底部绘制了 Sprite<br>Size的Label，而本工具不需要将图和尺寸信息绘制在一起，因此修改了源码，增加了一个bool类型的needSizeLabel参数，来控制是否显示尺寸信息</p><p>![这里写图片描述](<a href="https://img-" target="_blank" rel="noopener">https://img-</a><br>blog.csdn.net/20180805212621503?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</p><h1 id="代码Git地址-1"><a href="#代码Git地址-1" class="headerlink" title="代码Git地址"></a>代码Git地址</h1><p><a href="https://github.com/JingFengJi/ReplaceAtlas" target="_blank" rel="noopener"> https://github.com/JingFengJi/ReplaceAtlas</a></p><p>欢迎加星</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之十七：NGUI ComponentSelector增加搜索框</title>
      <link href="/2018/07/31/unity-bian-ji-qi-tuo-zhan-zhi-shi-qi-ngui-componentselector-zeng-jia-sou-suo-kuang/"/>
      <url>/2018/07/31/unity-bian-ji-qi-tuo-zhan-zhi-shi-qi-ngui-componentselector-zeng-jia-sou-suo-kuang/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="NGUI-ComponentSelector增加搜索框"><a href="#NGUI-ComponentSelector增加搜索框" class="headerlink" title="NGUI ComponentSelector增加搜索框"></a>NGUI ComponentSelector增加搜索框</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>最近在使用NGUI，给Sprite选择图集的时候，没有搜索框要挨个找挺麻烦，因此修改一下ComponentSelector组件，增加一个搜索框，便于搜索图集</p><p><img src="https://img-blog.csdn.net/20180731230908117?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h2 id="Gif动图展示"><a href="#Gif动图展示" class="headerlink" title="Gif动图展示"></a>Gif动图展示</h2><p><img src="https://img-blog.csdn.net/20180731232015407?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h2 id="SearchField介绍"><a href="#SearchField介绍" class="headerlink" title="SearchField介绍"></a>SearchField介绍</h2><p>关于SearchField介绍请看 <a href="https://blog.csdn.net/qq_26999509/article/details/80301320%20Unity%E7%BC%96%E8%BE%91%E5%99%A8%E6%8B%93%E5%B1%95%E4%B9%8B%E4%B9%9D%EF%BC%9ASearchField" target="_blank" rel="noopener"> Unity编辑器拓展之九</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下代码是修改的NGUI里的ComponentSelector脚本</p><pre><code>private SearchField search;private bool isInit = false;private string searchStr = &quot;&quot;;private void IfNeedInit(){    if(isInit == false)        search = new SearchField();    isInit = true;}void OnGUI (){    IfNeedInit();    searchStr = search.OnGUI(new Rect(10,10,200,10),searchStr);    searchStr = searchStr.ToLower();    //省略后面源码    }bool DrawObject (Object obj){    if (obj == null) return false;    //搜索    if(!string.IsNullOrEmpty(searchStr) &amp;&amp; !obj.name.ToLower().Contains(searchStr)) return false;    bool retVal = false;    Component comp = obj as Component;    GUILayout.BeginHorizontal();    {        string path = AssetDatabase.GetAssetPath(obj);        if (string.IsNullOrEmpty(path))        {            path = &quot;[Embedded]&quot;;            GUI.contentColor = new Color(0.7f, 0.7f, 0.7f);        }        else if (comp != null &amp;&amp; EditorUtility.IsPersistent(comp.gameObject))            GUI.contentColor = new Color(0.6f, 0.8f, 1f);        retVal |= GUILayout.Button(obj.name, &quot;AS TextArea&quot;, GUILayout.Width(160f), GUILayout.Height(20f));        retVal |= GUILayout.Button(path.Replace(&quot;Assets/&quot;, &quot;&quot;), &quot;AS TextArea&quot;, GUILayout.Height(20f));        GUI.contentColor = Color.white;        retVal |= GUILayout.Button(&quot;Select&quot;, &quot;ButtonLeft&quot;, GUILayout.Width(60f), GUILayout.Height(16f));    }    GUILayout.EndHorizontal();    return retVal;}</code></pre><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之十六：监听Scene Drag事件</title>
      <link href="/2018/07/30/unity-bian-ji-qi-tuo-zhan-zhi-shi-liu-jian-ting-scene-drag-shi-jian/"/>
      <url>/2018/07/30/unity-bian-ji-qi-tuo-zhan-zhi-shi-liu-jian-ting-scene-drag-shi-jian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="监听Scene-Drag事件"><a href="#监听Scene-Drag事件" class="headerlink" title="监听Scene Drag事件"></a>监听Scene Drag事件</h1><h2 id="Gif动图展示"><a href="#Gif动图展示" class="headerlink" title="Gif动图展示"></a>Gif动图展示</h2><p><img src="https://img-blog.csdn.net/20180730212155553?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>通过该监听，获取到被Drag进Scene的物体的类型，可以做一些预处理，例如：Drag一张图片，直接生成一个GameObject（带Image，前提是UGUI）的放在Canvas下</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;public class SceneManager{    [InitializeOnLoadMethod]    static void Init()    {        SceneView.onSceneGUIDelegate += OnSceneGUI;    }    private static void OnSceneGUI(SceneView sceneView)    {        Event e = Event.current;        if(e.type == EventType.DragUpdated || e.type == EventType.DragPerform)        {            DragAndDrop.visualMode = DragAndDropVisualMode.Copy;            if(e.type == EventType.DragPerform)            {                DragAndDrop.AcceptDrag();                for (int i = 0; i &lt; DragAndDrop.objectReferences.Length; i++)                {                    Object handleObj = DragAndDrop.objectReferences[i];                    if(handleObj != null)                    {                        Debug.LogError(handleObj.GetType());                    }                }            }        }    }}</code></pre><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之十五：NGUI批量替换图集工具</title>
      <link href="/2018/07/28/unity-bian-ji-qi-tuo-zhan-zhi-shi-wu-ngui-pi-liang-ti-huan-tu-ji-gong-ju/"/>
      <url>/2018/07/28/unity-bian-ji-qi-tuo-zhan-zhi-shi-wu-ngui-pi-liang-ti-huan-tu-ji-gong-ju/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="NGUI批量替换图集工具"><a href="#NGUI批量替换图集工具" class="headerlink" title="NGUI批量替换图集工具"></a>NGUI批量替换图集工具</h1><h2 id="工具目的"><a href="#工具目的" class="headerlink" title="工具目的"></a>工具目的</h2><p>因项目需要实现换肤的功能，也就是多套UI图集，提供工具批量换图集，方便查看Prebab各皮肤（图集）下的效果</p><h2 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h2><p>Gif 操作动图：<br><img src="https://img-blog.csdn.net/20180728004232812?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>工具截图：<br><img src="https://img-blog.csdn.net/20180728004352956?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>工具左侧是工程所有Prefab列表，右侧是替换图集的功能菜单，从指定原图集替换成目标图集</p><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><p>与上文：Unity编辑器之十四：字体替换工具 <a href="https://blog.csdn.net/qq_26999509/article/details/81106083" target="_blank" rel="noopener">https://blog.csdn.net/qq_26999509/article/details/81106083</a><br>一样，其实找到Prebfab下所有UISprite，并将其所有指定原图集 替换成<br>指定的目标图集，以此实现换肤的功能，当然两图集的SpriteName应该保持一致，不然没办法知道要换成目标图集里的那张图。</p><h2 id="重点代码"><a href="#重点代码" class="headerlink" title="重点代码"></a>重点代码</h2><pre><code>private void ReplacePrefabAtalas(GameObject prefab , UIAtlas atlas,UIAtlas targetAtlas){    if(prefab == null || atlas == null) return;    UISprite[] sprites = prefab.GetComponentsInChildren&lt;UISprite&gt;(true);    if(sprites != null &amp;&amp; sprites.Length &gt; 0)    {        int num = sprites.Length;        for (int i = 0; i &lt; num; i++)        {            UISprite s = sprites[i];            if(s != null &amp;&amp; s.atlas == atlas)            {                s.atlas = targetAtlas;                EditorUtility.SetDirty(s);            }        }    }    AssetDatabase.SaveAssets();}</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>1、Tools-&gt;ReplaceAtalas 打开工具</p><p><img src="https://img-blog.csdn.net/20180728005410396?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>2、选中待处理预制体，鼠标右键-&gt;替换图集</p><p><img src="https://img-blog.csdn.net/20180728005536617?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>3、<br><img src="https://img-blog.csdn.net/20180728005711218?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>4、 <img src="https://img-blog.csdn.net/20180728010026779?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h2 id="工具代码"><a href="#工具代码" class="headerlink" title="工具代码"></a>工具代码</h2><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;using System.IO;using UnityEditor.IMGUI.Controls;public class ReplaceAtalas : EditorWindow {    private static ReplaceAtalas window = null;    private static List&lt;string&gt; prefabPathList = new List&lt;string&gt; ();    private static string assetPath;    Rect SearchFieldRect    {        get        {            return new Rect(interval,interval,position.width * 0.3f,20f);        }    }    Rect prefabListRect     {        get { return new Rect (interval, interval + SearchFieldRect.yMax, SearchFieldRect.width, window.position.height - SearchFieldRect.yMax - 2 * interval); }    }    Rect replaceAtalsRect    {        get{return new Rect(prefabListRect.xMax + interval,interval,window.position.width - SearchFieldRect.width - 3 * interval,window.position.height - 2 * interval);}    }    private Vector2 scrollWidgetPos;    private float interval = 20f;    private string searchStr = &quot;&quot;;    private SearchField searchField;    private bool initialized = false;    [MenuItem(&quot;Assets/替换图集&quot;, false, 2001)]    public static void OpenWindow()    {        string selectedAssetPath = AssetDatabase.GetAssetPath (Selection.activeObject);        if(!string.IsNullOrEmpty(selectedAssetPath) &amp;&amp; selectedAssetPath.EndsWith(&quot;.prefab&quot;))        {            ReplaceAtalas window = ShowWindow();            if(window != null)            {                window.AutoSelctPrefab(selectedAssetPath);            }        }    }    [MenuItem(&quot;Tools/ReplaceAtalas&quot;)]    public static ReplaceAtalas ShowWindow()     {        prefabPathList.Clear ();        assetPath = Application.dataPath;        GetFiles (new DirectoryInfo (assetPath), &quot;*.prefab&quot;, ref prefabPathList);        if (window == null)            window = EditorWindow.GetWindow(typeof(ReplaceAtalas)) as ReplaceAtalas;        window.titleContent = new GUIContent(&quot;ReplaceAtalas&quot;);        window.Show();        return window;    }    public static void GetFiles (DirectoryInfo directory, string pattern, ref List&lt;string&gt; fileList)     {        if (directory != null &amp;&amp; directory.Exists &amp;&amp; !string.IsNullOrEmpty (pattern)) {            try {                foreach (FileInfo info in directory.GetFiles (pattern)) {                    string path = info.FullName.ToString ();                    fileList.Add (path.Substring (path.IndexOf (&quot;Assets&quot;)));                }            } catch (System.Exception)             {                throw;            }            foreach (DirectoryInfo info in directory.GetDirectories ())             {                GetFiles (info, pattern, ref fileList);            }        }    }    private void OnGUI()     {        InitIfNeeded();        DrawWindow();    }    private void DrawWindow()    {        DrawSearchField();        DrawPrefabList();        DrawReplaceAtalasTool();    }    private void InitIfNeeded()    {        if(!initialized)        {            if (null == searchField)                searchField = new SearchField ();        }        initialized = true;    }    private void DrawSearchField()    {        GUI.backgroundColor = Color.white;        searchStr = searchField.OnGUI (SearchFieldRect, searchStr);        searchStr = searchStr.ToLower();    }    private void DrawPrefabList()    {        GUI.backgroundColor = Color.white;        GUI.Box(prefabListRect,&quot;&quot;);        GUILayout.BeginArea(prefabListRect);        scrollWidgetPos = EditorGUILayout.BeginScrollView(scrollWidgetPos);        for (int i = 0; i &lt; prefabPathList.Count; i++)        {            if(CheckShowPrefab(prefabPathList[i],searchStr))            {                if(GUILayout.Button(prefabPathList[i]))                {                    curReplacePrefabPath = prefabPathList[i];                    curPrefabAtlas = GetPrefabAllAtlas(curReplacePrefabPath);                }            }        }        EditorGUILayout.EndScrollView();        GUILayout.EndArea();    }    private string curReplacePrefabPath = &quot;&quot;;    private bool CheckShowPrefab(string path,string searchstr)    {        if(string.IsNullOrEmpty(searchStr)) return true;        if(string.IsNullOrEmpty(path)) return false;        return GetFileNameWithSuffix(path.ToLower()).Contains(searchStr);    }    //包括后缀名    private string GetFileNameWithSuffix(string path)    {        if(string.IsNullOrEmpty(path)) return string.Empty;        return path.Substring(path.LastIndexOf(&quot;/&quot;)+1);    }    private UIAtlas curAtlas;    private UIAtlas targetAtlas;    void OnSelectAtlas (Object obj)    {        UIAtlas atlas = obj as UIAtlas;        if(isSelectCurAtlas)        {            curAtlas = obj as UIAtlas;        }        else if(isSelectTargetAtlas)        {            targetAtlas = obj as UIAtlas;        }        isSelectCurAtlas = false;        isSelectTargetAtlas = false;    }    private bool isSelectCurAtlas = false;    private bool isSelectTargetAtlas = false;    private List&lt;UIAtlas&gt; curPrefabAtlas = new List&lt;UIAtlas&gt;();    private void DrawReplaceAtalasTool()    {        GUI.backgroundColor = Color.white;        GUILayout.BeginArea(replaceAtalsRect);        EditorGUILayout.LabelField(curReplacePrefabPath);        GUILayout.BeginHorizontal();        EditorGUILayout.LabelField(&quot;该预制体含有的所有图集:&quot;,GUILayout.Width(150));        if(curPrefabAtlas.Count &gt; 0)        {            for (int i = 0; i &lt; curPrefabAtlas.Count; i++)            {                if(GUILayout.Button(curPrefabAtlas[i].name))                {                    curAtlas = curPrefabAtlas[i];                }                if(GUILayout.Button(&quot;Edit&quot;))                {                    //NGUISettings.atlas = mFont.atlas;                    //NGUISettings.selectedSprite = sym.spriteName;                    NGUIEditorTools.Select(curPrefabAtlas[i].gameObject);                }            }        }        GUILayout.EndHorizontal();        //原图集        GUILayout.BeginHorizontal();        curAtlas = (UIAtlas)EditorGUILayout.ObjectField(&quot;被替换图集&quot;, curAtlas, typeof(UIAtlas), true);        if (NGUIEditorTools.DrawPrefixButton(&quot;选择Atlas&quot;,GUILayout.Width(200)))        {            isSelectCurAtlas = true;            ComponentSelector.Show&lt;UIAtlas&gt;(OnSelectAtlas);        }        GUILayout.EndHorizontal();        //目标图集        GUILayout.BeginHorizontal();        targetAtlas = (UIAtlas)EditorGUILayout.ObjectField(&quot;目标图集&quot;, targetAtlas, typeof(UIAtlas), true);             if (NGUIEditorTools.DrawPrefixButton(&quot;选择Atlas&quot;,GUILayout.Width(200)))        {            isSelectTargetAtlas = true;            ComponentSelector.Show&lt;UIAtlas&gt;(OnSelectAtlas);        }        GUILayout.EndHorizontal();        if(GUILayout.Button(&quot;互换&quot;))        {            UIAtlas tmpCurAtlas = curAtlas;            curAtlas = targetAtlas;            targetAtlas = tmpCurAtlas;        }        //替换按钮        if(GUILayout.Button(&quot;替换图集&quot;))        {            if(string.IsNullOrEmpty(curReplacePrefabPath))            {                EditorUtility.DisplayDialog(&quot;提示&quot;, &quot;请先选择一个预制体!&quot;, &quot;确定&quot;);            }            else if (curAtlas == null)            {                EditorUtility.DisplayDialog(&quot;提示&quot;, &quot;请先指定被替换图集!&quot;, &quot;确定&quot;);            }            else            {                if(targetAtlas == null)                {                    if(EditorUtility.DisplayDialog(&quot;提示&quot;, &quot;原图集将被清空，确定替换吗？&quot;, &quot;确定&quot;,&quot;取消&quot;))                    {                        ReplacePrefabAtalas(curReplacePrefabPath);                    }                }                else                {                    ReplacePrefabAtalas(curReplacePrefabPath);                }            }        }        //保存按钮        //撤销按钮        GUILayout.EndArea();    }    private void ReplacePrefabAtalas(string path)    {        if(string.IsNullOrEmpty(path)) return;        GameObject gameObj = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(path);        ReplacePrefabAtalas(gameObj,curAtlas,targetAtlas);    }       private List&lt;UIAtlas&gt; GetPrefabAllAtlas(string path)    {        if(string.IsNullOrEmpty(path)) return null;        GameObject gameObj = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(path);        return GetPrefabAllAtlas(gameObj);    }    private List&lt;UIAtlas&gt; GetPrefabAllAtlas(GameObject prefab)    {        if(null == prefab) return null;        List&lt;UIAtlas&gt; atlass = new List&lt;UIAtlas&gt;();        UISprite[] sprites = prefab.GetComponentsInChildren&lt;UISprite&gt;(true);        if(sprites != null &amp;&amp; sprites.Length &gt; 0)        {            int num = sprites.Length;            for (int i = 0; i &lt; num; i++)            {                UISprite s = sprites[i];                if(s != null &amp;&amp; !atlass.Contains(s.atlas))                {                    atlass.Add(s.atlas);                }            }        }        return atlass;    }    private void ReplacePrefabAtalas(GameObject prefab , UIAtlas atlas,UIAtlas targetAtlas)    {        if(prefab == null || atlas == null) return;        UISprite[] sprites = prefab.GetComponentsInChildren&lt;UISprite&gt;(true);        if(sprites != null &amp;&amp; sprites.Length &gt; 0)        {            int num = sprites.Length;            for (int i = 0; i &lt; num; i++)            {                UISprite s = sprites[i];                if(s != null &amp;&amp; s.atlas == atlas)                {                    s.atlas = targetAtlas;                    EditorUtility.SetDirty(s);                }            }        }        AssetDatabase.SaveAssets();    }    public void AutoSelctPrefab(string prefabPath)    {        if(string.IsNullOrEmpty(prefabPath)) return;        curReplacePrefabPath = prefabPath;        curPrefabAtlas = GetPrefabAllAtlas(curReplacePrefabPath);        curAtlas = null;        targetAtlas = null;    }}</code></pre><h2 id="代码Git地址"><a href="#代码Git地址" class="headerlink" title="代码Git地址"></a>代码Git地址</h2><p><a href="https://github.com/JingFengJi/ReplaceAtlas" target="_blank" rel="noopener"> https://github.com/JingFengJi/ReplaceAtlas</a><br>欢迎加星</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之十四：字体替换工具</title>
      <link href="/2018/07/18/unity-bian-ji-qi-tuo-zhan-zhi-shi-si-zi-ti-ti-huan-gong-ju/"/>
      <url>/2018/07/18/unity-bian-ji-qi-tuo-zhan-zhi-shi-si-zi-ti-ti-huan-gong-ju/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="字体替换工具"><a href="#字体替换工具" class="headerlink" title="字体替换工具"></a>字体替换工具</h1><p><img src="https://img-blog.csdn.net/20180718215424988?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>选择NGUI还是UGUI，选择替换的字体以及字号比例，就可以替换工程目录下所有预制体的字体了</p><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;using System.IO;using UnityEngine.UI;public class ReplaceFont : EditorWindow  {    private static ReplaceFont window = null;    private static List&lt;string&gt; prefafbPathList = new List&lt;string&gt;();    private static Font targetFont;    private static Font curFont;    private static float fontSizeRatio = 1f;    private static bool isUGUI = true;    [MenuItem(&quot;Tools/替换字体&quot;)]    public static void CSVCode()    {        if (window == null)        window = EditorWindow.GetWindow(typeof(ReplaceFont)) as ReplaceFont;        GetFiles(new DirectoryInfo(Application.dataPath), &quot;*.prefab&quot;, ref prefafbPathList);        window.titleContent = new GUIContent(&quot;ReplaceFont&quot;);        window.Show();    }    public static void GetFiles(DirectoryInfo directory, string pattern, ref List&lt;string&gt; fileList)    {        if (directory != null &amp;&amp; directory.Exists &amp;&amp; !string.IsNullOrEmpty(pattern))         {            try             {                foreach (FileInfo info in directory.GetFiles(pattern))                 {                    string path = info.FullName.ToString();                    fileList.Add(path.Substring (path.IndexOf (&quot;Assets&quot;)));                }            }             catch (System.Exception)             {                throw;            }            foreach (DirectoryInfo info in directory.GetDirectories())             {                GetFiles(info, pattern, ref fileList);            }        }    }    void OnGUI()    {        EditorGUILayout.BeginHorizontal();        isUGUI = EditorGUILayout.Toggle(&quot;UGUI&quot;,isUGUI);        isUGUI = EditorGUILayout.Toggle(&quot;NGUI&quot;, !isUGUI);        EditorGUILayout.EndHorizontal();        curFont = (Font) EditorGUILayout.ObjectField(&quot;被替换字体&quot;, curFont, typeof(Font), true);        targetFont = (Font) EditorGUILayout.ObjectField(&quot;目标字体&quot;, targetFont, typeof(Font), true);        EditorGUILayout.BeginHorizontal();        EditorGUILayout.LabelField(&quot;字号比例：&quot;);        fontSizeRatio = EditorGUILayout.FloatField(fontSizeRatio);        EditorGUILayout.EndHorizontal();        if(GUILayout.Button(&quot;一键替换&quot;))        {            for (int i = 0; i&lt;prefafbPathList.Count; i++)            {                GameObject gameObj = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(prefafbPathList[i]);                Change(gameObj);            }        AssetDatabase.SaveAssets();        }    }    public static void Change(GameObject prefab)    {        if(null != prefab)        {            Component[] labels = null;            if(isUGUI)            {                labels = prefab.GetComponentsInChildren&lt;Text&gt;(true);            }            else            {                //labels = prefab.GetComponentsInChildren&lt;UILabel&gt;(true);            }            if(null != labels)            foreach (Object item in labels)            {                if(isUGUI)                {                    Text text = (Text)item;                    int newFontSize = (int)(text.fontSize * fontSizeRatio);                    if (text.font.name == curFont.name)                    {                        text.font = targetFont;                        text.fontSize = newFontSize;                    }                }                else                {                    // UILabel label = (UILabel)item;                    // int newFontSize = (int)(label.fontSize * fontSizeRatio);                    // if (label.trueTypeFont.name == curFont.name)                    // {                    //      label.trueTypeFont = targetFont;                    //      label.fontSize = newFontSize;                    // }                }                EditorUtility.SetDirty(item);            }        }    }}</code></pre><h1 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h1><p><a href="https://github.com/JingFengJi/ReplaceFont.git" target="_blank" rel="noopener"> https://github.com/JingFengJi/ReplaceFont.git</a></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之十三：CSV文件解析代码生成工具</title>
      <link href="/2018/07/17/unity-bian-ji-qi-tuo-zhan-zhi-shi-san-csv-wen-jian-jie-xi-dai-ma-sheng-cheng-gong-ju/"/>
      <url>/2018/07/17/unity-bian-ji-qi-tuo-zhan-zhi-shi-san-csv-wen-jian-jie-xi-dai-ma-sheng-cheng-gong-ju/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="CSV文件解析代码生成工具"><a href="#CSV文件解析代码生成工具" class="headerlink" title="CSV文件解析代码生成工具"></a>CSV文件解析代码生成工具</h1><h3 id="工具示意图"><a href="#工具示意图" class="headerlink" title="工具示意图"></a>工具示意图</h3><p><img src="https://img-blog.csdn.net/20180717221145417?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>左侧是工程下所有的CSV文件列表，并提供搜索框，右侧是解析部分，上边提供了保存代码文件和拷贝代码的菜单，中间是CSV文件预解析出来的字段、数据类型（可选）等，下面是代码预览区域。</p><h3 id="获取所有CSV文件的路径"><a href="#获取所有CSV文件的路径" class="headerlink" title="获取所有CSV文件的路径"></a>获取所有CSV文件的路径</h3><p>使用递归获取所有CSV文件的路径，并绘制在左侧</p><pre><code>    [MenuItem(&quot;Tools/CreateCSVParseCode&quot;)]    public static void CSVCode()    {        csvFilesPathList.Clear ();        assetPath = Application.dataPath;        //获取所有CSV文件的路径        GetFiles (new DirectoryInfo (assetPath), &quot;*.csv&quot;, ref csvFilesPathList);        if (window == null)            window = EditorWindow.GetWindow(typeof(CreateCSVParseCode)) as CreateCSVParseCode;        window.titleContent = new GUIContent(&quot;CreateCSVParseCode&quot;);        if(isLimitSize)        {            window.minSize = new Vector2(1420,674);            window.maxSize = new Vector2(1420,674);        }        window.Show();    }    public static void GetFiles (DirectoryInfo directory, string pattern, ref List&lt;string&gt; fileList)     {        if (directory != null &amp;&amp; directory.Exists &amp;&amp; !string.IsNullOrEmpty (pattern)) {            try {                foreach (FileInfo info in directory.GetFiles (pattern)) {                    string path = info.FullName.ToString ();                    fileList.Add (path.Substring (path.IndexOf (&quot;Assets&quot;)));                }            } catch (System.Exception)             {                throw;            }            foreach (DirectoryInfo info in directory.GetDirectories ())             {                GetFiles (info, pattern, ref fileList);            }        }    }</code></pre><h3 id="预解析CSV文件"><a href="#预解析CSV文件" class="headerlink" title="预解析CSV文件"></a>预解析CSV文件</h3><p>定义一个类存储预解析数据</p><pre><code>public class CsvData{    public string header;    public DataType dataType;    public bool isParse = true;}public enum DataType{    Int = 0,    String = 1,    Double = 2,    Bool = 3,    //后续更新下面三种类型数据的解析    //Vector3 = 4,    //Vector2 = 5,    //Color = 6,}</code></pre><p>详细代码参考后面代码工程git地址</p><h3 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h3><p>将解析代码格式化存储在一个类中，以string format的形式存在。</p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;public class CSVCodeConfig {    public static string DataClassFormat = @&quot;public class {0}{{    {1}}}&quot;;    //如果是带Vector3或者Vector3类型的数据需要使用带有UnityEngiine命名空间    public static string DataClassNameSpaceFormat = @&quot;using UnityEngine;public class {0}{{    {1}    }}&quot;;    public static string FieldFormat = &quot;\tpubilc {0} {1} {{ set; get; }}&quot;;    public static string ClassNameFormat = &quot;{0}Model&quot;;    public static string ModelListPrivateStatementFormat = &quot;private List&lt;{0}&gt; {1}&quot;;    public static string ModelListPublicPropertyFormat = @&quot;public List&lt;{0}&gt; {1}{{        get        {{            if({2} == null)            {{                {3}();            }}        return {4};    }}}}&quot;;    public static string parseMethodNameFormat = &quot;Init{0}&quot;;    public static string methodFormat = &quot;{0}();&quot;;    public static string ModelDataParseMethodFormat = @&quot;private void {0}(){{        {1} = new List<{2}>;        string path = DEFAULT_CSV_PATH + {3};        CSVTable csvTable = CsvLoader.LoadCSV(path);        foreach (CSVRecord record in csvTable.Records)        {{            {4} temp = new {5}();            foreach (string header in csvTable.Headers)            {{                {6}            }}        {7}.Add(temp);    }}}}&quot;;    public static string ModelDataHeaderEqualFormat_1 = @&quot;if (string.Equals(header, {0}))            {{                    {1}                }}&quot;;    public static string ModelDataHeaderEqualFormat_2 = @&quot;            else if (string.Equals(header, {0}))            {{                    {1}                }}&quot;;    public static string ModelDataFieldValuationFormat_String = &quot;temp.{0} = record.GetField(header);&quot;;    public static string ModelDataFieldValuationFormat_Int = &quot;temp.{0} = ConvertUtil.Str2Int(record.GetField(header));&quot;;    public static string ModelDataFieldValuationFormat_Double = &quot;temp.{0} = ConvertUtil.Str2Double(record.GetField(header));&quot;;    public static string ModelDataFieldValuationFormat_Bool = &quot;temp.{0} = ConvertUtil.Str2Int(record.GetField(header)) != 0;&quot;;}</{2}></code></pre><h3 id="完整工程"><a href="#完整工程" class="headerlink" title="完整工程"></a>完整工程</h3><p><a href="https://github.com/JingFengJi/CSVParseCodeCreate" target="_blank" rel="noopener"> https://github.com/JingFengJi/CSVParseCodeCreate</a></p><h3 id="第三方ReorderableList编辑器工具"><a href="#第三方ReorderableList编辑器工具" class="headerlink" title="第三方ReorderableList编辑器工具"></a>第三方ReorderableList编辑器工具</h3><p>Rotorz</p><p>下载地址： <a href="https://bitbucket.org/rotorz/reorderable-list-editor-field-for-unity" target="_blank" rel="noopener"> https://bitbucket.org/rotorz/reorderable-list-editor-field-for-unity</a></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏功能模块——新手引导</title>
      <link href="/2018/07/06/you-xi-gong-neng-mo-kuai-xin-shou-yin-dao/"/>
      <url>/2018/07/06/you-xi-gong-neng-mo-kuai-xin-shou-yin-dao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="新手引导"><a href="#新手引导" class="headerlink" title="新手引导"></a>新手引导</h1><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://img-blog.csdn.net/20180706225632527?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p><img src="https://img-blog.csdn.net/20180706225847458?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h5 id="遮罩Shader"><a href="#遮罩Shader" class="headerlink" title="遮罩Shader"></a>遮罩Shader</h5><p>1、圆形遮罩</p><pre><code>// Unity built-in shader source. Copyright (c) 2016 Unity Technologies. MIT license (see license.txt)Shader &quot;UI/BeginnerGuidance/CircleGuidance&quot;{    Properties    {        [PerRendererData] _MainTex (&quot;Sprite Texture&quot;, 2D) = &quot;white&quot; {}        _Color (&quot;Tint&quot;, Color) = (1,1,1,1)        _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8        _Stencil (&quot;Stencil ID&quot;, Float) = 0        _StencilOp (&quot;Stencil Operation&quot;, Float) = 0        _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255        _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255        _ColorMask (&quot;Color Mask&quot;, Float) = 15        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0        _Center(&quot;Center&quot;,vector) = (0,0,0,0)        _Slider(&quot;Slider&quot;,Range(0,1500)) = 1500    }    SubShader    {        Tags        {            &quot;Queue&quot;=&quot;Transparent&quot;            &quot;IgnoreProjector&quot;=&quot;True&quot;            &quot;RenderType&quot;=&quot;Transparent&quot;            &quot;PreviewType&quot;=&quot;Plane&quot;            &quot;CanUseSpriteAtlas&quot;=&quot;True&quot;        }        Stencil        {            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]        }        Cull Off        Lighting Off        ZWrite Off        ZTest [unity_GUIZTestMode]        Blend SrcAlpha OneMinusSrcAlpha        ColorMask [_ColorMask]        Pass        {            Name &quot;Default&quot;        CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma target 2.0            #include &quot;UnityCG.cginc&quot;            #include &quot;UnityUI.cginc&quot;            #pragma multi_compile __ UNITY_UI_CLIP_RECT            #pragma multi_compile __ UNITY_UI_ALPHACLIP            struct appdata_t            {                float4 vertex   : POSITION;                float4 color    : COLOR;                float2 texcoord : TEXCOORD0;                UNITY_VERTEX_INPUT_INSTANCE_ID            };            struct v2f            {                float4 vertex   : SV_POSITION;                fixed4 color    : COLOR;                float2 texcoord  : TEXCOORD0;                float4 worldPosition : TEXCOORD1;                UNITY_VERTEX_OUTPUT_STEREO            };            fixed4 _Color;            fixed4 _TextureSampleAdd;            float4 _ClipRect;            float2 _Center;            float _Slider;            v2f vert(appdata_t v)            {                v2f OUT;                UNITY_SETUP_INSTANCE_ID(v);                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(OUT);                OUT.worldPosition = v.vertex;                OUT.vertex = UnityObjectToClipPos(OUT.worldPosition);                OUT.texcoord = v.texcoord;                OUT.color = v.color * _Color;                return OUT;            }            sampler2D _MainTex;            fixed4 frag(v2f IN) : SV_Target            {                half4 color = (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd) * IN.color;                #ifdef UNITY_UI_CLIP_RECT                color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect);                #endif                #ifdef UNITY_UI_ALPHACLIP                clip (color.a - 0.001);                #endif                color.a *= (distance(IN.worldPosition.xy, _Center.xy) &gt; _Slider);                color.rgb *= color.a;                return color;            }        ENDCG        }    }}</code></pre><p>2、矩形遮罩</p><pre><code>// Unity built-in shader source. Copyright (c) 2016 Unity Technologies. MIT license (see license.txt)Shader &quot;UI/BeginnerGuidance/Rect&quot;{    Properties    {        [PerRendererData] _MainTex (&quot;Sprite Texture&quot;, 2D) = &quot;white&quot; {}        _Color (&quot;Tint&quot;, Color) = (1,1,1,1)        _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8        _Stencil (&quot;Stencil ID&quot;, Float) = 0        _StencilOp (&quot;Stencil Operation&quot;, Float) = 0        _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255        _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255        _ColorMask (&quot;Color Mask&quot;, Float) = 15        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0        _Center(&quot;Center&quot;,vector) = (0,0,0,0)        _SliderX(&quot;SliderX&quot;,Range(0,1500)) = 1500        _SliderY(&quot;SliderY&quot;,Range(0,1500)) = 1500    }    SubShader    {        Tags        {            &quot;Queue&quot;=&quot;Transparent&quot;            &quot;IgnoreProjector&quot;=&quot;True&quot;            &quot;RenderType&quot;=&quot;Transparent&quot;            &quot;PreviewType&quot;=&quot;Plane&quot;            &quot;CanUseSpriteAtlas&quot;=&quot;True&quot;        }        Stencil        {            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]        }        Cull Off        Lighting Off        ZWrite Off        ZTest [unity_GUIZTestMode]        Blend SrcAlpha OneMinusSrcAlpha        ColorMask [_ColorMask]        Pass        {            Name &quot;Default&quot;        CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma target 2.0            #include &quot;UnityCG.cginc&quot;            #include &quot;UnityUI.cginc&quot;            #pragma multi_compile __ UNITY_UI_CLIP_RECT            #pragma multi_compile __ UNITY_UI_ALPHACLIP            struct appdata_t            {                float4 vertex   : POSITION;                float4 color    : COLOR;                float2 texcoord : TEXCOORD0;                UNITY_VERTEX_INPUT_INSTANCE_ID            };            struct v2f            {                float4 vertex   : SV_POSITION;                fixed4 color    : COLOR;                float2 texcoord  : TEXCOORD0;                float4 worldPosition : TEXCOORD1;                UNITY_VERTEX_OUTPUT_STEREO            };            fixed4 _Color;            fixed4 _TextureSampleAdd;            float4 _ClipRect;            float2 _Center;            float _SliderX;            float _SliderY;            v2f vert(appdata_t v)            {                v2f OUT;                UNITY_SETUP_INSTANCE_ID(v);                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(OUT);                OUT.worldPosition = v.vertex;                OUT.vertex = UnityObjectToClipPos(OUT.worldPosition);                OUT.texcoord = v.texcoord;                OUT.color = v.color * _Color;                return OUT;            }            sampler2D _MainTex;            fixed4 frag(v2f IN) : SV_Target            {                half4 color = (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd) * IN.color;                #ifdef UNITY_UI_CLIP_RECT                color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect);                #endif                #ifdef UNITY_UI_ALPHACLIP                clip (color.a - 0.001);                #endif                float2 dis = IN.worldPosition.xy - _Center.xy;                color.a *= (abs(dis.x) &gt; _SliderX) || (abs(dis.y) &gt; _SliderY);                color.rgb *= color.a;                return color;            }        ENDCG        }    }}</code></pre><p>持续更新中……</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之十二：预制体层级全预览</title>
      <link href="/2018/06/24/unity-bian-ji-qi-tuo-zhan-zhi-shi-er-yu-zhi-ti-ceng-ji-quan-yu-lan/"/>
      <url>/2018/06/24/unity-bian-ji-qi-tuo-zhan-zhi-shi-er-yu-zhi-ti-ceng-ji-quan-yu-lan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="预制体层级全预览"><a href="#预制体层级全预览" class="headerlink" title="预制体层级全预览"></a>预制体层级全预览</h1><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>Asset面板下预制体并不会显示全，制作一个工具显示预制体的全部层级，这算是TreeView的一个应用</p><p><img src="https://img-blog.csdn.net/2018062422144114?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>代码中用了 <a href="https://blog.csdn.net/qq_26999509/article/details/80794973" target="_blank" rel="noopener"> Unity编辑器拓展之十一：通过Image Name反查Prefab</a><br>中的一个类PrefabTreeView</p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEditor.IMGUI.Controls;using UnityEngine;public class GameObjectTreeViewItem {    public TreeViewItem viewItem;    public Transform treeViewTrans;    public Transform parent;    public List&lt;Transform&gt; childs = new List&lt;Transform&gt; ();    public bool IsChild (Transform tran) {        if (null == tran) return false;        if (tran.parent == treeViewTrans) return true;        return false;    }    public void AddChildTransform (Transform childTransform) {        if (null != childTransform)            childs.Add (childTransform);    }    public bool HasChildTransform (Transform tran) {        if (null == tran) return false;        return childs.Contains (tran);    }}public class PrefabTreeView : TreeView {    private Transform[] childs;    private GameObjectTreeViewItem[] items;    public PrefabTreeView (TreeViewState state, GameObject go) : base (state) {        treeGameObject = go;        childs = treeGameObject.GetComponentsInChildren&lt;Transform&gt; (true);        items = new GameObjectTreeViewItem[childs.Length];        #region Init Items Parent        for (int i = 0; i &lt; childs.Length; i++) {            items[i] = new GameObjectTreeViewItem ();            items[i].treeViewTrans = childs[i];            if (childs[i].parent != null)                items[i].parent = childs[i].parent;        }        #endregion        #region Init Child Transform        for (int i = 0; i &lt; childs.Length; i++) {            for (int j = 0; j &lt; items.Length; j++) {                if (items[j].IsChild (childs[i])) {                    items[j].AddChildTransform (childs[i]);                    break;                }            }        }        #endregion        Reload ();    }    private GameObject treeGameObject;    private GameObjectTreeViewItem GetGameObjectTreeViewItem (GameObjectTreeViewItem[] items, Transform trans) {        if (null == items || items.Length == 0 || trans == null)            return null;        for (int i = 0; i &lt; items.Length; i++) {            if (items[i] != null &amp;&amp; items[i].treeViewTrans == trans)                return items[i];        }        return null;    }    private GameObjectTreeViewItem GetGameObjectTreeViewItem (GameObjectTreeViewItem[] items, TreeViewItem viewItem) {        if (null == items || items.Length == 0 || viewItem == null)            return null;        for (int i = 0; i &lt; items.Length; i++) {            if (null != items &amp;&amp; items[i].viewItem == viewItem)                return items[i];        }        return null;    }    protected override TreeViewItem BuildRoot () {        TreeViewItem root = new TreeViewItem { id = 0, depth = -1, displayName = &quot;root&quot; };        TreeViewItem[] childItems = new TreeViewItem[childs.Length];        for (int i = 0; i &lt; childs.Length; i++) {            childItems[i] = new TreeViewItem { id = i + 1, displayName = childs[i].name };            GameObjectTreeViewItem item = GetGameObjectTreeViewItem (items, childs[i]);            if (null != item) {                item.viewItem = childItems[i];            }        }        root.AddChild (childItems[0]);        for (int i = 0; i &lt; childItems.Length; i++) {            GameObjectTreeViewItem temp = GetGameObjectTreeViewItem (items, childItems[i]);            if (temp != null &amp;&amp; temp.childs != null) {                for (int j = 0; j &lt; temp.childs.Count; j++) {                    GameObjectTreeViewItem childItem = GetGameObjectTreeViewItem (items, temp.childs[j]);                    if (childItem != null &amp;&amp; childItem.viewItem != null) {                        childItems[i].AddChild (childItem.viewItem);                    }                }            }        }        SetupDepthsFromParentsAndChildren (root);        return root;    }}using System.Collections;using System.Collections.Generic;using UnityEditor;using UnityEditor.IMGUI.Controls;using UnityEngine;public class PrefabViewWindow : EditorWindow {    private GameObject selectPrefab = null;    [SerializeField]    TreeViewState treeViewState;    PrefabTreeView prefabTreeView;    void OnEnable () {        if (null == treeViewState)            treeViewState = new TreeViewState ();    }    [MenuItem (&quot;PrefabView/PrefabViewWindow&quot;)]    private static void ShowWindow () {        GetWindow&lt;PrefabViewWindow&gt; ().Show ();    }    private void OnGUI () {        if (null != selectPrefab) {            Rect rect = GUILayoutUtility.GetRect (0, 100000, 0, 100000);            prefabTreeView = new PrefabTreeView (treeViewState, selectPrefab);            prefabTreeView.OnGUI (rect);            prefabTreeView.ExpandAll ();        } else {        }    }    void OnSelectionChange () {        selectPrefab = Selection.activeObject as GameObject;        Repaint();    }}</code></pre><h3 id="Code下载"><a href="#Code下载" class="headerlink" title="Code下载"></a>Code下载</h3><p><a href="https://github.com/JingFengJi/PrefabViewWindow" target="_blank" rel="noopener"> https://github.com/JingFengJi/PrefabViewWindow</a></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之十一：通过Image Name反查Prefab</title>
      <link href="/2018/06/24/unity-bian-ji-qi-tuo-zhan-zhi-shi-yi-tong-guo-image-name-fan-cha-prefab/"/>
      <url>/2018/06/24/unity-bian-ji-qi-tuo-zhan-zhi-shi-yi-tong-guo-image-name-fan-cha-prefab/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="通过Image-Name快速反查Prefab"><a href="#通过Image-Name快速反查Prefab" class="headerlink" title="通过Image Name快速反查Prefab"></a>通过Image Name快速反查Prefab</h1><h3 id="开发思路"><a href="#开发思路" class="headerlink" title="开发思路"></a>开发思路</h3><p>1、获取到工程中所有Prefab<br>2、获取Prefab的所有Image和RawImage<br>3、检测Prefab下是否存在指定名称的Image</p><h3 id="编辑器示意图"><a href="#编辑器示意图" class="headerlink" title="编辑器示意图"></a>编辑器示意图</h3><p><img src="https://img-blog.csdn.net/2018062421264348?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>编辑器包括三个部分：<br>1、搜索框<br>2、预制体列表<br>3、预制体层级</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code>using System.Collections;using System.Collections.Generic;using System.IO;using UnityEditor;using UnityEditor.IMGUI.Controls;using UnityEngine;using UnityEngine.UI;public class FindPrefabByImage : EditorWindow {        private static string assetPath;        private static List&lt;string&gt; prefabPaths = new List&lt;string&gt; ();        private bool initialized = false;        private SearchField searchField;        private string searchStr;        Rect toolbarRect {            get { return new Rect (20f, 10f, position.width - 40f, 20f); }        }        Rect searchResultViewRect {            get { return new Rect (20f, 40f, (position.width - 40) / 2, position.height - 40f); }        }        Rect selectPrefabHierarchyViewRect {            get { return new Rect (position.width / 2, 40, (position.width - 40) / 2, position.height - 40f); }        }        Vector2 searchResultScrollViewPos = Vector2.zero;        [SerializeField]        TreeViewState treeViewState;        PrefabTreeView prefabTreeView;        private GameObject curSelectPrefab;        void OnEnable () {            if (null == treeViewState)                treeViewState = new TreeViewState ();        }        [MenuItem (&quot;CommonTools/图片反查预制体引用工具&quot;)]        public static FindPrefabByImage GetWindow () {            prefabPaths.Clear ();            assetPath = Application.dataPath;            GetFiles (new DirectoryInfo (assetPath), &quot;*.prefab&quot;, ref prefabPaths);            var window = GetWindow&lt;FindPrefabByImage&gt; ();            window.titleContent = new GUIContent (&quot;FindPrefab&quot;);            window.Focus ();            window.Repaint ();            return window;        }        public static void GetFiles (DirectoryInfo directory, string pattern, ref List&lt;string&gt; fileList) {            if (directory != null &amp;&amp; directory.Exists &amp;&amp; !string.IsNullOrEmpty (pattern)) {                try {                    foreach (FileInfo info in directory.GetFiles (pattern)) {                        string path = info.FullName.ToString ();                        fileList.Add (path.Substring (path.IndexOf (&quot;Assets&quot;)));                    }                } catch (System.Exception) {                    throw;                }                foreach (DirectoryInfo info in directory.GetDirectories ()) {                    GetFiles (info, pattern, ref fileList);                }            }        }        /// &lt;summary&gt;        /// 检测预制体是否包含Image组件        /// &lt;/summary&gt;        /// &lt;param name=&quot;prefab&quot;&gt;检测的预制体&lt;/param&gt;        /// &lt;param name=&quot;imageName&quot;&gt;Image名称，可为空&lt;/param&gt;        /// &lt;returns&gt;如果Image名称为空且预制体包含Image组件，或者Image不为空预制体包含该指定Image，则返回true，否则返回false&lt;/returns&gt;        public static bool CheckPrefabHasImage (GameObject prefab, string imageName = null) {            if (!string.IsNullOrEmpty (imageName))                imageName = imageName.ToLower ();            if (null == prefab) return false;            Image[] images = prefab.GetComponentsInChildren&lt;Image&gt; (true);            if (null != images &amp;&amp; images.Length &gt; 0) {                if (string.IsNullOrEmpty (imageName)) {                    return true;                } else {                    for (int i = 0; i &lt; images.Length; i++) {                        if (null != images[i] &amp;&amp; images[i].sprite != null &amp;&amp; images[i].sprite.name.ToLower() == imageName) {                            return true;                        }                    }                }            }            RawImage[] rawImages = prefab.GetComponentsInChildren&lt;RawImage&gt; (true);            if (null != rawImages &amp;&amp; rawImages.Length &gt; 0) {                if (string.IsNullOrEmpty (imageName)) {                    return true;                } else {                    for (int i = 0; i &lt; rawImages.Length; i++) {                        if (null != rawImages[i] &amp;&amp; null != rawImages[i].texture &amp;&amp; rawImages[i].texture.name.ToLower() == imageName) {                            return true;                        }                    }                }            }            return false;        }        private void InitIfNeeded () {            if (!initialized) {                if (null == searchField)                    searchField = new SearchField ();                initialized = true;            }        }        void OnGUI () {            InitIfNeeded ();            DoSearchField ();            DoSearchResultView ();            DoSelectPrefabHierarchyVieww ();        }        private void DoSearchField () {            searchStr = searchField.OnGUI (toolbarRect, searchStr);        }        private void DoSearchResultView () {            GUILayout.BeginArea (searchResultViewRect);            searchResultScrollViewPos = GUILayout.BeginScrollView (searchResultScrollViewPos);            for (int i = 0; i &lt; prefabPaths.Count; i++) {                 GameObject gameObj = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt; (@prefabPaths[i]);                if (gameObj != null)                {                    bool result = CheckPrefabHasImage (gameObj,searchStr);                    if (result)                    {                        if (GUILayout.Button (prefabPaths[i]))                        {                            curSelectPrefab = gameObj;                        }                    }                }            }            GUILayout.EndScrollView ();            GUILayout.EndArea ();        }    private void DoSelectPrefabHierarchyVieww () {        GUILayout.BeginArea (selectPrefabHierarchyViewRect);        if (null != curSelectPrefab) {            Rect rect = GUILayoutUtility.GetRect (0, 100000, 0, 100000);            prefabTreeView = new PrefabTreeView (treeViewState, curSelectPrefab);            prefabTreeView.OnGUI (rect);            prefabTreeView.ExpandAll ();        } else {        }        GUILayout.EndArea ();    }}using System.Collections;using System.Collections.Generic;using UnityEditor.IMGUI.Controls;using UnityEngine;public class GameObjectTreeViewItem {    public TreeViewItem viewItem;    public Transform treeViewTrans;    public Transform parent;    public List&lt;Transform&gt; childs = new List&lt;Transform&gt; ();    public bool IsChild (Transform tran) {        if (null == tran) return false;        if (tran.parent == treeViewTrans) return true;        return false;    }    public void AddChildTransform (Transform childTransform) {        if (null != childTransform)            childs.Add (childTransform);    }    public bool HasChildTransform (Transform tran) {        if (null == tran) return false;        return childs.Contains (tran);    }}public class PrefabTreeView : TreeView {    private Transform[] childs;    private GameObjectTreeViewItem[] items;    public PrefabTreeView (TreeViewState state, GameObject go) : base (state) {        treeGameObject = go;        childs = treeGameObject.GetComponentsInChildren&lt;Transform&gt; (true);        items = new GameObjectTreeViewItem[childs.Length];        #region Init Items Parent        for (int i = 0; i &lt; childs.Length; i++) {            items[i] = new GameObjectTreeViewItem ();            items[i].treeViewTrans = childs[i];            if (childs[i].parent != null)                items[i].parent = childs[i].parent;        }        #endregion        #region Init Child Transform        for (int i = 0; i &lt; childs.Length; i++) {            for (int j = 0; j &lt; items.Length; j++) {                if (items[j].IsChild (childs[i])) {                    items[j].AddChildTransform (childs[i]);                    break;                }            }        }        #endregion        Reload ();    }    private GameObject treeGameObject;    private GameObjectTreeViewItem GetGameObjectTreeViewItem (GameObjectTreeViewItem[] items, Transform trans) {        if (null == items || items.Length == 0 || trans == null)            return null;        for (int i = 0; i &lt; items.Length; i++) {            if (items[i] != null &amp;&amp; items[i].treeViewTrans == trans)                return items[i];        }        return null;    }    private GameObjectTreeViewItem GetGameObjectTreeViewItem (GameObjectTreeViewItem[] items, TreeViewItem viewItem) {        if (null == items || items.Length == 0 || viewItem == null)            return null;        for (int i = 0; i &lt; items.Length; i++) {            if (null != items &amp;&amp; items[i].viewItem == viewItem)                return items[i];        }        return null;    }    protected override TreeViewItem BuildRoot () {        TreeViewItem root = new TreeViewItem { id = 0, depth = -1, displayName = &quot;root&quot; };        TreeViewItem[] childItems = new TreeViewItem[childs.Length];        for (int i = 0; i &lt; childs.Length; i++) {            childItems[i] = new TreeViewItem { id = i + 1, displayName = childs[i].name };            GameObjectTreeViewItem item = GetGameObjectTreeViewItem (items, childs[i]);            if (null != item) {                item.viewItem = childItems[i];            }        }        root.AddChild (childItems[0]);        for (int i = 0; i &lt; childItems.Length; i++) {            GameObjectTreeViewItem temp = GetGameObjectTreeViewItem (items, childItems[i]);            if (temp != null &amp;&amp; temp.childs != null) {                for (int j = 0; j &lt; temp.childs.Count; j++) {                    GameObjectTreeViewItem childItem = GetGameObjectTreeViewItem (items, temp.childs[j]);                    if (childItem != null &amp;&amp; childItem.viewItem != null) {                        childItems[i].AddChild (childItem.viewItem);                    }                }            }        }        SetupDepthsFromParentsAndChildren (root);        return root;    }}</code></pre><p>代码中用到了TreeView的知识，请自行补充，后续会更新关系TreeView的知识点</p><h3 id="Code下载"><a href="#Code下载" class="headerlink" title="Code下载"></a>Code下载</h3><p><a href="https://github.com/JingFengJi/FindPrefabByImage" target="_blank" rel="noopener"> https://github.com/JingFengJi/FindPrefabByImage</a></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之十：UI对齐工具</title>
      <link href="/2018/06/22/unity-bian-ji-qi-tuo-zhan-zhi-shi-ui-dui-qi-gong-ju/"/>
      <url>/2018/06/22/unity-bian-ji-qi-tuo-zhan-zhi-shi-ui-dui-qi-gong-ju/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="示例图"><a href="#示例图" class="headerlink" title="示例图"></a>示例图</h1><p><img src="https://img-blog.csdn.net/20180622214023588?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><img src="https://img-blog.csdn.net/20180622214216448?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h1 id="开发思路"><a href="#开发思路" class="headerlink" title="开发思路"></a>开发思路</h1><p>1、获取选中的UI<br>2、根据对齐规则修改所选中UI的坐标</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="UGUIAlign-cs"><a href="#UGUIAlign-cs" class="headerlink" title="UGUIAlign.cs"></a>UGUIAlign.cs</h2><pre><code>using System.Collections;using System.Collections.Generic;using UnityEditor;using UnityEngine;public enum AlignType{    Top = 1,    Left = 2,    Right = 3,    Bottom = 4,    HorizontalCenter = 5,       //水平居中    VerticalCenter = 6,         //垂直居中    Horizontal = 7,             //横向分布    Vertical = 8,               //纵向分布}public class UGUIAlign : Editor{    [MenuItem(&quot;GameObject/UI/Align/Left 【左对齐】&quot;)]    static void AlignLeft()    {        Align(AlignType.Left);    }    [MenuItem(&quot;GameObject/UI/Align/HorizontalCenter 【水平居中】&quot;)]    static void AlignHorizontalCenter()    {        Align(AlignType.HorizontalCenter);    }    [MenuItem(&quot;GameObject/UI/Align/Right 【右对齐】&quot;)]    static void AlignRight()    {        Align(AlignType.Right);    }    [MenuItem(&quot;GameObject/UI/Align/Top 【顶端对齐】&quot;)]    static void AlignTop()    {        Align(AlignType.Top);    }    [MenuItem(&quot;GameObject/UI/Align/VerticalCenter 【垂直居中】&quot;)]    static void AlignVerticalCenter()    {        Align(AlignType.VerticalCenter);    }    [MenuItem(&quot;GameObject/UI/Align/Bottom 【底端对齐】&quot;)]    static void AlignBottom()    {        Align(AlignType.Bottom);    }    [MenuItem(&quot;GameObject/UI/Align/Horizontal 【横向分布】&quot;)]    static void AlignHorizontal()    {        Align(AlignType.Horizontal);    }    [MenuItem(&quot;GameObject/UI/Align/Vertical 【纵向分布】&quot;)]    static void AlignVertical()    {        Align(AlignType.Vertical);    }    public static void Align(AlignType type)    {        List&lt;RectTransform&gt; rects = new List&lt;RectTransform&gt;();        GameObject[] objects = Selection.gameObjects;        if (objects != null &amp;&amp; objects.Length &gt; 0)        {            for (int i = 0; i &lt; objects.Length; i++)            {                RectTransform rect = objects[i].GetComponent&lt;RectTransform&gt;();                if (rect != null)                    rects.Add(rect);            }        }        if (rects.Count &gt; 1)        {            Align(type, rects);        }    }    public static void Align(AlignType type, List&lt;RectTransform&gt; rects)    {        RectTransform tenplate = rects[0];        float w = tenplate.sizeDelta.x * tenplate.lossyScale.x;        float h = tenplate.sizeDelta.y * tenplate.localScale.y;        float x = tenplate.position.x - tenplate.pivot.x * w;        float y = tenplate.position.y - tenplate.pivot.y * h;        switch (type)        {            case AlignType.Top:                for (int i = 1; i &lt; rects.Count; i++)                {                    RectTransform trans = rects[i];                    float th = trans.sizeDelta.y * trans.localScale.y;                    Vector3 pos = trans.position;                    pos.y = y + h - th + trans.pivot.y * th;                    trans.position = pos;                }                break;            case AlignType.Left:                for (int i = 1; i &lt; rects.Count; i++)                {                    RectTransform trans = rects[i];                    float tw = trans.sizeDelta.x * trans.lossyScale.x;                    Vector3 pos = trans.position;                    pos.x = x + tw * trans.pivot.x;                    trans.position = pos;                }                break;            case AlignType.Right:                for (int i = 1; i &lt; rects.Count; i++)                {                    RectTransform trans = rects[i];                    float tw = trans.sizeDelta.x * trans.lossyScale.x;                    Vector3 pos = trans.position;                    pos.x = x + w - tw + tw * trans.pivot.x;                    trans.position = pos;                }                break;            case AlignType.Bottom:                for (int i = 1; i &lt; rects.Count; i++)                {                    RectTransform trans = rects[i];                    float th = trans.sizeDelta.y * trans.localScale.y;                    Vector3 pos = trans.position;                    pos.y = y + th * trans.pivot.y;                    trans.position = pos;                }                break;            case AlignType.HorizontalCenter:                for (int i = 1; i &lt; rects.Count; i++)                {                    RectTransform trans = rects[i];                    float tw = trans.sizeDelta.x * trans.lossyScale.x;                    Vector3 pos = trans.position;                    pos.x = x + 0.5f * w - 0.5f * tw + tw * trans.pivot.x;                    trans.position = pos;                }                break;            case AlignType.VerticalCenter:                for (int i = 1; i &lt; rects.Count; i++)                {                    RectTransform trans = rects[i];                    float th = trans.sizeDelta.y * trans.localScale.y;                    Vector3 pos = trans.position;                    pos.y = y + 0.5f * h - 0.5f * th + th * trans.pivot.y;                    trans.position = pos;                }                break;            case AlignType.Horizontal:                float minX = GetMinX(rects);                float maxX = GetMaxX(rects);                rects.Sort(SortListRectTransformByX);                float distance = (maxX - minX)/(rects.Count - 1);                for (int i = 1; i &lt; rects.Count - 1; i++)                {                    RectTransform trans = rects[i];                    Vector3 pos = trans.position;                    pos.x = minX + i * distance;                    trans.position = pos;                }                break;            case AlignType.Vertical:                float minY = GetMinY(rects);                float maxY = GetMaxY(rects);                rects.Sort(SortListRectTransformByY);                float distanceY = (maxY - minY)/(rects.Count - 1);                for (int i = 1; i &lt; rects.Count - 1; i++)                {                    RectTransform trans = rects[i];                    Vector3 pos = trans.position;                    pos.y = minY + i*distanceY;                    trans.position = pos;                }                break;        }    }    private static int SortListRectTransformByX(RectTransform r1, RectTransform r2)    {        float w = r1.sizeDelta.x * r1.lossyScale.x;        float x1 = r1.position.x - r1.pivot.x * w;        w = r2.sizeDelta.x * r2.lossyScale.x;        float x2 = r2.position.x - r2.pivot.x * w;        if (x1 &gt;= x2)            return 1;        else            return -1;    }    private static int SortListRectTransformByY(RectTransform r1, RectTransform r2)    {        float w = r1.sizeDelta.y * r1.lossyScale.y;        float y1 = r1.position.y - r1.pivot.y * w;        w = r2.sizeDelta.y * r2.lossyScale.y;        float y2 = r2.position.y - r2.pivot.y * w;        if (y1 &gt;= y2)            return 1;        else            return -1;    }    private static float GetMinX(List&lt;RectTransform&gt; rects)    {        if (null == rects || rects.Count == 0)            return 0;        RectTransform tenplate = rects[0];        float minx = tenplate.position.x;        float tempX = 0;        for (int i = 1; i &lt; rects.Count; i++)        {            tempX = rects[i].position.x;            if (tempX &lt; minx)                minx = tempX;        }        return minx;    }    private static float GetMaxX(List&lt;RectTransform&gt; rects)    {        if (null == rects || rects.Count == 0)            return 0;        RectTransform tenplate = rects[0];        float maxX = tenplate.position.x;        float tempX = 0;        for (int i = 1; i &lt; rects.Count; i++)        {            tempX = rects[i].position.x;            if (tempX &gt; maxX)                maxX = tempX;        }        return maxX;    }    private static float GetMinY(List&lt;RectTransform&gt; rects)    {        if (null == rects || rects.Count == 0)            return 0;        RectTransform tenplate = rects[0];        float minY = tenplate.position.y;        float tempX = 0;        for (int i = 1; i &lt; rects.Count; i++)        {            tempX = rects[i].position.y;            if (tempX &lt; minY)                minY = tempX;        }        return minY;    }    private static float GetMaxY(List&lt;RectTransform&gt; rects)    {        if (null == rects || rects.Count == 0)            return 0;        RectTransform tenplate = rects[0];        float maxY = tenplate.position.y;        float tempX = 0;        for (int i = 1; i &lt; rects.Count; i++)        {            tempX = rects[i].position.y;            if (tempX &gt; maxY)                maxY = tempX;        }        return maxY;    }}</code></pre><h2 id="UGUIAlignWindow-cs"><a href="#UGUIAlignWindow-cs" class="headerlink" title="UGUIAlignWindow.cs"></a>UGUIAlignWindow.cs</h2><p>为了操作更加便捷，提供一个EditorWindow类</p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEditor;using UnityEngine;public class UGUIAlignWindow : EditorWindow{    private Dictionary&lt;AlignType,Texture&gt; alignTexture = new Dictionary&lt;AlignType, Texture&gt;();     void OnEnable()    {        Texture leftTexture = Resources.Load&lt;Texture&gt;(&quot;Textures/Left&quot;);        Texture horizontalCenterTexture = Resources.Load&lt;Texture&gt;(&quot;Textures/HorizontalCenter&quot;);        Texture rightTexture = Resources.Load&lt;Texture&gt;(&quot;Textures/Right&quot;);        Texture topTexture = Resources.Load&lt;Texture&gt;(&quot;Textures/Top&quot;);        Texture verticalCenterTexture = Resources.Load&lt;Texture&gt;(&quot;Textures/VerticalCenter&quot;);        Texture bottomTexture = Resources.Load&lt;Texture&gt;(&quot;Textures/Bottom&quot;);        Texture horizontalTexture = Resources.Load&lt;Texture&gt;(&quot;Textures/Horizontal&quot;);        Texture verticalTexture = Resources.Load&lt;Texture&gt;(&quot;Textures/Vertical&quot;);        alignTexture.Add(AlignType.Left, leftTexture);        alignTexture.Add(AlignType.HorizontalCenter, horizontalCenterTexture);        alignTexture.Add(AlignType.Right, rightTexture);        alignTexture.Add(AlignType.Top, topTexture);        alignTexture.Add(AlignType.VerticalCenter, verticalCenterTexture);        alignTexture.Add(AlignType.Bottom, bottomTexture);        alignTexture.Add(AlignType.Horizontal, horizontalTexture);        alignTexture.Add(AlignType.Vertical, verticalTexture);    }    [MenuItem(&quot;UGUIAlign/Align&quot;)]    public static UGUIAlignWindow GetWindow()    {        var window = GetWindow&lt;UGUIAlignWindow&gt;();        window.titleContent = new GUIContent(&quot;UGUI Align&quot;);        window.Focus();        window.Repaint();        return window;    }    void OnGUI()    {        GUILayout.BeginHorizontal();        GUILayout.BeginVertical();        for (int i = (int)AlignType.Top; i &lt;= (int)AlignType.Vertical; i++)        {            if (GUILayout.Button(alignTexture[(AlignType)i], &quot;LargeButton&quot;))            {                UGUIAlign.Align((AlignType)i);            }            if (i%3 == 0)            {                GUILayout.EndVertical();                GUILayout.BeginVertical();            }        }        GUILayout.EndVertical();        GUILayout.EndHorizontal();    }}</code></pre><h1 id="对齐图片资源"><a href="#对齐图片资源" class="headerlink" title="对齐图片资源"></a>对齐图片资源</h1><p><img src="https://img-blog.csdn.net/2018062221455923?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h1 id="Code下载"><a href="#Code下载" class="headerlink" title="Code下载"></a>Code下载</h1><p><a href="https://github.com/JingFengJi/UGUIAlign" target="_blank" rel="noopener"> https://github.com/JingFengJi/UGUIAlign</a></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之九：SearchField</title>
      <link href="/2018/05/13/unity-bian-ji-qi-tuo-zhan-zhi-jiu-searchfield/"/>
      <url>/2018/05/13/unity-bian-ji-qi-tuo-zhan-zhi-jiu-searchfield/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>Unity官方介绍文档：</p><p><a href="https://docs.unity3d.com/ScriptReference/IMGUI.Controls.SearchField.html" target="_blank" rel="noopener"> https://docs.unity3d.com/ScriptReference/IMGUI.Controls.SearchField.html</a></p><h1 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h1><p>1、autoSetFocusOnFindCommand：当用户按下“Ctrl/Cmd + F”时，聚焦该控件，默认值为true<br>相关代码：</p><pre><code>private bool m_AutoSetFocusOnFindCommand = true;public bool autoSetFocusOnFindCommand{    get    {        return this.m_AutoSetFocusOnFindCommand;    }    set    {        this.m_AutoSetFocusOnFindCommand = value;    }}private void CommandEventHandling(){    Event current = Event.current;    if (current.type == EventType.ExecuteCommand || current.type == EventType.ValidateCommand)    {        //UnityEngine内部应该建立了commandName与按键的对应关系        //https://docs.unity3d.com/ScriptReference/Event-commandName.html        if (this.m_AutoSetFocusOnFindCommand &amp;&amp; current.commandName == &quot;Find&quot;)        {            if (current.type == EventType.ExecuteCommand)            {                this.SetFocus();            }            current.Use();        }    }}</code></pre><p>2、searchFieldControlID<br>控件的ControllID，就不多介绍了，构造函数里会为它赋值。</p><h1 id="公有函数："><a href="#公有函数：" class="headerlink" title="公有函数："></a>公有函数：</h1><p>构造函数：</p><pre><code>public SearchField(){    this.m_ControlID = GUIUtility.GetPermanentControlID();}</code></pre><p>HasFocus：</p><pre><code>public bool HasFocus(){    return GUIUtility.keyboardControl == this.m_ControlID;}</code></pre><p>SetFocus：</p><pre><code>public void SetFocus(){    this.m_WantsFocus = true;}</code></pre><p>OnGUI<br>提供了三个重载：</p><pre><code>public string OnGUI(string text, params GUILayoutOption[] options);public string OnGUI(Rect rect, string text);public string OnGUI(Rect rect, string text, GUIStyle style, GUIStyle cancelButtonStyle, GUIStyle emptyCancelButtonStyle);public string OnGUI(Rect rect, string text, GUIStyle style, GUIStyle cancelButtonStyle, GUIStyle emptyCancelButtonStyle){    this.CommandEventHandling();    this.FocusAndKeyHandling();    float fixedWidth = cancelButtonStyle.fixedWidth;    Rect position = rect;    position.width -= fixedWidth;    text = EditorGUI.TextFieldInternal(this.m_ControlID, position, text, style);    Rect position2 = rect;    position2.x += rect.width - fixedWidth;    position2.width = fixedWidth;    //搜索框的 X 按钮    if (GUI.Button(position2, GUIContent.none, (!(text != &quot;&quot;)) ? emptyCancelButtonStyle : cancelButtonStyle) &amp;&amp; text != &quot;&quot;)    {        //搜索文字 置为 Empty，并取消其聚焦        text = &quot;&quot;;        GUIUtility.keyboardControl = 0;    }    return text;}public string OnGUI(Rect rect, string text){    //EditorStyles.searchField = 搜索框样式    //EditorStyles.searchFieldCancelButton= 搜索框取消按钮样式    //EditorStyles.searchFieldCancelButtonEmpty = 搜索框 搜索关键字为空时的 样式    return this.OnGUI(rect, text, EditorStyles.searchField, EditorStyles.searchFieldCancelButton, EditorStyles.searchFieldCancelButtonEmpty);}public string OnGUI(string text, params GUILayoutOption[] options){    Rect rect = GUILayoutUtility.GetRect(36f, 1E+07f, 16f, 16f, EditorStyles.searchField, options);    return this.OnGUI(rect, text);}</code></pre><h1 id="私有函数："><a href="#私有函数：" class="headerlink" title="私有函数："></a>私有函数：</h1><p>FocusAndKeyHandling：</p><pre><code>private void FocusAndKeyHandling(){    Event current = Event.current;    //SetFocus公有接口将私有变量m_WantsFocus置为true，将controlID赋值给GUIUtility.keyboardControl以此实现Focus    if (this.m_WantsFocus &amp;&amp; current.type == EventType.Repaint)    {        GUIUtility.keyboardControl = this.m_ControlID;        EditorGUIUtility.editingTextField = true;        this.m_WantsFocus = false;    }    if (current.type == EventType.KeyDown &amp;&amp; (current.keyCode == KeyCode.DownArrow || current.keyCode == KeyCode.UpArrow) &amp;&amp; GUIUtility.keyboardControl == this.m_ControlID &amp;&amp; GUIUtility.hotControl == 0)    {        if (this.downOrUpArrowKeyPressed != null)        {            this.downOrUpArrowKeyPressed();            current.Use();        }    }}</code></pre><h1 id="Event："><a href="#Event：" class="headerlink" title="Event："></a>Event：</h1><p>downOrUpArrowKeyPressed：<br>搜索字段时检测到向上或者向下键被按下时，可以用来改变键盘焦点到另一个控件，例如TreeView，如下图</p><p><img src="https://img-blog.csdn.net/20180513181705295?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><pre><code>public event SearchField.SearchFieldCallback downOrUpArrowKeyPressed{    add    {        SearchField.SearchFieldCallback searchFieldCallback = this.downOrUpArrowKeyPressed;        SearchField.SearchFieldCallback searchFieldCallback2;        do        {            searchFieldCallback2 = searchFieldCallback;            searchFieldCallback = Interlocked.CompareExchange&lt;SearchField.SearchFieldCallback&gt;(ref this.downOrUpArrowKeyPressed, (SearchField.SearchFieldCallback)Delegate.Combine(searchFieldCallback2, value), searchFieldCallback);        }        while (searchFieldCallback != searchFieldCallback2);    }    remove    {        SearchField.SearchFieldCallback searchFieldCallback = this.downOrUpArrowKeyPressed;        SearchField.SearchFieldCallback searchFieldCallback2;        do        {            searchFieldCallback2 = searchFieldCallback;            searchFieldCallback = Interlocked.CompareExchange&lt;SearchField.SearchFieldCallback&gt;(ref this.downOrUpArrowKeyPressed, (SearchField.SearchFieldCallback)Delegate.Remove(searchFieldCallback2, value), searchFieldCallback);        }        while (searchFieldCallback != searchFieldCallback2);    }}</code></pre><p>以上代码为使用ILSpy工具反编译得来，仅供学习使用。</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之七：如何在PreferencesWindow中新增条目</title>
      <link href="/2018/04/06/unity-bian-ji-qi-tuo-zhan-zhi-qi-ru-he-zai-preferenceswindow-zhong-xin-zeng-tiao-mu/"/>
      <url>/2018/04/06/unity-bian-ji-qi-tuo-zhan-zhi-qi-ru-he-zai-preferenceswindow-zhong-xin-zeng-tiao-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="本文介绍如何在PreferencesWindow中新增条目"><a href="#本文介绍如何在PreferencesWindow中新增条目" class="headerlink" title="本文介绍如何在PreferencesWindow中新增条目"></a>本文介绍如何在PreferencesWindow中新增条目</h2><p>在 <a href="https://blog.csdn.net/qq_26999509/article/details/79829670" target="_blank" rel="noopener"> Unity编辑器拓展之六 </a><br>中，有介绍到部分PreferencesWindow.cs的代码，而本文从源码开始给大家介绍。</p><p>PreferencesWindow.cs中：</p><pre><code>private void AddCustomSections(){    Assembly[] loadedAssemblies = EditorAssemblies.loadedAssemblies;    for (int i = 0; i &lt; loadedAssemblies.Length; i++)    {        Assembly assembly = loadedAssemblies[i];        Type[] typesFromAssembly = AssemblyHelper.GetTypesFromAssembly(assembly);        Type[] array = typesFromAssembly;        for (int j = 0; j &lt; array.Length; j++)        {            Type type = array[j];            MethodInfo[] methods = type.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);            for (int k = 0; k &lt; methods.Length; k++)            {                MethodInfo methodInfo = methods[k];                //关键在这一行                PreferenceItem preferenceItem = Attribute.GetCustomAttribute(methodInfo, typeof(PreferenceItem)) as PreferenceItem;                if (preferenceItem != null)                {                    PreferencesWindow.OnGUIDelegate onGUIDelegate = Delegate.CreateDelegate(typeof(PreferencesWindow.OnGUIDelegate), methodInfo) as PreferencesWindow.OnGUIDelegate;                    if (onGUIDelegate != null)                    {                        this.m_Sections.Add(new PreferencesWindow.Section(preferenceItem.name, onGUIDelegate));                    }                }            }        }    }}</code></pre><p>代码片中标注的那一行，MSDN中的介绍是：<br>“检索应用于程序集、 模块、 类型成员或方法参数的指定类型的自定义属性。”</p><p><a href="https://msdn.microsoft.com/zh-cn/library/system.attribute.getcustomattribute%28v=vs.110%29.aspx" target="_blank" rel="noopener"> MSDN中关于该接口的介绍 </a></p><p>那么，上述代码中检索了程序中使用 PreferenceItem<br>的所有method，随后将带有PreferenceItem的methodInfo实例化成一个委托，进而构造一个Section对象，添加到m_Setions集合中。</p><p>接着，看Unity 文档，关于 PreferenceItem 的介绍。</p><p><a href="https://docs.unity3d.com/2017.2/Documentation/ScriptReference/PreferenceItem.html" target="_blank" rel="noopener">https://docs.unity3d.com/2017.2/Documentation/ScriptReference/PreferenceItem.html</a></p><p>PreferenceItem属性允许您添加首选项到preferences窗口。</p><p>解释跟源码分析的一样，接下来进行代码测试。</p><pre><code>    [PreferenceItem(&quot;Preference Item&quot;)]    private static void SelfPreferenceItem()    {        EditorGUILayout.LabelField(&quot;Self Preference Item&quot;, EditorStyles.boldLabel);        if (GUILayout.Button(&quot;Button&quot;))        {            Debug.LogError(&quot;Click&quot;);        }        EditorGUILayout.Space();    }</code></pre><p><img src="https://img-blog.csdn.net/20180406153027300?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>但是，发现有点不对劲，编辑器拓展之六中提到的选中左侧，出现问题了。没有自动选中新增的那一项。</p><p>然后通过断点，查看到反射出来的m_Sections集合里，并没有新增的那一项，使得在遍历的时候，没法自动选中它。</p><p>也就是说，AddCustomSections函数在此时并没有执行到，使得新增的 “Preference Item”<br>并没有被添加到m_Sections这个集合里。</p><p>查看一下源码中是合适调用的 AddCustomSections函数，</p><pre><code>private void OnGUI(){    if (this.m_RefreshCustomPreferences)    {        this.AddCustomSections();        this.m_RefreshCustomPreferences = false;    }    //节省篇幅，后面代码省略}</code></pre><p>也就是当m_RefreshCustomPreferences值为true时，执行一遍AddCustomSections函数。</p><p>完善代码：</p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;using System.Reflection;using System;public class OpenPreferencesWindow : EditorWindow{    [MenuItem(&quot;Tool/OpenPreferencesWindow&quot;)]    public static void Open()    {        OpenPreferencesWindow editor = EditorWindow.GetWindow&lt;OpenPreferencesWindow&gt;();    }    private void OnGUI()    {        if (GUILayout.Button(&quot;打开PerferencesWindow&quot;))        {            Assembly assembly = Assembly.GetAssembly(typeof(UnityEditor.EditorWindow));            Type type = assembly.GetType(&quot;UnityEditor.PreferencesWindow&quot;);            type.GetMethod(&quot;ShowPreferencesWindow&quot;, BindingFlags.NonPublic | BindingFlags.Static).Invoke(null, null);            EditorWindow window = EditorWindow.GetWindow(type);            //解决不能自动定位 新增条目 的问题            //手动调用一遍AddCustomSections函数            FieldInfo refreshField = type.GetField(&quot;m_RefreshCustomPreferences&quot;, BindingFlags.NonPublic | BindingFlags.Instance);            if ((bool)refreshField.GetValue(window))            {                type.GetMethod(&quot;AddCustomSections&quot;, BindingFlags.NonPublic | BindingFlags.Instance).Invoke(window, null);                refreshField.SetValue(window, false);            }            FieldInfo sectionsField = type.GetField(&quot;m_Sections&quot;, BindingFlags.Instance | BindingFlags.NonPublic);            IList sections = sectionsField.GetValue(window) as IList;            Type sectionType = sectionsField.FieldType.GetGenericArguments()[0];            FieldInfo sectionContentField = sectionType.GetField(&quot;content&quot;, BindingFlags.Instance | BindingFlags.Public);            for (int i = 0; i &lt; sections.Count; i++)            {                GUIContent sectionContent = sectionContentField.GetValue(sections[i]) as GUIContent;                if (sectionContent.text == &quot;Preference Item&quot;)                {                    FieldInfo sectionIndexField = type.GetField(&quot;m_SelectedSectionIndex&quot;, BindingFlags.Instance | BindingFlags.NonPublic);                    sectionIndexField.SetValue(window, i);                    return;                }            }        }    }    [PreferenceItem(&quot;Preference Item&quot;)]    private static void SelfPreferenceItem()    {        EditorGUILayout.LabelField(&quot;Self Preference Item&quot;, EditorStyles.boldLabel);        if (GUILayout.Button(&quot;Button&quot;))        {            Debug.LogError(&quot;Click&quot;);        }        EditorGUILayout.Space();    }}</code></pre><p>完美收工！</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> PreferencesWindow </tag>
            
            <tag> 编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之六：利用反射打开Unity Preferences Window</title>
      <link href="/2018/04/05/unity-bian-ji-qi-tuo-zhan-zhi-liu-li-yong-fan-she-da-kai-unity-preferences-window/"/>
      <url>/2018/04/05/unity-bian-ji-qi-tuo-zhan-zhi-liu-li-yong-fan-she-da-kai-unity-preferences-window/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="如何利用反射打开Unity-Preferences-Window"><a href="#如何利用反射打开Unity-Preferences-Window" class="headerlink" title="如何利用反射打开Unity Preferences Window"></a>如何利用反射打开Unity Preferences Window</h1><p>Unity Preferences Window如下图所示：</p><p><img src="https://img-blog.csdn.net/2018040521134474?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>作为Unity 的参数设置窗口，这个窗口支持新增项，当然本文不介绍这个内容，本次介绍如何利用反射、以及Unity<br>Editor代码来实现用代码打开Preferences Window以及设置选中项。</p><p>使用ILSpy工具反编译UnityEditor.dll后呢，在下图目录中的PreferencesWinndow.cs脚本</p><p><img src="https://img-blog.csdn.net/2018040521190433?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>里面有一个接口是”ShowPreferencesWindow”，从字面上就可以理解到是用来打开PreferencesWindow的。</p><pre><code>private static void ShowPreferencesWindow(){    EditorWindow window = EditorWindow.GetWindow&lt;PreferencesWindow&gt;(true, &quot;Unity Preferences&quot;);    window.minSize = new Vector2(500f, 400f);    window.maxSize = new Vector2(window.minSize.x, window.maxSize.y);    window.position = new Rect(new Vector2(100f, 100f), window.minSize);    window.m_Parent.window.m_DontSaveToLayout = true;}</code></pre><p>该函数是私有的，没办法直接调，利用反射试一下。</p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;using System.Reflection;using System;public class OpenPreferencesWindow : EditorWindow{    [MenuItem(&quot;Tool/OpenPreferencesWindow&quot;)]    public static void Open()    {        OpenPreferencesWindow editor = EditorWindow.GetWindow&lt;OpenPreferencesWindow&gt;();    }    private void OnGUI()    {        if (GUILayout.Button(&quot;打开PerferencesWindow&quot;))        {            Assembly assembly = Assembly.GetAssembly(typeof(UnityEditor.EditorWindow));            Type type = assembly.GetType(&quot;UnityEditor.PreferencesWindow&quot;);            type.GetMethod(&quot;ShowPreferencesWindow&quot;, BindingFlags.NonPublic | BindingFlags.Static).Invoke(null, null);        }    }}</code></pre><p>效果图：</p><p><img src="https://img-blog.csdn.net/20180405213022507?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>接下来，就是如何实现在打开window之后直接选中某一项。</p><p>查看一下OnEnable函数，初始化里面做了啥？</p><pre><code>private void OnEnable(){    this.prefWinExtensions = ModuleManager.GetPreferenceWindowExtensions();    this.ReadPreferences();    this.m_Sections = new List&lt;PreferencesWindow.Section&gt;();    this.m_Sections.Add(new PreferencesWindow.Section(&quot;General&quot;, new PreferencesWindow.OnGUIDelegate(this.ShowGeneral)));    this.m_Sections.Add(new PreferencesWindow.Section(&quot;External Tools&quot;, new PreferencesWindow.OnGUIDelegate(this.ShowExternalApplications)));    this.m_Sections.Add(new PreferencesWindow.Section(&quot;Colors&quot;, new PreferencesWindow.OnGUIDelegate(this.ShowColors)));    this.m_Sections.Add(new PreferencesWindow.Section(&quot;Keys&quot;, new PreferencesWindow.OnGUIDelegate(this.ShowKeys)));    this.m_Sections.Add(new PreferencesWindow.Section(&quot;GI Cache&quot;, new PreferencesWindow.OnGUIDelegate(this.ShowGICache)));    this.m_Sections.Add(new PreferencesWindow.Section(&quot;2D&quot;, new PreferencesWindow.OnGUIDelegate(this.Show2D)));    if (Unsupported.IsDeveloperBuild() || UnityConnect.preferencesEnabled)    {        this.m_Sections.Add(new PreferencesWindow.Section(&quot;Unity Services&quot;, new PreferencesWindow.OnGUIDelegate(this.ShowUnityConnectPrefs)));    }    this.m_RefreshCustomPreferences = true;}</code></pre><p>与PreferencesWindow图对比之后发现，m_Sections这个集合里存的Section对象应该就是Window左侧的可选项了。</p><p>接着看看Section这个类</p><pre><code>private class Section{    public GUIContent content;    public PreferencesWindow.OnGUIDelegate guiFunc;    public Section(string name, PreferencesWindow.OnGUIDelegate guiFunc)    {        this.content = new GUIContent(name);        this.guiFunc = guiFunc;    }    public Section(string name, Texture2D icon, PreferencesWindow.OnGUIDelegate guiFunc)    {        this.content = new GUIContent(name, icon);        this.guiFunc = guiFunc;    }    public Section(GUIContent content, PreferencesWindow.OnGUIDelegate guiFunc)    {        this.content = content;        this.guiFunc = guiFunc;    }}</code></pre><p>PreferencesWindow在OnEnable的时候，就有实例化几个对象，其中传入的第一个参数，例如“Colors”,就存在类的content中，那么只需要反射到这个content的，再遍历这个m_Sections，就可以实现选中左侧了。</p><p>完整代码，如下：</p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;using System.Reflection;using System;public class OpenPreferencesWindow : EditorWindow{    [MenuItem(&quot;Tool/OpenPreferencesWindow&quot;)]    public static void Open()    {        OpenPreferencesWindow editor = EditorWindow.GetWindow&lt;OpenPreferencesWindow&gt;();    }    private void OnGUI()    {        if (GUILayout.Button(&quot;打开PerferencesWindow&quot;))        {            Assembly assembly = Assembly.GetAssembly(typeof(UnityEditor.EditorWindow));            Type type = assembly.GetType(&quot;UnityEditor.PreferencesWindow&quot;);            type.GetMethod(&quot;ShowPreferencesWindow&quot;, BindingFlags.NonPublic | BindingFlags.Static).Invoke(null, null);            EditorWindow window = EditorWindow.GetWindow(type);            FieldInfo sectionsField = type.GetField(&quot;m_Sections&quot;, BindingFlags.Instance | BindingFlags.NonPublic);            IList sections = sectionsField.GetValue(window) as IList;            Type sectionType = sectionsField.FieldType.GetGenericArguments()[0];            FieldInfo sectionContentField = sectionType.GetField(&quot;content&quot;, BindingFlags.Instance | BindingFlags.Public);            for (int i = 0; i &lt; sections.Count; i++)            {                GUIContent sectionContent = sectionContentField.GetValue(sections[i]) as GUIContent;                if (sectionContent.text == &quot;Colors&quot;)                {                    FieldInfo sectionIndexField = type.GetField(&quot;m_SelectedSectionIndex&quot;, BindingFlags.Instance | BindingFlags.NonPublic);                    sectionIndexField.SetValue(window, i);                    return;                }            }        }    }}</code></pre><p>效果图：</p><p><img src="https://img-blog.csdn.net/20180405215336898?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2OTk5NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>如果插件中有在PreferencesWindow中添加项，就可以通过这个让用户快捷打开了。</p><p>通过这篇文章，希望可以帮助大家学会如何分析反编译出的代码，分析UnityEditor如何实现的编辑器，以此来写出更加实用的插件</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之五：修改脚本icon</title>
      <link href="/2017/12/28/unity-bian-ji-qi-tuo-zhan-zhi-wu-xiu-gai-jiao-ben-icon/"/>
      <url>/2017/12/28/unity-bian-ji-qi-tuo-zhan-zhi-wu-xiu-gai-jiao-ben-icon/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>Unity修改脚本在Project面板中显示的icon有两种方法，<br>先看示意图：<br><img src="https://img-blog.csdn.net/20171228000919910?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>方法1：修改脚本的meta文件<br>脚本的 meta文件默认如下所示：</p><p><img src="https://img-blog.csdn.net/20171228001130631?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>注意到，图中的icon，填的“instanceID = 0”即为默认显示</p><p>在里面填入icon文件的fileid和guid，如下所示，即可实现。</p><p><img src="https://img-blog.csdn.net/20171228001038478?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>方法二：简单粗暴，Unity直接可以设置。。。</p><p><img src="https://img-blog.csdn.net/20171228001444719?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之四：ConsoleWindow中的双击日志定位</title>
      <link href="/2017/11/12/unity-bian-ji-qi-tuo-zhan-zhi-si-consolewindow-zhong-de-shuang-ji-ri-zhi-ding-wei/"/>
      <url>/2017/11/12/unity-bian-ji-qi-tuo-zhan-zhi-si-consolewindow-zhong-de-shuang-ji-ri-zhi-ding-wei/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>原文地址： <a href="http://blog.csdn.net/l449612236/article/details/76087616" target="_blank" rel="noopener"> http://blog.csdn.net/l449612236/article/details/76087616</a></p><p>感谢上位博主的分享。</p><p>本文在此基础上，做了分析加上了更加详细的介绍。</p><p>新建LogEditor脚本<br>直接上源码以及注释：</p><pre><code>using System.Reflection;using UnityEditor;using UnityEngine;public class LogEditor {    private class LogEditorConfig    {        public string logScriptPath = &quot;&quot;;   //自定义日志脚本路径        public string logTypeName = &quot;&quot;;     //脚本type        public int instanceID = 0;        public LogEditorConfig(string logScriptPath, System.Type logType)        {            this.logScriptPath = logScriptPath;            this.logTypeName = logType.FullName;        }    }    //配置的日志    private static LogEditorConfig[] _logEditorConfig = new LogEditorConfig[]    {        new LogEditorConfig(&quot;Assets/Scripts/DDebug/DDebug.cs&quot;,typeof(DDebug))    };    //处理从ConsoleWindow双击跳转    [UnityEditor.Callbacks.OnOpenAssetAttribute(-1)]    private static bool OnOpenAsset(int instanceID,int line)    {        for (int i = _logEditorConfig.Length - 1; i &gt;= 0; --i)        {            var configTmp = _logEditorConfig[i];            UpdateLogInstanceID(configTmp);            if (instanceID == configTmp.instanceID)            {                var statckTrack = GetStackTrace();                if (!string.IsNullOrEmpty(statckTrack))                {                    /*                    举例说明：下面这段是一条ConsoleWindow的日志信息                    Awake                    UnityEngine.Debug:Log(Object)                    DDebug:Log(String) (at Assets/Scripts/DDebug/DDebug.cs:13)                    Test:Awake() (at Assets/Scripts/Test.cs:13)                    说明：                    1、其中第一行的&quot;Awake&quot;:是指调用自定义打印日志函数的函数名，本例是在Test脚本中的Awake函数里调用的                    2、第二行的&quot;UnityEngine.Debug:Log(Object)&quot;:是指该日志最底层是通过Debug.Log函数打印出来的                    3、第三行的&quot;DDebug:Log(String) (at Assets/Scripts/DDebug/DDebug.cs:13)&quot;:指第二行的函数调用在DDebug.cs的13行                    4、第四行的&quot;Test:Awake() (at Assets/Scripts/Test.cs:13)&quot;:指Test.cs脚本的Awake函数调用了第二行的DDebug.cs的Log函数，在第13行                     */                    //通过以上信息，不难得出双击该日志应该打开Test.cs文件，并定位到第13行                    //以换行分割堆栈信息                    var fileNames = statckTrack.Split(&#39;\n&#39;);                    //定位到调用自定义日志函数的那一行：&quot;Test:Awake() (at Assets/Scripts/Test.cs:13)&quot;                    var fileName = GetCurrentFullFileName(fileNames);                    //定位到上例的行数：13                    var fileLine = LogFileNameToFileLine(fileName);                    //得到调用自定义日志函数的脚本：&quot;Assets/Scripts/Test.cs&quot;                    fileName = GetRealFileName(fileName);                    //根据脚本名和行数，打开脚本                    //&quot;Assets/Scripts/Test.cs&quot;                    //13                    AssetDatabase.OpenAsset(AssetDatabase.LoadAssetAtPath&lt;UnityEngine.Object&gt;(fileName), fileLine);                    return true;                }                break;            }        }        return false;    }    /// &lt;summary&gt;    /// 反射出日志堆栈    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    private static string GetStackTrace()    {        var consoleWindowType = typeof(EditorWindow).Assembly.GetType(&quot;UnityEditor.ConsoleWindow&quot;);        var fieldInfo = consoleWindowType.GetField(&quot;ms_ConsoleWindow&quot;, BindingFlags.Static | BindingFlags.NonPublic);        var consoleWindowInstance = fieldInfo.GetValue(null);        if (null != consoleWindowInstance)        {            if ((object)EditorWindow.focusedWindow == consoleWindowInstance)            {                fieldInfo = consoleWindowType.GetField(&quot;m_ActiveText&quot;, BindingFlags.Instance | BindingFlags.NonPublic);                string activeText = fieldInfo.GetValue(consoleWindowInstance).ToString();                return activeText;            }        }        return &quot;&quot;;    }    private static void UpdateLogInstanceID(LogEditorConfig config)    {        if (config.instanceID &gt; 0)        {            return;        }        var assetLoadTmp = AssetDatabase.LoadAssetAtPath&lt;UnityEngine.Object&gt;(config.logScriptPath);        if (null == assetLoadTmp)        {            throw new System.Exception(&quot;not find asset by path=&quot; + config.logScriptPath);        }        config.instanceID = assetLoadTmp.GetInstanceID();    }    private static string GetCurrentFullFileName(string[] fileNames)    {        string retValue = &quot;&quot;;        int findIndex = -1;        for (int i = fileNames.Length - 1; i &gt;= 0; --i)        {            bool isCustomLog = false;            for (int j = _logEditorConfig.Length - 1; j &gt;= 0; --j)            {                if (fileNames[i].Contains(_logEditorConfig[j].logTypeName))                {                    isCustomLog = true;                    break;                }            }            if (isCustomLog)            {                findIndex = i;                break;            }        }        if (findIndex &gt;= 0 &amp;&amp; findIndex &lt; fileNames.Length - 1)        {            retValue = fileNames[findIndex + 1];        }        return retValue;    }    private static string GetRealFileName(string fileName)    {        int indexStart = fileName.IndexOf(&quot;(at &quot;) + &quot;(at &quot;.Length;        int indexEnd = ParseFileLineStartIndex(fileName) - 1;        fileName = fileName.Substring(indexStart, indexEnd - indexStart);        return fileName;    }    private static int LogFileNameToFileLine(string fileName)    {        int findIndex = ParseFileLineStartIndex(fileName);        string stringParseLine = &quot;&quot;;        for (int i = findIndex; i &lt; fileName.Length; ++i)        {            var charCheck = fileName[i];            if (!IsNumber(charCheck))            {                break;            }            else            {                stringParseLine += charCheck;            }        }        return int.Parse(stringParseLine);    }    private static int ParseFileLineStartIndex(string fileName)    {        int retValue = -1;        for (int i = fileName.Length - 1; i &gt;= 0; --i)        {            var charCheck = fileName[i];            bool isNumber = IsNumber(charCheck);            if (isNumber)            {                retValue = i;            }            else            {                if (retValue != -1)                {                    break;                }            }        }        return retValue;    }    private static bool IsNumber(char c)    {        return c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;;    }}</code></pre><p>该脚本放置在工程目录下的Editor文件夹中。</p><p>接着实现自己的日志类，我这里取名为DDebug类。<br>我之前也介绍过一篇文章，实现自己的Debug类<br>地址如下： <a href="http://blog.csdn.net/qq_26999509/article/details/53643564" target="_blank" rel="noopener"> http://blog.csdn.net/qq_26999509/article/details/53643564</a></p><p>当初写的不够成熟，大家可以按照自己意愿进行编写。<br>本次主要是为了实现双击日志定位的功能。</p><p>下面附上本次测试写的DDebug脚本：</p><pre><code>using UnityEngine;public class DDebug {    static private string errorColor = &quot;red&quot;;    static private string warningColor = &quot;yellow&quot;;    static private string logColor = &quot;white&quot;;    public static void Log(string info)    {        info = string.Concat(&quot;&lt;color=&quot;, logColor, &quot;&gt;&quot;, info, &quot;&lt;/color&gt;&quot;);        Debug.Log(info);    }    public static void LogError(string info)    {        info = string.Concat(&quot;&lt;color=&quot;, errorColor, &quot;&gt;&quot;, info, &quot;&lt;/color&gt;&quot;);        Debug.LogError(info);    }    public static void LogWarning(string info)    {        info = string.Concat(&quot;&lt;color=&quot;, warningColor, &quot;&gt;&quot;, info, &quot;&lt;/color&gt;&quot;);        Debug.LogWarning(info);    }}</code></pre><p>这里只是加了颜色而已，其实还有不少功能可以拓展。</p><p>接下来写个Test测试脚本，进行代码测试。</p><pre><code>using UnityEngine;public class Test : MonoBehaviour {    private void OnEnable()    {        DDebug.LogWarning(&quot;OnEnable&quot;);    }    void Awake()    {        DDebug.Log(&quot;Awake&quot;);    }    void Start ()     {        DDebug.LogError(&quot;Start&quot;);    }}</code></pre><p>将该脚本挂在场景中。</p><p>测试如下：</p><p><img src="https://img-blog.csdn.net/20171112231731303?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>双击日志也能成功跳转到日志函数调用的地方。。测试通过。</p><p>最后附上工程地址：<br>链接： <a href="http://pan.baidu.com/s/1c2La0hy" target="_blank" rel="noopener"> http://pan.baidu.com/s/1c2La0hy </a><br>密码：ibqb</p><p>再次补充，原文地址： <a href="http://blog.csdn.net/l449612236/article/details/76087616" target="_blank" rel="noopener"> http://blog.csdn.net/l449612236/article/details/76087616</a></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity插件推荐</title>
      <link href="/2017/11/07/unity-cha-jian-tui-jian/"/>
      <url>/2017/11/07/unity-cha-jian-tui-jian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h3 id="一、可视化PlayerPrefs"><a href="#一、可视化PlayerPrefs" class="headerlink" title="一、可视化PlayerPrefs"></a>一、可视化PlayerPrefs</h3><p>Advanced PlayerPrefs Window插件是一款PlayerPrefs数据的可视化管理插件</p><p>下载地址： <a href="http://www.taidous.com/forum.php?mod=viewthread&tid=59744&highlight=PlayerPrefs" target="_blank" rel="noopener">http://www.taidous.com/forum.php?mod=viewthread&amp;tid=59744&amp;highlight=PlayerPrefs</a></p><p>或者链接： <a href="http://pan.baidu.com/s/1bpg0AYF" target="_blank" rel="noopener"> http://pan.baidu.com/s/1bpg0AYF </a><br>密码：w9vm</p><p>插件界面如下图所示：</p><p><img src="https://img-blog.csdn.net/20171106235922648?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="插件代码分析："><a href="#插件代码分析：" class="headerlink" title="插件代码分析："></a>插件代码分析：</h4><p>至于编辑器的代码就不解释了，主要来看一下该插件是如何获取到工程里关于PlayerPrefs数据的所有的key 的。<br>先看一下官方文档中关于PlayerPrefs的解释：<br><a href="https://docs.unity3d.com/2017.2/Documentation/ScriptReference/PlayerPrefs.html" target="_blank" rel="noopener">https://docs.unity3d.com/2017.2/Documentation/ScriptReference/PlayerPrefs.html</a></p><p>其中</p><p><img src="https://img-blog.csdn.net/20171107000252250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>从图中可以看出Unity将这些数据在各平台下存储的位置，以Windows为例，其数据存储在注册表中的</p><p>HKCU/Software[company name][product name]中</p><p>下面是截图：<br><img src="https://img-blog.csdn.net/20171107000710134?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>图中可见该工程包含了5个key，其中UnityGraphicsQuality是Unity工程自带的。</p><p>下面上一段该插件从注册表中获取key的代码（Windows平台的）</p><pre><code>        private string[] GetAllWindowsKeys()        {            RegistryKey cuKey = Registry.CurrentUser;            RegistryKey unityKey;            //The default location of PlayerPrefs pre Unity 5_5#if UNITY_5_5_OR_NEWER            unityKey = cuKey.CreateSubKey(&quot;Software\\Unity\\UnityEditor\\&quot; + PlayerSettings.companyName + &quot;\\&quot; + PlayerSettings.productName);#else            unityKey = cuKey.CreateSubKey(&quot;Software\\&quot; + PlayerSettings.companyName + &quot;\\&quot; + PlayerSettings.productName);            if (unityKey.GetValueNames().Length == 0)            {                //On some machines (Windows 7 &amp; 8 64bit using Unity5.4) PlayersPrefs are saved in HKEY_CURRENT_USER\SOFTWARE\AppDataLow\Software\CompanyName\ProjectName weird enough...                unityKey = cuKey.CreateSubKey(&quot;Software\\AppDataLow\\Software\\&quot; + PlayerSettings.companyName + &quot;\\&quot; + PlayerSettings.productName);            }#endif            string[] values = unityKey.GetValueNames();            for (int i = 0; i &lt; values.Length; i++)            {                values[i] = values[i].Substring(0, values[i].LastIndexOf(&quot;_&quot;));            }            return values;        }</code></pre><p>代码不一一解释了，关于RegistryKey类和Registry类查看一下MSDN：<br><a href="https://msdn.microsoft.com/zh-cn/library/microsoft.win32.registrykey(v=vs.110).aspx" target="_blank" rel="noopener"> https://msdn.microsoft.com/zh-cn/library/microsoft.win32.registrykey(v=vs.110).aspx</a><br><a href="https://msdn.microsoft.com/zh-cn/library/microsoft.win32.registry(v=vs.110).aspx" target="_blank" rel="noopener"> https://msdn.microsoft.com/zh-cn/library/microsoft.win32.registry(v=vs.110).aspx</a></p><p>以上知识分享，步骤详细，如有错误，欢迎指出，共同学习，共同进步</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity&amp;Android之二：获取手机电量信息、网络状况</title>
      <link href="/2017/11/04/unity-yu-android-zhi-er-huo-qu-shou-ji-dian-liang-xin-xi-wang-luo-zhuang-kuang/"/>
      <url>/2017/11/04/unity-yu-android-zhi-er-huo-qu-shou-ji-dian-liang-xin-xi-wang-luo-zhuang-kuang/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Unity-amp-Android之二：获取手机电量信息、网络状况"><a href="#Unity-amp-Android之二：获取手机电量信息、网络状况" class="headerlink" title="Unity&amp;Android之二：获取手机电量信息、网络状况"></a>Unity&amp;Android之二：获取手机电量信息、网络状况</h1><p>游戏中经常会在UI显示电量以及网络状况</p><p>手机电量包括：<br>1、当前正在充电还是放电<br>2、当前电量值</p><p>网络包括：<br>1、如果是WIFI，WIFI信号强度<br>2、如果是流量，信号强度等数据</p><p>例如王者荣耀中右上角所示<br><img src="https://img-blog.csdn.net/20171104150659066?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>那么接下来就介绍一下如何实现获取手机电量信息以及网络状况等数据。</p><h4 id="1、打开Eclipse建一个安卓库工程，注意是库工程"><a href="#1、打开Eclipse建一个安卓库工程，注意是库工程" class="headerlink" title="1、打开Eclipse建一个安卓库工程，注意是库工程"></a>1、打开Eclipse建一个安卓库工程，注意是库工程</h4><p><img src="https://img-blog.csdn.net/20171104151235368?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="这里注意一下包名"><a href="#这里注意一下包名" class="headerlink" title="这里注意一下包名"></a>这里注意一下包名</h4><p><img src="https://img-blog.csdn.net/20171104151506838?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="https://img-blog.csdn.net/20171104151651454?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>Icon显示方式选择，默认即可</p><p><img src="https://img-blog.csdn.net/20171104151745185?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>选择一个空的activity</p><p><img src="https://img-blog.csdn.net/20171104151831195?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>安卓Activity名称，默认即可，Finish</p><p><img src="https://img-blog.csdn.net/20171104151909255?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>创建完之后，就会得到这样一个工程</p><p><img src="https://img-blog.csdn.net/20171104152012704?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>至于目录结构，请自行补充相关知识</p><p>工程创建好，此时安卓还无法与Unity进行交互，需要为工程导入一个Unity提供的classes.jar，该文件在Unity的安装目录下</p><p><img src="https://img-blog.csdn.net/20171104152233437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>将该jar文件导入到工程目录下的libs文件夹中，鼠标选中工程根目录</p><p><img src="https://img-blog.csdn.net/20171104152504759?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>准备工作完成之后，就可以开始编写代码了。</p><p>修改MainActivity.java类的父类为UnityPlayerActivity</p><p>该类需要import相关的包</p><pre><code>import com.unity3d.player.UnityPlayerActivity;</code></pre><p>删除onCreate函数中的</p><pre><code>setContentView(R.layout.activity_main);</code></pre><p>至此，MainActivity.java文件代码如下：</p><pre><code>package com.unityplugin.phonepower;import com.unity3d.player.UnityPlayerActivity;import android.os.Bundle;import android.app.Activity;import android.view.Menu;public class MainActivity extends UnityPlayerActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);    }    @Override    public boolean onCreateOptionsMenu(Menu menu) {        // Inflate the menu; this adds items to the action bar if it is present.        getMenuInflater().inflate(R.menu.main, menu);        return true;    }}</code></pre><p>接下来编写函数以供Unity调用</p><p>完整代码如下：</p><pre><code>package com.unityplugin.phonepower;import com.unity3d.player.UnityPlayerActivity;import android.net.wifi.WifiInfo;import android.net.wifi.WifiManager;import android.os.Bundle;import android.app.Activity;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.view.Menu;public class MainActivity extends UnityPlayerActivity {    private static Context instance;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        instance = getApplication();    }    @Override    public boolean onCreateOptionsMenu(Menu menu) {        // Inflate the menu; this adds items to the action bar if it is present.        getMenuInflater().inflate(R.menu.main, menu);        return true;    }    //获取手机当前电量、总电量（默认其实都是100）、当前状态（充电还是放电）    //其余数据例如电压、电池温度用的较少    public String MonitorBatteryState()    {        IntentFilter iFilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);        Intent intent = instance.registerReceiver(null, iFilter);        int rawLevel = intent.getIntExtra(&quot;level&quot;, 0);      //获得当前电量        int scale = intent.getIntExtra(&quot;scale&quot;, 0);         //获得总电量        int status = intent.getIntExtra(&quot;status&quot;, 0);       //电池充电状态        int health = intent.getIntExtra(&quot;voltage&quot;, 0);      //电池健康状况        int batteryV = intent.getIntExtra(&quot;voltage&quot;, 0);    //电池电压(mv)        int temperature = intent.getIntExtra(&quot;temperature&quot;, 0); //电池温度(数值)        double t = temperature / 10.0;  //电池摄氏温度，默认获取的非摄氏温度值，需做一下运算转换        String targetStr = &quot;&quot;;        int level = -1;        if(rawLevel &gt; 0 &amp;&amp; scale &gt; 0)        {            level = (rawLevel * 100) / scale;            targetStr = level + &quot;|&quot; + scale + &quot;|&quot; + status;        }        return targetStr;    }    //获取Wifi信号强度    @SuppressWarnings(&quot;deprecation&quot;)    private String ObtainWifiInfo()    {        String result = &quot;&quot;;        WifiManager wifiManager = (WifiManager)getApplication().getSystemService(WIFI_SERVICE);        WifiInfo info = wifiManager.getConnectionInfo();        if(info.getBSSID() != null)        {            //链接信号强度            int strength = WifiManager.calculateSignalLevel(info.getRssi(), 5);            //链接速度            int speed = info.getLinkSpeed();            //链接速度单位            String units = WifiInfo.LINK_SPEED_UNITS;            //Wifi源名称            String ssid = info.getSSID();            int ip = info.getIpAddress();            String mac = info.getMacAddress();            result = strength + &quot;|&quot; + IntToIp(ip) + &quot;|&quot; + mac + &quot;|&quot; + ssid;        }        return result;    }    private String IntToIp(int paramInt)    {        return (paramInt &amp; 0xFF) + &quot;.&quot; + (0xFF &amp; paramInt &gt;&gt; 8) + &quot;.&quot; + (0xFF &amp; paramInt &gt;&gt; 16) + &quot;.&quot; + (0xFF &amp; paramInt &gt;&gt; 24);    }}</code></pre><p>代码编写完之后，还有一件重要的事情，那就是手机权限。<br>访问手机电量，不需要权限，不过WIFI状况需要添加一个权限。</p><h3 id="如何添加权限"><a href="#如何添加权限" class="headerlink" title="如何添加权限"></a>如何添加权限</h3><p>双击AndroidManifest.xml文件<br><img src="https://img-blog.csdn.net/20171104153826100?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>点击Add按钮添加权限</p><p><img src="https://img-blog.csdn.net/20171104153911163?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>选中最后一项Uses Permission</p><p>添加Name为android.permission.ACCESS_WIFI_STATE的权限</p><p><img src="https://img-blog.csdn.net/20171104154000967?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="记得保存该文件！"><a href="#记得保存该文件！" class="headerlink" title="记得保存该文件！"></a>记得保存该文件！</h3><p>权限弄完之后即可到处jar包到Unity工程中了。</p><p><img src="https://img-blog.csdn.net/20171104154131855?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="https://img-blog.csdn.net/20171104154205290?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="https://img-blog.csdn.net/20171104154304138?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>jar导出后，就可以创建一个Unity工程，进行测试了。</p><p>创建一个Plugins/Android的文件夹，该文件夹用来 存放安卓插件的。</p><p>将Android工程中的Libs、Res、AndroidMainFest.xml文件拷贝过来，如下：<br><img src="https://img-blog.csdn.net/20171104154629294?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>接下来编写测试代码：</p><p>在场景中创建一个Button（用来点击从安卓那边获取数据）和两个text（分别用来显示电量数据和wifi数据），并创建一个test脚本</p><p><img src="https://img-blog.csdn.net/20171104155525241?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>脚本代码如下：</p><pre><code>using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class Test : MonoBehaviour {    public Button button;    public Text phonePowerText;    public Text wifiText;    private string batteryData;    private string wifiData;    void Awake()    {        button.onClick.AddListener(OnButtonClicked);    }    private void OnButtonClicked()    {        AndroidJavaClass jc = new AndroidJavaClass(&quot;com.unity3d.player.UnityPlayer&quot;);        AndroidJavaObject jo = jc.GetStatic&lt;AndroidJavaObject&gt;(&quot;currentActivity&quot;);        batteryData = jo.Call&lt;string&gt;(&quot;MonitorBatteryState&quot;);        wifiData = jo.Call&lt;string&gt;(&quot;ObtainWifiInfo&quot;);        OnBatteryDataBack(batteryData);        OnWifiDataBack(wifiData);    }    //安卓那边将数据以“|”进行分割，所以这边以&quot;|&quot;来分割数据    private void OnBatteryDataBack(string data)    {        phonePowerText.text = &quot;&quot;;        string[] args = data.Split(&#39;|&#39;);        if (args[2] == &quot;2&quot;)        {            phonePowerText.text += &quot;电池充电中\n&quot;;        }        else        {            phonePowerText.text += &quot;电池放电中\n&quot;;        }        int curPower = int.Parse(args[0]);        float power = float.Parse(args[1]);        float percent = curPower / power;        phonePowerText.text += &quot; cur power:&quot; + curPower;        phonePowerText.text += &quot;  all power:&quot; + power;        phonePowerText.text += &quot; 电量比例：&quot; + (Mathf.CeilToInt(percent * 100) + &quot;%&quot;).ToString();    }    private void OnWifiDataBack(string data)    {        wifiText.text = &quot;&quot;;        wifiText.text += wifiData;        string[] args = wifiData.Split(&#39;|&#39;);        int wifiLevel = int.Parse(args[0]);        wifiText.text += &quot;Wifi信号格数：&quot; + wifiLevel.ToString() + &quot;\n&quot;;        string ip = &quot;IP：&quot; + args[1] + &quot;\n&quot;;        string mac = &quot;MAC:&quot; + args[2] + &quot;\n&quot;;        string ssid = &quot;Wifi Name:&quot; + args[3] + &quot;\n&quot;;        wifiText.text += ip;        wifiText.text += mac;        wifiText.text += ssid;    }}</code></pre><p>记得将工程平台切换成Android</p><p>最后设置PlayerSettings，</p><p><img src="https://img-blog.csdn.net/20171104155855294?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>可以build成apk了。</p><p>测试截图：</p><p><img src="https://img-blog.csdn.net/20171104160949446?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>从图中可以看出<br>当前手机正在充电，并且电量为60，至于图中的61属于浮点类型数据的运算带来的精度问题，不过这点问题在应用中不足为虑。<br>而wifi状况则是，四格信号，都是正常的。</p><p>抱歉，IP地址被我打码了。</p><p>以上知识分享，步骤详细，如有错误，欢迎指出，共同学习，共同进步</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity&amp;Android之一：手机震动</title>
      <link href="/2017/11/04/unity-yu-android-zhi-yi-shou-ji-zhen-dong/"/>
      <url>/2017/11/04/unity-yu-android-zhi-yi-shou-ji-zhen-dong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Unity调用手机震动"><a href="#Unity调用手机震动" class="headerlink" title="Unity调用手机震动"></a>Unity调用手机震动</h1><p>在游戏中，有时为了增加游戏的打击感，会使用手机震动。关于手机震动其实很简单。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>Unity中提供了一个接口</p><pre><code>Handheld.Vibrate();</code></pre><p>该接口无需做平台判断。<br>官方介绍：Triggers device vibration.<br>翻译就是指触发装置振动。<br><a href="https://docs.unity3d.com/2017.3/Documentation/ScriptReference/Handheld.Vibrate.html" target="_blank" rel="noopener">https://docs.unity3d.com/2017.3/Documentation/ScriptReference/Handheld.Vibrate.html</a></p><p>该接口无法为振动设置时长、频率等。如有需要，安卓则需要通过获取系统服务后开启振动</p><pre><code>public void Shake()    {        Activity curActivity = UnityPlayer.currentActivity;        m_vibrator = (Vibrator)curActivity.getSystemService(Service.VIBRATOR_SERVICE);        m_vibrator.vibrate(new long[]{100,10,100,1000},-1);    }</code></pre><p>详情参考：<br><a href="http://www.cnblogs.com/android-blogs/p/6381850.html" target="_blank" rel="noopener"> http://www.cnblogs.com/android-blogs/p/6381850.html </a></p><p>如果只是简单的使用，Unity 提供的接口已经够了。。</p><h4 id="请在真机下进行测试"><a href="#请在真机下进行测试" class="headerlink" title="请在真机下进行测试"></a>请在真机下进行测试</h4><p>最近正在补充Unity跟Android交互相关的知识，包括接入SDK、游戏中使用二维码等</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之三：拓展Unity的Hierarchy面板</title>
      <link href="/2017/09/16/unity-bian-ji-qi-tuo-zhan-zhi-san-tuo-zhan-unity-de-hierarchy-mian-ban/"/>
      <url>/2017/09/16/unity-bian-ji-qi-tuo-zhan-zhi-san-tuo-zhan-unity-de-hierarchy-mian-ban/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>效果图：</p><p><img src="https://img-blog.csdn.net/20170916213433810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>上图中在Hierarchy右侧绘制了Toggle，Label，以及自定义的texture和Unity原声的Texture，知道了原理，其实这些都很简单。。</p><p>这里主要是使用了EditorApplication类下的HierarchyWindowItemCallback类型的hierarchyWindowItemOnGUI</p><pre><code>        //        // 摘要:        //     ///        //     Delegate to be called for every visible list item in the HierarchyWindow on every        //     OnGUI event.        //     ///        //        // 参数:        //   instanceID:        //        //   selectionRect:        public delegate void HierarchyWindowItemCallback(int instanceID, Rect selectionRect);</code></pre><p>该委托有两个参数，一个是int类型的instanceID，通过该ID利用EditorUtility.InstanceIDToObject(instanceID)可以获取该GameObject，然后第二个参数Rect，也就是该物体在Hierarchy面板的位置信息了，通过这两个数据，在Hierarchy面板上拓展就很简单了。</p><pre><code>using System;using System.Collections;using System.Collections.Generic;using UnityEditor;using UnityEngine;using UnityEngine.Networking;using UnityEngine.UI;[InitializeOnLoad]public class HierachyIconManager{    // 层级窗口项回调    private static readonly EditorApplication.HierarchyWindowItemCallback hiearchyItemCallback;    private static Texture2D hierarchyIcon;    private static Texture2D HierarchyIcon    {        get        {            if (HierachyIconManager.hierarchyIcon == null)            {                HierachyIconManager.hierarchyIcon = (Texture2D)Resources.Load(&quot;icon_1&quot;);            }            return HierachyIconManager.hierarchyIcon;        }    }    /// &lt;summary&gt;    /// 静态构造    /// &lt;/summary&gt;    static HierachyIconManager()    {        HierachyIconManager.hiearchyItemCallback = new EditorApplication.HierarchyWindowItemCallback(HierachyIconManager.DrawHierarchyIcon);        EditorApplication.hierarchyWindowItemOnGUI = (EditorApplication.HierarchyWindowItemCallback)Delegate.Combine(            EditorApplication.hierarchyWindowItemOnGUI,            HierachyIconManager.hiearchyItemCallback);        //EditorApplication.update += Update;    }    // 绘制icon方法    private static void DrawHierarchyIcon(int instanceID, Rect selectionRect)    {        Rect rectCheck = new Rect(selectionRect);        rectCheck.x += rectCheck.width - 20;        rectCheck.width = 18;        GameObject go = EditorUtility.InstanceIDToObject(instanceID) as GameObject;        go.SetActive(GUI.Toggle(rectCheck, go.activeSelf, string.Empty));        var index = 0;        GUIStyle style = null;        if (go.isStatic)        {            index += 1;            Rect rectIcon = GetRect(selectionRect, index);            GUI.Label(rectIcon, &quot;S&quot;);        }        // 文字颜色定义         var colorMesh = new Color(42 / 255f, 210 / 255f, 235 / 255f);        var colorSkinMesh = new Color(0.78f, 0.35f, 0.78f);        var colorLight = new Color(251 / 255f, 244 / 255f, 124 / 255f);        var colorPhysic = new Color(0.35f, 0.75f, 0f);        var colorCollider = new Color(0.35f, 0.75f, 0.196f);        var colorAnimation = new Color(175 / 255f, 175 / 255f, 218 / 255f);        var colorCamera = new Color(111 / 255f, 121 / 255f, 212 / 255f);        var colorParticle = new Color(130 / 255f, 124 / 255f, 251 / 255f);        var colorNav = new Color(217 / 255f, 80 / 255f, 62 / 255f);        var colorNetwork = new Color(42 / 255f, 129 / 255f, 235 / 255f);        var colorAudio = new Color(255 / 255f, 126 / 255f, 0f);        DrawRectIcon(selectionRect,HierarchyIcon,ref index);        DrawRectIcon&lt;MeshRenderer&gt;(selectionRect, go, colorMesh, ref index, ref style);        DrawRectIcon&lt;SkinnedMeshRenderer&gt;(selectionRect, go, colorSkinMesh, ref index, ref style);        // Colliders        DrawRectIcon&lt;BoxCollider&gt;(selectionRect, go, colorCollider, ref index, ref style);        DrawRectIcon&lt;SphereCollider&gt;(selectionRect, go, colorCollider, ref index, ref style);        DrawRectIcon&lt;CapsuleCollider&gt;(selectionRect, go, colorCollider, ref index, ref style);        DrawRectIcon&lt;MeshCollider&gt;(selectionRect, go, colorCollider, ref index, ref style);        DrawRectIcon&lt;CharacterController&gt;(selectionRect, go, colorCollider, ref index, ref style);        // RigidBody        DrawRectIcon&lt;Rigidbody&gt;(selectionRect, go, colorPhysic, ref index, ref style);        // Lights        DrawRectIcon&lt;Light&gt;(selectionRect, go, colorLight, ref index, ref style);        // Joints        // Animation / Animator        DrawRectIcon&lt;Animator&gt;(selectionRect, go, colorAnimation, ref index, ref style);        DrawRectIcon&lt;Animation&gt;(selectionRect, go, colorAnimation, ref index, ref style);        // Camera / Projector        DrawRectIcon&lt;Camera&gt;(selectionRect, go, colorCamera, ref index, ref style);        DrawRectIcon&lt;Projector&gt;(selectionRect, go, colorCamera, ref index, ref style);        // NavAgent        DrawRectIcon&lt;UnityEngine.AI.NavMeshAgent&gt;(selectionRect, go, colorNav, ref index, ref style);        DrawRectIcon&lt;UnityEngine.AI.NavMeshObstacle&gt;(selectionRect, go, colorNav, ref index, ref style);        // Network        DrawRectIcon&lt;NetworkIdentity&gt;(selectionRect, go, colorNetwork, ref index, ref style);        DrawRectIcon&lt;NetworkAnimator&gt;(selectionRect, go, colorNetwork, ref index, ref style);        DrawRectIcon&lt;NetworkTransform&gt;(selectionRect, go, colorNetwork, ref index, ref style);        DrawRectIcon&lt;NetworkBehaviour&gt;(selectionRect, go, colorNetwork, ref index, ref style);        DrawRectIcon&lt;NetworkManager&gt;(selectionRect, go, colorNetwork, ref index, ref style);        // Particle        DrawRectIcon&lt;ParticleSystem&gt;(selectionRect, go, colorParticle, ref index, ref style);        // Audio        DrawRectIcon&lt;AudioSource&gt;(selectionRect, go, colorAudio, ref index, ref style);        DrawRectIcon&lt;AudioReverbZone&gt;(selectionRect, go, colorAudio, ref index, ref style);        //UI        DrawRectIcon&lt;Image&gt;(selectionRect, go, colorParticle, ref index, ref style);        DrawRectIcon&lt;Text&gt;(selectionRect, go, colorParticle, ref index, ref style);        DrawRectIcon&lt;SpriteRenderer&gt;(selectionRect, go, colorParticle, ref index, ref style);        // 绘制Label来覆盖原有的名字        if (style != null &amp;&amp; go.activeInHierarchy)        {            GUI.Label(selectionRect, go.name, style);        }    }    private static void Update()    {        Debug.Log(&quot;1&quot;);    }    private static Rect GetRect(Rect selectionRect , int index)    {        Rect rect = new Rect(selectionRect);        rect.x += rect.width - 20 - (20 * index);        rect.width = 18;        return rect;    }    /// &lt;summary&gt;    /// 绘制一个Unity原声图标    /// &lt;/summary&gt;    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;    /// &lt;param name=&quot;rect&quot;&gt;&lt;/param&gt;    private static void DrawIcon&lt;T&gt;(Rect rect)    {        var icon = EditorGUIUtility.ObjectContent(null, typeof(T)).image;        GUI.Label(rect, icon);    }    private static void DrawRectIcon&lt;T&gt;(Rect selectionRect,GameObject go,Color textColor,ref int order, ref GUIStyle style)where T :Component    {        if (go.HasComponent&lt;T&gt;())        {            order += 1;            var rect = GetRect(selectionRect, order);            DrawIcon&lt;T&gt;(rect);        }    }    private static void DrawRectIcon(Rect selectionRect,Texture2D texture,ref int order)    {        order += 1;        var rect = GetRect(selectionRect,order);        GUI.Label(rect,texture);    }}public static class ExtensionMethods{    public static bool HasComponent&lt;T&gt;(this GameObject go) where T : Component    {        return go.GetComponent&lt;T&gt;() != null;    }}</code></pre><p>其中使用了[InitializeOnLoad]，这个Attribute的意思是在启动Unity的时候运行的编辑器脚本，该类需要一个静态的构造函数。。</p><p>通过EditorGUIUtility.ObjectContent(null,<br>typeof(T)).image就可以获取到T类型的Unity原声Texture了。<br>而Label和Toggle，则分别使用GUI.Label和GUI.Toggle即可。。具体参见上面代码。</p><p>我们可以根据需要定制自己需要的Hierarchy面板，例如上述代码中通过判断该GameObject是否是static的，如果是，则绘制一个S在旁边，这样就可以很快速的查看哪些物体是static的了。。</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之二：ReorderableList可重新排序的列表框（复杂使用）</title>
      <link href="/2017/09/02/unity-bian-ji-qi-tuo-zhan-zhi-er-reorderablelist-ke-chong-xin-pai-xu-de-lie-biao-kuang-fu-za-shi-yong/"/>
      <url>/2017/09/02/unity-bian-ji-qi-tuo-zhan-zhi-er-reorderablelist-ke-chong-xin-pai-xu-de-lie-biao-kuang-fu-za-shi-yong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>先看效果gif图：<br><img src="https://img-blog.csdn.net/20170902160043794?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>如果没有看过Unity编辑器拓展之一：ReorderableList可重新排序的列表框（简单使用）的，可以先看这一篇：<br><a href="http://blog.csdn.net/qq_26999509/article/details/77782177" target="_blank" rel="noopener"> http://blog.csdn.net/qq_26999509/article/details/77782177</a></p><p>在此基础上，来绘制更加复杂的类</p><p>先提供一个需要绘制的类</p><pre><code>using UnityEngine;using System.Collections;using System.Collections.Generic;using System;public class CharacterTest : MonoBehaviour {    public List&lt;Character&gt; characters = new List&lt;Character&gt;();    // Use this for initialization    void Start ()     {    }    // Update is called once per frame    void Update ()     {    }}[Serializable]public class Character{    [SerializeField]    Texture icon;    [SerializeField]    string name;    [SerializeField]    int hp;    [SerializeField]    int power;    [SerializeField]    GameObject weapon;}</code></pre><p>然后跟上一篇一样，通过使用ReorderableList绘制List</p><pre><code>using UnityEngine;using System.Collections;using UnityEditor;using UnityEditorInternal;[CustomEditor(typeof(CharacterTest))]public class CharacterInspector : Editor {    ReorderableList reorderableList;    void OnEnable()    {        SerializedProperty prop = serializedObject.FindProperty(&quot;characters&quot;);        reorderableList = new ReorderableList(serializedObject, prop, true, true, true, true);        //设置单个元素的高度        reorderableList.elementHeight = 80;        //绘制单个元素        reorderableList.drawElementCallback =            (rect, index, isActive, isFocused) =&gt; {                var element = prop.GetArrayElementAtIndex(index);                rect.height -= 4;                rect.y += 2;                EditorGUI.PropertyField(rect, element);            };        //背景色        reorderableList.drawElementBackgroundCallback = (rect, index, isActive, isFocused) =&gt; {            GUI.backgroundColor = Color.yellow;        };        //头部        reorderableList.drawHeaderCallback = (rect) =&gt;            EditorGUI.LabelField(rect, prop.displayName);    }    public override void OnInspectorGUI()    {        serializedObject.Update();        reorderableList.DoLayoutList();        serializedObject.ApplyModifiedProperties();    }}</code></pre><p>目前的效果如下图：</p><p><img src="https://img-blog.csdn.net/20170902160317066?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>最后还需要利用PropertyDrawer来绘制单个Serializable类的每个实例的GUI，也就是Character类</p><pre><code>using UnityEngine;using System.Collections;using UnityEditor;//定制Serializable类的每个实例的GUI[CustomPropertyDrawer(typeof(Character))]public class CharacterDrawer : PropertyDrawer {    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)    {        //创建一个属性包装器，用于将常规GUI控件与SerializedProperty一起使用        using (new EditorGUI.PropertyScope(position, label, property))        {            //设置属性名宽度 Name HP            EditorGUIUtility.labelWidth = 60;            //输入框高度，默认一行的高度            position.height = EditorGUIUtility.singleLineHeight;            //ico 位置矩形            Rect iconRect = new Rect(position)            {                width = 68,                height = 68            };            Rect nameRect = new Rect(position)            {                width = position.width - 70,    //减去icon的width 64                x = position.x + 70             //在icon的基础上右移64            };            Rect hpRect = new Rect(nameRect)            {                //在name的基础上，y坐标下移                y = nameRect.y + EditorGUIUtility.singleLineHeight + 2            };            Rect powerRect = new Rect(hpRect)            {                //在hp的基础上，y坐标下移                y = hpRect.y + EditorGUIUtility.singleLineHeight + 2            };            Rect weaponLabelRect = new Rect(powerRect)            {                y = powerRect.y + EditorGUIUtility.singleLineHeight + 2,                width = 60            };            Rect weaponRect = new Rect(weaponLabelRect)            {                x = weaponLabelRect.x + 60,                width = powerRect.width - 60            };            //找到每个属性的序列化值            SerializedProperty iconProperty = property.FindPropertyRelative(&quot;icon&quot;);            SerializedProperty nameProperty = property.FindPropertyRelative(&quot;name&quot;);            SerializedProperty hpProperty = property.FindPropertyRelative(&quot;hp&quot;);            SerializedProperty powerProperty = property.FindPropertyRelative(&quot;power&quot;);            SerializedProperty weaponProperty = property.FindPropertyRelative(&quot;weapon&quot;);            //绘制icon            iconProperty.objectReferenceValue = EditorGUI.ObjectField(iconRect, iconProperty.objectReferenceValue, typeof(Texture), false);            //绘制name            nameProperty.stringValue = EditorGUI.TextField(nameRect, nameProperty.displayName, nameProperty.stringValue);            //Slider，范围在0-100            EditorGUI.IntSlider(hpRect, hpProperty, 0, 100);            //Slider，范围在0-10            EditorGUI.IntSlider(powerRect, powerProperty, 0, 10);            EditorGUI.PrefixLabel(weaponLabelRect, new GUIContent(&quot;weapon&quot;));            EditorGUI.PropertyField(weaponRect, weaponProperty, GUIContent.none);        }    }}</code></pre><p>最后效果就是文章一开始的gif图了</p><p>示例工程链接：<br>链接： <a href="http://pan.baidu.com/s/1cgyZ98" target="_blank" rel="noopener"> http://pan.baidu.com/s/1cgyZ98 </a> 密码：jbzh</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity编辑器拓展之一：ReorderableList可重新排序的列表框（简单使用）</title>
      <link href="/2017/09/01/unity-bian-ji-qi-tuo-zhan-zhi-yi-reorderablelist-ke-chong-xin-pai-xu-de-lie-biao-kuang-jian-dan-shi-yong/"/>
      <url>/2017/09/01/unity-bian-ji-qi-tuo-zhan-zhi-yi-reorderablelist-ke-chong-xin-pai-xu-de-lie-biao-kuang-jian-dan-shi-yong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="可重新排序的列表框"><a href="#可重新排序的列表框" class="headerlink" title="可重新排序的列表框"></a>可重新排序的列表框</h1><p>先看效果图：<br><img src="https://img-blog.csdn.net/20170901231522594?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>UnityEditorInternal命名空间下提供 一个类ReorderableList可以实现通过拖曳来达到列表元素的重新排序。</p><p>基本使用：<br>名称 描述<br>draggable 拖曳排序<br>displayAdd 显示添加按钮<br>displayRemove 显示移除按钮<br>elementHeight 元素高度<br>headerHeight 表头高度<br>footerHeight 尾部高度<br>showDefaultBackground 显示默认背景<br>drawHeaderCallback 绘制表头回调<br>drawFooterCallback 绘制尾部回调<br>drawElementCallback 绘制元素回调<br>drawElementBackgroundCallback 绘制元素背景回调<br>onReorderCallback 重新排序回调<br>onSelectCallback 选中回调<br>onAddCallback 添加按钮回调<br>onAddDropdownCallback 添加下拉选项回调<br>onRemoveCallback 移除元素回调<br>onMouseUpCallback 鼠标抬起回调<br>onCanRemoveCallback 是否显示可移除按钮回调<br>onChangedCallback 列表改变回调</p><p>示例代码如下：<br>先创建一个脚本：TestList</p><pre><code>using UnityEngine;using System.Collections;using System.Collections.Generic;public class TestList : MonoBehaviour {    public List&lt;Color&gt; m_colors = new List&lt;Color&gt;();    private void Start()    {    }}</code></pre><p>上述代码中有一个List类型的变量，接下来使用一个继承自Editor脚本实现主要逻辑</p><pre><code>using UnityEngine;using System.Collections;using UnityEditor;using UnityEditorInternal;using System;[CustomEditor(typeof(TestList))]public class TestListEditor : Editor {    private ReorderableList m_colors;    private void OnEnable()    {        m_colors = new ReorderableList(serializedObject, serializedObject.FindProperty(&quot;m_colors&quot;), true, true, true, true);        //绘制元素        m_colors.drawElementCallback = (Rect rect, int index, bool selected, bool focused) =&gt;        {            SerializedProperty itemData = m_colors.serializedProperty.GetArrayElementAtIndex(index);            rect.y += 2;            rect.height = EditorGUIUtility.singleLineHeight;            EditorGUI.PropertyField(rect, itemData, GUIContent.none);        };        //绘制表头        m_colors.drawHeaderCallback = (Rect rect) =&gt;        {            GUI.Label(rect, &quot;Colors&quot;);        };        //当移除元素时回调        m_colors.onRemoveCallback = (ReorderableList list) =&gt;        {            //弹出一个对话框            if (EditorUtility.DisplayDialog(&quot;警告&quot;,&quot;是否确定删除该颜色&quot;,&quot;是&quot;,&quot;否&quot;))            {                //当点击“是”                ReorderableList.defaultBehaviours.DoRemoveButton(list);            }        };        //添加按钮回调        m_colors.onAddCallback = (ReorderableList list) =&gt;        {            if (list.serializedProperty != null)            {                list.serializedProperty.arraySize++;                list.index = list.serializedProperty.arraySize - 1;                SerializedProperty itemData = list.serializedProperty.GetArrayElementAtIndex(list.index);                itemData.colorValue = Color.red;            }            else            {                ReorderableList.defaultBehaviours.DoAddButton(list);            }        };        //鼠标抬起回调        m_colors.onMouseUpCallback = (ReorderableList list) =&gt;        {            Debug.Log(&quot;MouseUP&quot;);        };        //当选择元素回调        m_colors.onSelectCallback = (ReorderableList list) =&gt;        {            //打印选中元素的索引            Debug.Log(list.index);        };    }    public override void OnInspectorGUI()    {        EditorGUILayout.Space();        serializedObject.Update();        m_colors.DoLayoutList();        serializedObject.ApplyModifiedProperties();    }}</code></pre><p>结果就如之前的图中显示所示。</p><p>其中OnInspectorGUI函数中，删除了base.OnInspectorGUI();<br>不然的话，效果如下图：<br><img src="https://img-blog.csdn.net/20170901232457862?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>可以看出，colors绘制了两遍。</p><p>示例工程链接：<br>链接： <a href="http://pan.baidu.com/s/1o7Tjslc" target="_blank" rel="noopener"> http://pan.baidu.com/s/1o7Tjslc </a><br>密码：pgri</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步</p>]]></content>
      
      
      <categories>
          
          <category> Unity编辑器拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity之图片轮播组件实现</title>
      <link href="/2017/08/20/unity-zhi-tu-pian-lun-bo-zu-jian-shi-xian/"/>
      <url>/2017/08/20/unity-zhi-tu-pian-lun-bo-zu-jian-shi-xian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>游戏中有时候会见到图片轮播的效果，那么这里就自己封装了一个，包括自动轮播、切页按钮控制、页码下标更新、滑动轮播、切页后的回调等等<br>下面，先上一个简陋的gif动态效果图</p><p><img src="https://img-blog.csdn.net/20170820225254127?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>从图中可以看出，该示例包括了三张图片的轮播，左右分别是上一张和下一张的按钮，右下角显示了当前是第几章的页码下标。</p><p>直接上脚本：</p><pre><code>using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Events;using UnityEngine.EventSystems;using UnityEngine.UI;namespace UnityEngine.UI{    [AddComponentMenu(&quot;UI/Slidershow&quot;, 39)]          //添加菜单    [ExecuteInEditMode]                             //编辑模式下可执行    [DisallowMultipleComponent]                     //不可重复    [RequireComponent(typeof(RectTransform))]       //依赖于RectTransform组件    public class Slideshow : UIBehaviour,IPointerDownHandler,IPointerUpHandler    {        public enum MovementType        {            /// &lt;summary&gt;            /// 循环            /// &lt;/summary&gt;            Circulation,        //循环，轮播到最后一页之后，直接回到第一页            /// &lt;summary&gt;            /// 来回往复            /// &lt;/summary&gt;            PingPong,           //来回往复，轮播到最后一页之后，倒序轮播，到第一页之后，同理        }        public enum MoveDir        {            Left,            Right,        }        [SerializeField]        private MovementType m_movement = MovementType.Circulation;        public MovementType Movement { get { return m_movement; } set { m_movement = value; } }        [SerializeField]        private RectTransform m_content;        public RectTransform Content { get { return m_content; } set { m_content = value; } }        [SerializeField]        private Button m_lastPageButton;        public Button LastPageButton { get { return m_lastPageButton; } set { m_lastPageButton = value; } }        [SerializeField]        private Button m_nextPageButton;        public Button NextPageButton { get { return m_nextPageButton; } set { m_nextPageButton = value; } }        /// &lt;summary&gt;        /// 自动轮播时长        /// &lt;/summary&gt;        [SerializeField]        private float m_showTime = 2.0f;        public float ShowTime { get { return m_showTime; } set { m_showTime = value; } }        /// &lt;summary&gt;        /// 是否自动轮播        /// &lt;/summary&gt;        [SerializeField]        private bool m_autoSlide = false;        public bool AutoSlide { get { return m_autoSlide; }set { m_autoSlide = value; } }        /// &lt;summary&gt;        /// 自动轮播方向，-1表示向左，1表示向右        /// &lt;/summary&gt;        private MoveDir m_autoSlideDir = MoveDir.Right;        /// &lt;summary&gt;        /// 是否允许拖动切页        /// &lt;/summary&gt;        [SerializeField]        private bool m_allowDrag = true;        public bool AllowDrag { get { return m_allowDrag; }set { m_allowDrag = value; } }        /// &lt;summary&gt;        /// 当前显示页的页码，下标从0开始        /// &lt;/summary&gt;        private int m_curPageIndex = 0;        public int CurPageIndex { get { return m_curPageIndex; } }        /// &lt;summary&gt;        /// 最大页码        /// &lt;/summary&gt;        private int m_maxPageIndex = 0;        public int MaxPageIndex { get { return m_maxPageIndex; } }        /// &lt;summary&gt;        /// 圆圈页码ToggleGroup        /// &lt;/summary&gt;        [SerializeField]        private ToggleGroup m_pageToggleGroup;        public ToggleGroup PageToggleGroup { get { return m_pageToggleGroup; } set { m_pageToggleGroup = value; } }        /// &lt;summary&gt;        /// 圆圈页码Toggle List        /// &lt;/summary&gt;        private List&lt;Toggle&gt; m_pageToggleList;        public List&lt;Toggle&gt; PageToggleLise { get { return m_pageToggleList; }}        //item数目        private int m_itemNum = 0;        public int ItemNum { get { return m_itemNum; } }        //以Toggle为Key，返回页码        private Dictionary&lt;Toggle, int&gt; m_togglePageNumDic = null;        private float m_time = 0f;        private List&lt;float&gt; m_childItemPos = new List&lt;float&gt;();        private GridLayoutGroup m_grid = null;        protected override void Awake()        {            base.Awake();            if (null == m_content)            {                throw new Exception(&quot;Slideshow content is null&quot;);            }            else            {                m_grid = m_content.GetComponent&lt;GridLayoutGroup&gt;();                if (m_grid == null)                {                    throw new Exception(&quot;Slideshow content is miss GridLayoutGroup Component&quot;);                }                InitChildItemPos();            }            if (null != m_lastPageButton)            {                m_lastPageButton.onClick.AddListener(OnLastPageButtonClick);            }            if (null != m_nextPageButton)            {                m_nextPageButton.onClick.AddListener(OnNextPageButtonClick);            }            if (null != m_pageToggleGroup)            {                int toggleNum = m_pageToggleGroup.transform.childCount;                if (toggleNum &gt; 0)                {                    m_pageToggleList = new List&lt;Toggle&gt;();                    m_togglePageNumDic = new Dictionary&lt;Toggle, int&gt;();                    for (int i = 0; i &lt; toggleNum; i++)                    {                        Toggle childToggle = m_pageToggleGroup.transform.GetChild(i).GetComponent&lt;Toggle&gt;();                        if (null != childToggle)                        {                            m_pageToggleList.Add(childToggle);                            m_togglePageNumDic.Add(childToggle, i);                            childToggle.onValueChanged.AddListener(OnPageToggleValueChanged);                        }                    }                    m_itemNum = m_pageToggleList.Count;                    m_maxPageIndex = m_pageToggleList.Count - 1;                }            }            UpdateCutPageButtonActive(m_curPageIndex);        }        private void InitChildItemPos()        {            int childCount = m_content.transform.childCount;            float cellSizeX = m_grid.cellSize.x;            float spacingX = m_grid.spacing.x;            float posX = -cellSizeX * 0.5f;            m_childItemPos.Add(posX);            for (int i = 1; i &lt; childCount; i++)            {                posX -= cellSizeX + spacingX;                m_childItemPos.Add(posX);            }        }        private void OnPageToggleValueChanged(bool ison)        {            if (ison)            {                Toggle activeToggle = GetActivePageToggle();                if (m_togglePageNumDic.ContainsKey(activeToggle))                {                    int page = m_togglePageNumDic[activeToggle];                    SwitchToPageNum(page);                }            }        }        private Toggle GetActivePageToggle()        {            if (m_pageToggleGroup == null || m_pageToggleList == null || m_pageToggleList.Count &lt;= 0)            {                return null;            }            for (int i = 0; i &lt; m_pageToggleList.Count; i++)            {                if (m_pageToggleList[i].isOn)                {                    return m_pageToggleList[i];                }            }            return null;        }        /// &lt;summary&gt;        /// 切换至某页        /// &lt;/summary&gt;        /// &lt;param name=&quot;pageNum&quot;&gt;页码&lt;/param&gt;        private void SwitchToPageNum(int pageNum)        {            if (pageNum &lt; 0 || pageNum &gt; m_maxPageIndex)            {                throw new Exception(&quot;page num is error&quot;);            }            if (pageNum == m_curPageIndex)            {                //目标页与当前页是同一页                return;            }            m_curPageIndex = pageNum;            if (m_movement == MovementType.PingPong)            {                UpdateCutPageButtonActive(m_curPageIndex);            }            Vector3 pos = m_content.localPosition;            m_content.localPosition = new Vector3(m_childItemPos[m_curPageIndex], pos.y, pos.z);            m_pageToggleList[m_curPageIndex].isOn = true;            if (m_onValueChanged != null)            {                //执行回调                m_onValueChanged.Invoke(m_pageToggleList[m_curPageIndex].gameObject);            }        }        /// &lt;summary&gt;        /// 根据页码更新切页按钮active        /// &lt;/summary&gt;        /// &lt;param name=&quot;pageNum&quot;&gt;&lt;/param&gt;        private void UpdateCutPageButtonActive(int pageNum)        {            if (pageNum == 0)            {                UpdateLastButtonActive(false);                UpdateNextButtonActive(true);            }            else if (pageNum == m_maxPageIndex)            {                UpdateLastButtonActive(true);                UpdateNextButtonActive(false);            }            else            {                UpdateLastButtonActive(true);                UpdateNextButtonActive(true);            }        }        private void OnNextPageButtonClick()        {            m_time = Time.time;     //重新计时            switch (m_movement)            {                case MovementType.Circulation:                    SwitchToPageNum((m_curPageIndex + 1) % m_itemNum);                    break;                case MovementType.PingPong:                    //该模式下，会自动隐藏切页按钮                    SwitchToPageNum(m_curPageIndex + 1);                    break;                default:                    break;            }            Debug.Log(m_content.localPosition);        }        private void OnLastPageButtonClick()        {            m_time = Time.time; //重新计时            switch (m_movement)            {                case MovementType.Circulation:                    SwitchToPageNum((m_curPageIndex + m_itemNum - 1) % m_itemNum);                    break;                case MovementType.PingPong:                    //该模式下，会自动隐藏切页按钮                    SwitchToPageNum(m_curPageIndex - 1);                    break;                default:                    break;            }        }        private void UpdateLastButtonActive(bool activeSelf)        {            if (null == m_lastPageButton)            {                throw new Exception(&quot;Last Page Button is null&quot;);            }            bool curActive = m_lastPageButton.gameObject.activeSelf;            if (curActive != activeSelf)            {                m_lastPageButton.gameObject.SetActive(activeSelf);            }        }        private void UpdateNextButtonActive(bool activeSelf)        {            if (null == m_nextPageButton)            {                throw new Exception(&quot;Next Page Button is null&quot;);            }            bool curActive = m_nextPageButton.gameObject.activeSelf;            if (curActive != activeSelf)            {                m_nextPageButton.gameObject.SetActive(activeSelf);            }        }        private Vector3 m_originDragPos = Vector3.zero;        private Vector3 m_desDragPos = Vector3.zero;        private bool m_isDrag = false;        public void OnPointerDown(PointerEventData eventData)        {            if (!m_allowDrag)            {                return;            }            if (eventData.button != PointerEventData.InputButton.Left)            {                return;            }            if (!IsActive())            {                return;            }            m_isDrag = true;            m_originDragPos = eventData.position;        }        public void OnPointerUp(PointerEventData eventData)        {            m_desDragPos = eventData.position;            MoveDir dir = MoveDir.Right;            if (m_desDragPos.x &lt; m_originDragPos.x)            {                dir = MoveDir.Left;            }            switch (dir)            {                case MoveDir.Left:                    if (m_movement == MovementType.Circulation || (m_movement == MovementType.PingPong &amp;&amp; m_curPageIndex != 0))                    {                        OnLastPageButtonClick();                    }                    break;                case MoveDir.Right:                    if (m_movement == MovementType.Circulation || (m_movement == MovementType.PingPong &amp;&amp; m_curPageIndex != m_maxPageIndex))                    {                        OnNextPageButtonClick();                    }                    break;            }            m_isDrag = false;        }        /// &lt;summary&gt;        /// 切页后回调函数        /// &lt;/summary&gt;        [Serializable]        public class SlideshowEvent : UnityEvent&lt;GameObject&gt; { }        [SerializeField]        private SlideshowEvent m_onValueChanged = new SlideshowEvent();        public SlideshowEvent OnValueChanged { get { return m_onValueChanged; } set { m_onValueChanged = value; } }        public override bool IsActive()        {            return base.IsActive() &amp;&amp; m_content != null;        }        private void Update()        {            if (m_autoSlide &amp;&amp; !m_isDrag)            {                if (Time.time &gt; m_time + m_showTime)                {                    m_time = Time.time;                    switch (m_movement)                    {                        case MovementType.Circulation:                            m_autoSlideDir = MoveDir.Right;                            break;                        case MovementType.PingPong:                            if (m_curPageIndex == 0)                            {                                m_autoSlideDir = MoveDir.Right;                            }                            else if (m_curPageIndex == m_maxPageIndex)                            {                                m_autoSlideDir = MoveDir.Left;                            }                            break;                    }                    switch (m_autoSlideDir)                    {                        case MoveDir.Left:                            OnLastPageButtonClick();                            break;                        case MoveDir.Right:                            OnNextPageButtonClick();                            break;                    }                }            }        }    }}</code></pre><p>这里提供了一个枚举MovementType，该枚举定义了两种循环方式，其中Circulation循环，是指轮播到最后一页之后，直接回到第一页；而PingPong相信大家你熟悉了，就是来回往复的。</p><p>其中还提供了对每张图显示的时长进行设置，还有是否允许自动轮播的控制，是否允许拖动切页控制，等等。。其实将图片作为轮播子元素只是其中之一而已，完全可以将ScrollRect作为轮播子元素，这样每个子元素又可以滑动阅览了。。</p><p>这里还提供了两个编辑器脚本，一个是SlideshowEditor（依赖Slideshow组件），另一个是给用户提供菜单用的CreateSlideshow，代码分别如下：</p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEditor;using UnityEngine;using UnityEngine.EventSystems;using UnityEngine.UI;public class CreateSlideshow : Editor{    private static GameObject m_slideshowPrefab = null;    private static GameObject m_canvas = null;    [MenuItem(&quot;GameObject/UI/Slideshow&quot;)]    static void CreateSlideshowUI(MenuCommand menuCommand)    {        if (null == m_slideshowPrefab)        {            m_slideshowPrefab = Resources.Load&lt;GameObject&gt;(&quot;Slideshow&quot;);            if (null == m_slideshowPrefab)            {                Debug.LogError(&quot;Prefab Slideshow is null&quot;);                return;            }        }        m_canvas = menuCommand.context as GameObject;        if (m_canvas == null || m_canvas.GetComponentInParent&lt;Canvas&gt;() == null)        {            m_canvas = GetOrCreateCanvasGameObject();        }        GameObject go = GameObject.Instantiate(m_slideshowPrefab, m_canvas.transform);        go.transform.localPosition = Vector3.zero;        go.name = &quot;Slideshow&quot;;        Selection.activeGameObject = go;    }    static public GameObject GetOrCreateCanvasGameObject()    {        GameObject selectedGo = Selection.activeGameObject;        Canvas canvas = (selectedGo != null) ? selectedGo.GetComponentInParent&lt;Canvas&gt;() : null;        if (canvas != null &amp;&amp; canvas.gameObject.activeInHierarchy)            return canvas.gameObject;        canvas = Object.FindObjectOfType(typeof(Canvas)) as Canvas;        if (canvas != null &amp;&amp; canvas.gameObject.activeInHierarchy)            return canvas.gameObject;        return CreateCanvas();    }    public static GameObject CreateCanvas()    {        var root = new GameObject(&quot;Canvas&quot;);        root.layer = LayerMask.NameToLayer(&quot;UI&quot;);        Canvas canvas = root.AddComponent&lt;Canvas&gt;();        canvas.renderMode = RenderMode.ScreenSpaceOverlay;        root.AddComponent&lt;CanvasScaler&gt;();        root.AddComponent&lt;GraphicRaycaster&gt;();        Undo.RegisterCreatedObjectUndo(root, &quot;Create &quot; + root.name);        CreateEventSystem();        return root;    }    public static void CreateEventSystem()    {        var esys = Object.FindObjectOfType&lt;EventSystem&gt;();        if (esys == null)        {            var eventSystem = new GameObject(&quot;EventSystem&quot;);            GameObjectUtility.SetParentAndAlign(eventSystem, null);            esys = eventSystem.AddComponent&lt;EventSystem&gt;();            eventSystem.AddComponent&lt;StandaloneInputModule&gt;();            Undo.RegisterCreatedObjectUndo(eventSystem, &quot;Create &quot; + eventSystem.name);        }    }}using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor.Advertisements;using UnityEngine.UI;namespace UnityEditor.UI{    [CustomEditor(typeof(Slideshow), true)]    public class SlideshowEditor : Editor    {        SerializedProperty m_movement;        SerializedProperty m_content;        SerializedProperty m_lastPageButton;        SerializedProperty m_nextPageButton;        SerializedProperty m_showTime;        SerializedProperty m_pageToggleGroup;        SerializedProperty m_onValueChanged;        SerializedProperty m_allowDrag;        SerializedProperty m_autoSlide;        protected virtual void OnEnable()        {            m_movement = serializedObject.FindProperty(&quot;m_movement&quot;);            m_content = serializedObject.FindProperty(&quot;m_content&quot;);            m_lastPageButton = serializedObject.FindProperty(&quot;m_lastPageButton&quot;);            m_nextPageButton = serializedObject.FindProperty(&quot;m_nextPageButton&quot;);            m_showTime = serializedObject.FindProperty(&quot;m_showTime&quot;);            m_pageToggleGroup = serializedObject.FindProperty(&quot;m_pageToggleGroup&quot;);            m_onValueChanged = serializedObject.FindProperty(&quot;m_onValueChanged&quot;);            m_allowDrag = serializedObject.FindProperty(&quot;m_allowDrag&quot;);            m_autoSlide = serializedObject.FindProperty(&quot;m_autoSlide&quot;);        }        public override void OnInspectorGUI()        {            serializedObject.Update();            EditorGUILayout.PropertyField(m_movement);            EditorGUILayout.PropertyField(m_content);            EditorGUILayout.PropertyField(m_lastPageButton);            EditorGUILayout.PropertyField(m_nextPageButton);            EditorGUILayout.PropertyField(m_allowDrag);            EditorGUILayout.PropertyField(m_autoSlide);            EditorGUILayout.PropertyField(m_showTime);            EditorGUILayout.PropertyField(m_pageToggleGroup);            EditorGUILayout.Space();            EditorGUILayout.PropertyField(m_onValueChanged);            //不加这句代码，在编辑模式下，无法将物体拖拽赋值            serializedObject.ApplyModifiedProperties();        }    }}</code></pre><p>这两个脚本中使用了一些拓展编辑器的知识，后续在另外写博客介绍<br>其中脚本CreateSlideshow中使用UGUI源码中的DefaultControls脚本里的方法，有兴趣可以去下载查阅。<br>Demo工程下载地址如下：<br>链接： <a href="http://pan.baidu.com/s/1i4Rralf" target="_blank" rel="noopener"> http://pan.baidu.com/s/1i4Rralf </a><br>密码：7loe<br>链接如有私有，请及时联系补充</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity之UGUI脚本自动生成</title>
      <link href="/2017/08/09/unity-zhi-ugui-jiao-ben-zi-dong-sheng-cheng/"/>
      <url>/2017/08/09/unity-zhi-ugui-jiao-ben-zi-dong-sheng-cheng/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>在做UI开发工作中，往往会有很多重复工作，比如用FindChild找可交互的ui呀，比如给这些ui加Listener等，那么这里提供一种思路，通过给UI中需要加交互事件的ui物体加上标记脚本，然后就可以根据这些标记得出相对于UIRoot的路径，得到路径就可以通过FindChild得到交互UI物体，然后给他们加上事件监听即可。</p><p>先定义一个枚举</p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;public enum UIType {    UIRoot,    Transform,    Image,    RawImage,    Button,    Toggle,    Slider,    Scrollbar,    Dropdown,    InputField,    ScrollRect,}</code></pre><p>然后上一个效果图来给UI物体加标记</p><p><img src="https://img-blog.csdn.net/20170809002217766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>从图中可以看出，加完标记之后，生成代码。<br>先看示例的UIDialog<br><img src="https://img-blog.csdn.net/20170809002336955?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>其中图中两一个Image，一个InputFiel，一个Button，一个Toggle<br>生成的代码如下：</p><pre><code>using UnityEngine;using UnityEngine.UI;using System;public class TestDialog : MonoBehaviour{    private Image m_Image = null;    private InputField m_UserNameInputField = null;    private Button m_CloseButton = null;    private Toggle m_SexToggle = null;    void Awake()    {        m_Image = transform.FindChild(&quot;Image&quot;).GetComponent&lt;Image&gt;();        m_UserNameInputField = transform.FindChild(&quot;Image/UserNameInputField&quot;).GetComponent&lt;InputField&gt;();        m_CloseButton = transform.FindChild(&quot;CloseButton&quot;).GetComponent&lt;Button&gt;();        m_SexToggle = transform.FindChild(&quot;SexToggle&quot;).GetComponent&lt;Toggle&gt;();    }    void Start()    {        InitUIEvent();    }    private void InitUIEvent()    {        m_UserNameInputField.onEndEdit.AddListener(OnUserNameInputFieldEndEdit);        m_CloseButton.onClick.AddListener(OnCloseButtonClick);        m_SexToggle.onValueChanged.AddListener(OnSexToggleValueChanged);    }    private void OnUserNameInputFieldEndEdit(string arg0)    {        throw new NotImplementedException();    }    private void OnCloseButtonClick()    {        throw new NotImplementedException();    }    private void OnSexToggleValueChanged(bool arg0)    {        throw new NotImplementedException();    }}</code></pre><p>生成代码的逻辑比较长，就不放出来了，原理就是按照规范拼StringBuilder，包括变量名前缀，函数名规范等，以及插入等长度的空格代替tab、还有换行使得代码对其等等。</p><h4 id="这个只是提供一种思路，Demo以及源码会放在下面，大家有兴趣可以参考一下，转载请注明原文地址。"><a href="#这个只是提供一种思路，Demo以及源码会放在下面，大家有兴趣可以参考一下，转载请注明原文地址。" class="headerlink" title="这个只是提供一种思路，Demo以及源码会放在下面，大家有兴趣可以参考一下，转载请注明原文地址。"></a><strong>这个只是提供一种思路，Demo以及源码会放在下面，大家有兴趣可以参考一下，转载请注明原文地址。</strong></h4><p>Demo源码下载地址：<br>链接： <a href="http://pan.baidu.com/s/1i4YbIML" target="_blank" rel="noopener"> http://pan.baidu.com/s/1i4YbIML </a><br>密码：uyg9</p><p>下载链接如有失效，请即时联系<br>以上知识分享，如有错误，欢迎指出，共同学习，共同进步</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity之简易定时器Timer</title>
      <link href="/2017/08/06/unity-zhi-jian-yi-ding-shi-qi-timer/"/>
      <url>/2017/08/06/unity-zhi-jian-yi-ding-shi-qi-timer/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>有时候我们会有这样的需求：几秒或者几帧之后做什么事，也就是一个定时器。这里我利用Time.realtimeSinceStartup实现了一个简单的秒钟定时器，当然还可以利用Time.frameCount实现一个帧计时器</p><p>上代码：</p><pre><code>using System;using System.Collections;using System.Collections.Generic;using UnityEngine;public class Timer {    private Timer()    {        m_timerTask = new List&lt;TimerTask&gt;();    }    private static Timer m_instance;    public static Timer Instance    {        get        {            if (m_instance == null)            {                m_instance = new Timer();            }            return m_instance;        }    }    public delegate void OnTimeStart();    private List&lt;TimerTask&gt; m_timerTask = null;    public class TimerTask    {        //public int Id;        public float RealTime;        public float Time;        //public bool IsLoop;        //public int LoopCount;        public OnTimeStart CallBack;    }    public void UpdateTimer()    {        for (int i = 0; i &lt; m_timerTask.Count; i++)        {            TimerTask t = m_timerTask[i];            if (t == null)            {                continue;            }            if (t.RealTime &lt; Time.realtimeSinceStartup)            {                if (null != t.CallBack)                {                    t.CallBack();                    m_timerTask.Remove(t);                }            }        }    }    public void AddTimerTask(float time, OnTimeStart callback)    {        if (null == callback)        {            return;        }        TimerTask t = new TimerTask();        t.Time = time;        t.RealTime = Time.realtimeSinceStartup + time;        t.CallBack = callback;        m_timerTask.Add(t);    }}</code></pre><p>上面的代码省略了是否循环、循环次数以及帧计时器，思路类似。<br>最后附上测试Demo下载地址：<br>链接： <a href="http://pan.baidu.com/s/1bp5xRSr" target="_blank" rel="noopener"> http://pan.baidu.com/s/1bp5xRSr </a><br>密码：y35i</p><p>下载链接如有失效，请即时联系<br>以上知识分享，如有错误，欢迎指出，共同学习，共同进步</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity之拓展Button：支持双击与长按</title>
      <link href="/2017/08/06/unity-zhi-tuo-zhan-button-zhi-chi-shuang-ji-yu-chang-an/"/>
      <url>/2017/08/06/unity-zhi-tuo-zhan-button-zhi-chi-shuang-ji-yu-chang-an/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>双击直接利用的eventData.clickCount实现，而长按则是在PointerDown的时候记录时间，然后在Update里判断时间即可，由于代码比较简单，直接上源码。</p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.EventSystems;using UnityEngine.UI;public class UIButton : Button {    protected UIButton()    {        m_onDoubleClick = new ButtonClickedEvent();        m_onLongPress = new ButtonClickedEvent();    }    private ButtonClickedEvent m_onLongPress;    public ButtonClickedEvent OnLongPress    {        get { return m_onLongPress; }        set { m_onLongPress = value; }    }    private ButtonClickedEvent m_onDoubleClick;    public ButtonClickedEvent OnDoubleClick    {        get { return m_onDoubleClick; }        set { m_onDoubleClick = value; }    }    private bool m_isStartPress = false;    private float m_curPointDownTime = 0f;    private float m_longPressTime = 1f;    private bool m_longPressTrigger = false;    void Update ()     {        if (m_isStartPress &amp;&amp; !m_longPressTrigger)        {            if (Time.time &gt; m_curPointDownTime + m_longPressTime)            {                m_longPressTrigger = true;                m_isStartPress = false;                if (m_onLongPress != null)                {                    m_onLongPress.Invoke();                }            }        }    }    public override void OnPointerDown(PointerEventData eventData)    {        base.OnPointerDown(eventData);        m_curPointDownTime = Time.time;        m_isStartPress = true;        m_longPressTrigger = false;    }    public override void OnPointerUp(PointerEventData eventData)    {        base.OnPointerUp(eventData);        m_isStartPress = false;        m_longPressTrigger = false;    }    public override void OnPointerExit(PointerEventData eventData)    {        base.OnPointerExit(eventData);        m_isStartPress = false;        m_longPressTrigger = false;    }    public override void OnPointerClick(PointerEventData eventData)    {        //base.OnPointerClick(eventData);        if (!m_longPressTrigger)        {            if (eventData.clickCount == 1)            {                onClick.Invoke();            }            else if (eventData.clickCount == 2)            {                if (m_onDoubleClick != null)                {                    m_onDoubleClick.Invoke();                }            }        }    }}</code></pre><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity之ScrollRect滑动居中</title>
      <link href="/2017/07/16/unity-zhi-scrollrect-hua-dong-ju-zhong/"/>
      <url>/2017/07/16/unity-zhi-scrollrect-hua-dong-ju-zhong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>先上效果图<br><img src="https://img-blog.csdn.net/20170716183336257?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>这里同时支持水平方向和垂直方向，同时ScrollRect支持使用GridLayoutGroup、HorizontalLayoutGroup、VerticalLayoutGroup三种LayoutGroup，不过水平方向的ScrollRect不支持VerticalLayoutGroup，垂直方向的ScrollRect不支持HorizontalLayoutGroup，当然也不存在这两种情况。</p><p>由于这里是通过对ScrollRect的content的localPosition做了插值移动，因此ScrollRect的中心点设置必须跟我这保持一致。</p><p>下面直接上代码：</p><pre><code>using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.EventSystems;using UnityEngine.UI;public enum ScrollDir{    Horizontal,    Vertical}public class ScrollRectCenter : MonoBehaviour , IEndDragHandler,IDragHandler,IBeginDragHandler{    public ScrollDir Dir = ScrollDir.Horizontal;    /// &lt;summary&gt;    /// 是否正在居中    /// &lt;/summary&gt;    private bool _isCentering = false;    /// &lt;summary&gt;    /// 居中过程移动速度    /// &lt;/summary&gt;    public float MoveToCenterSpeed = 10f;    private ScrollRect _scrollView;    private Transform _content;    private List&lt;float&gt; _childrenPos = new List&lt;float&gt;();    private float _targetPos;    /// &lt;summary&gt;    /// 当前中心child索引    /// &lt;/summary&gt;    private int _curCenterChildIndex = -1;    /// &lt;summary&gt;    /// 当前中心ChildItem    /// &lt;/summary&gt;    public GameObject CurCenterChildItem    {        get        {            GameObject centerChild = null;            if (_content != null &amp;&amp; _curCenterChildIndex &gt;= 0 &amp;&amp; _curCenterChildIndex &lt; _content.childCount)            {                centerChild = _content.GetChild(_curCenterChildIndex).gameObject;            }            return centerChild;        }    }    void Awake()    {        _scrollView = GetComponent&lt;ScrollRect&gt;();        if (_scrollView == null)        {            Debug.LogError(&quot;ScrollRect is null&quot;);            return;        }        _content = _scrollView.content;        LayoutGroup layoutGroup = null;        layoutGroup = _content.GetComponent&lt;LayoutGroup&gt;();        if (layoutGroup == null)        {            Debug.LogError(&quot;LayoutGroup component is null&quot;);        }        _scrollView.movementType = ScrollRect.MovementType.Unrestricted;        float spacing = 0f;        //根据dir计算坐标，Horizontal：存x，Vertical：存y        switch (Dir)        {            case ScrollDir.Horizontal:                if (layoutGroup is HorizontalLayoutGroup)                {                    float childPosX = _scrollView.GetComponent&lt;RectTransform&gt;().rect.width * 0.5f - GetChildItemWidth(0) * 0.5f;                    spacing = (layoutGroup as HorizontalLayoutGroup).spacing;                    _childrenPos.Add(childPosX);                    for (int i = 1; i &lt; _content.childCount; i++)                    {                        childPosX -= GetChildItemWidth(i) * 0.5f + GetChildItemWidth(i - 1) * 0.5f + spacing;                        _childrenPos.Add(childPosX);                    }                }                else if (layoutGroup is GridLayoutGroup)                {                    GridLayoutGroup grid = layoutGroup as GridLayoutGroup;                    float childPosX = _scrollView.GetComponent&lt;RectTransform&gt;().rect.width * 0.5f - grid.cellSize.x * 0.5f;                    _childrenPos.Add(childPosX);                    for (int i = 0; i &lt; _content.childCount - 1; i++)                    {                        childPosX -= grid.cellSize.x + grid.spacing.x;                        _childrenPos.Add(childPosX);                    }                }                else                {                    Debug.LogError(&quot;Horizontal ScrollView is using VerticalLayoutGroup&quot;);                }                break;            case ScrollDir.Vertical:                if (layoutGroup is VerticalLayoutGroup)                {                    float childPosY = -_scrollView.GetComponent&lt;RectTransform&gt;().rect.height * 0.5f + GetChildItemHeight(0) * 0.5f;                    spacing = (layoutGroup as VerticalLayoutGroup).spacing;                    _childrenPos.Add(childPosY);                    for (int i = 1; i &lt; _content.childCount; i++)                    {                        childPosY += GetChildItemHeight(i) * 0.5f + GetChildItemHeight(i - 1) * 0.5f + spacing;                        _childrenPos.Add(childPosY);                    }                }                else if (layoutGroup is GridLayoutGroup)                {                    GridLayoutGroup grid = layoutGroup as GridLayoutGroup;                    float childPosY = -_scrollView.GetComponent&lt;RectTransform&gt;().rect.height * 0.5f + grid.cellSize.y * 0.5f;                    _childrenPos.Add(childPosY);                    for (int i = 1; i &lt; _content.childCount; i++)                    {                        childPosY += grid.cellSize.y + grid.spacing.y;                        _childrenPos.Add(childPosY);                    }                }                else                {                    Debug.LogError(&quot;Vertical ScrollView is using HorizontalLayoutGroup&quot;);                }                break;        }    }    private float GetChildItemWidth(int index)    {        return (_content.GetChild(index) as RectTransform).sizeDelta.x;    }    private float GetChildItemHeight(int index)    {        return (_content.GetChild(index) as RectTransform).sizeDelta.y;    }    void Start ()     {    }    void Update ()     {        if (_isCentering)        {            Vector3 v = _content.localPosition;            switch (Dir)            {                case ScrollDir.Horizontal:                    v.x = Mathf.Lerp(_content.localPosition.x, _targetPos, MoveToCenterSpeed * Time.deltaTime);                    _content.localPosition = v;                    if (Math.Abs(_content.localPosition.x - _targetPos) &lt; 0.01f)                    {                        _isCentering = false;                    }                    break;                case ScrollDir.Vertical:                    v.y = Mathf.Lerp(_content.localPosition.y, _targetPos, MoveToCenterSpeed * Time.deltaTime);                    _content.localPosition = v;                    if (Math.Abs(_content.localPosition.y - _targetPos) &lt; 0.01f)                    {                        _isCentering = false;                    }                    break;            }        }    }    public void OnDrag(PointerEventData eventData)    {    }    public void OnEndDrag(PointerEventData eventData)    {        switch (Dir)        {            case ScrollDir.Horizontal:                _targetPos = FindClosestChildPos(_content.localPosition.x, out _curCenterChildIndex);                break;            case ScrollDir.Vertical:                _targetPos = FindClosestChildPos(_content.localPosition.y, out _curCenterChildIndex);                break;        }        _isCentering = true;    }    public void OnBeginDrag(PointerEventData eventData)    {        _isCentering = false;        _curCenterChildIndex = -1;    }    private float FindClosestChildPos(float currentPos, out int curCenterChildIndex)    {        float closest = 0;        float distance = Mathf.Infinity;        curCenterChildIndex = -1;        for (int i = 0; i &lt; _childrenPos.Count; i++)        {            float p = _childrenPos[i];            float d = Mathf.Abs(p - currentPos);            if (d &lt; distance)            {                distance = d;                closest = p;                curCenterChildIndex = i;            }        }        return closest;    }}</code></pre><p>最后附上Demo下载链接：<br>链接： <a href="http://pan.baidu.com/s/1pLoJcjL" target="_blank" rel="noopener"> http://pan.baidu.com/s/1pLoJcjL </a><br>密码：js7g<br>链接如果失效，请及时评论，及时更新</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity之粘贴板操作</title>
      <link href="/2017/07/15/unity-zhi-nian-tie-ban-cao-zuo/"/>
      <url>/2017/07/15/unity-zhi-nian-tie-ban-cao-zuo/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Unity之粘贴板操作"><a href="#Unity之粘贴板操作" class="headerlink" title="Unity之粘贴板操作"></a>Unity之粘贴板操作</h1><p>Untiy提供GUIUtility.systemCopyBuffer进行对粘贴板缓存数据存储与获取</p><p>官方解释为访问系统的粘贴板，可set，可get</p><p>上图<br><img src="https://img-blog.csdn.net/20170715113619738?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>附上官方文档地址：<br><a href="https://docs.unity3d.com/2017.2/Documentation/ScriptReference/GUIUtility-systemCopyBuffer.html" target="_blank" rel="noopener"> https://docs.unity3d.com/2017.2/Documentation/ScriptReference/GUIUtility-systemCopyBuffer.html</a></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity之简易任务队列TaskQueue</title>
      <link href="/2017/07/09/unity-zhi-jian-yi-ren-wu-dui-lie-taskqueue/"/>
      <url>/2017/07/09/unity-zhi-jian-yi-ren-wu-dui-lie-taskqueue/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h1><p>该功能包括两个类：Task任务类，TaskQueue任务队列类<br>其中TaskQueue负责：<br>1、开始任务<br>2、添加任务<br>3、清空任务<br>4、开始任务回调<br>5、完成队列中所有任务回调<br>6、下一个任务<br>7、当前任务进度<br>8、队列存储所有任务</p><p>其中Task类代码如下：</p><pre><code>using System;using System.Collections;using System.Collections.Generic;public class Task {    //任务名    private string m_TaskName;    public string TaskName    {        set        {            m_TaskName = value;        }        get        {            return m_TaskName;        }    }    //任务具体内容，外部传入    public Action Work;    public Task(Action work, string taskName = &quot;defaultTaskName&quot;)    {        this.Work = work;        this.m_TaskName = taskName;    }}</code></pre><p>TaskQueue类代码如下：</p><pre><code>using System;using System.Collections;using System.Collections.Generic;using UnityEngine;public class TaskQueue {    //构造函数    public TaskQueue()    {        m_TaskQueue = new Queue&lt;Task&gt;();        m_TasksNum = 0;    }    //1、添加任务    public void AddTask(Task task)    {        m_TaskQueue.Enqueue(task);    }    public void AddTask(Action work)    {        Task task = new Task(work);        m_TaskQueue.Enqueue(task);    }    //2、开始任务    public void Start()    {        //获取任务队列的总任务数        m_TasksNum = m_TaskQueue.Count;        if (OnStart != null)        {            OnStart();        }        NextTask();    }    //3、清空任务    public void Clear()    {        m_TaskQueue.Clear();        m_TasksNum = 0;    }    //4、开始任务回调    public Action OnStart = null;    //5、完成所有任务回调    public Action OnFinish = null;    //6、下一个任务    private void NextTask()    {        if (m_TaskQueue.Count &gt; 0)        {            Task task = m_TaskQueue.Dequeue();            task.Work();            NextTask();        }        else        {            if (OnFinish != null)            {                OnFinish();            }        }    }    //7、当前任务进度    public float TaskProcess    {        get        {            return 1 - m_TaskQueue.Count * 1.0f / m_TasksNum;        }    }    //8、任务队列总任务量    private int m_TasksNum = 0;    //9、任务队列    private Queue&lt;Task&gt; m_TaskQueue;}</code></pre><p>然后写一个test脚本挂在相机上，测试前面的代码：</p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;public class Test : MonoBehaviour {    void Start ()     {        TaskQueue taskQueue = new TaskQueue();        taskQueue.OnStart = () =&gt; { Debug.Log(&quot;OnStart&quot;); };        taskQueue.OnFinish = () =&gt; { Debug.Log(&quot;OnFinish&quot;); };        taskQueue.AddTask(Task1);        taskQueue.AddTask(Task2);        taskQueue.Start();    }    private void Task1()    {        Debug.Log(&quot;Task1&quot;);    }    private void Task2()    {        Debug.Log(&quot;Task2&quot;);    }}</code></pre><p>执行结果如下图：<br><img src="https://img-blog.csdn.net/20170709182839383?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>该任务队列写的比较简单，后期会拓展，敬请期待。</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity之NetworkReachability描述网络可达性选项。</title>
      <link href="/2017/07/06/unity-zhi-networkreachability-miao-shu-wang-luo-ke-da-xing-xuan-xiang/"/>
      <url>/2017/07/06/unity-zhi-networkreachability-miao-shu-wang-luo-ke-da-xing-xuan-xiang/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>Unity自带一个枚举NetworkReachability，用来描述网络可达性<br>NotReachable：网络无法访问<br>ReachableViaCarrierDataNetwork：通过运营商数据网络可以访问网络<br>ReachableViaLocalAreaNetwork：网络通过WIFI或电缆可达</p><p>附上Unity官方文档地址： <a href="https://docs.unity3d.com/ScriptReference/NetworkReachability.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/NetworkReachability.html</a></p><p>截图如下：<br><img src="https://img-blog.csdn.net/20170706125329699?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity之使用IOS 3DTouch功能</title>
      <link href="/2017/04/26/unity-zhi-shi-yong-ios-3dtouch-gong-neng/"/>
      <url>/2017/04/26/unity-zhi-shi-yong-ios-3dtouch-gong-neng/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>Unity工程在IOS平台使用3DTouch功能，提供了以下接口：<br>（1）Input.touchPressureSupported：是否支持3Dtouch，bool类型<br>（2）Touch.pressure：获取当前按压值，float类型<br>（3）Touch.maximumPossiblePressure：获取最大按压值，float类型</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity之DOTweenPath轨迹移动</title>
      <link href="/2017/04/26/unity-zhi-dotweenpath-gui-ji-yi-dong/"/>
      <url>/2017/04/26/unity-zhi-dotweenpath-gui-ji-yi-dong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>先简单介绍一下DOTweenPath。</p><p>先来看一下DOTweenPath组件的截图</p><p><img src="https://img-blog.csdn.net/20170426150708706?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>1、Scene View Commands<br>（1）SHIFT+CTRL：add a waypoint<br>加一个轨迹点<br>（2）SHIFT+ALT：remove a waypoint<br>移除一个轨迹点</p><p>2、INfo<br>（1）Path Length：轨迹长度</p><p>3、Tween Options<br>（1）AutoPlay：自动播放<br>（2）AutoKill：播放完自动销毁动画<br>（3）Duration：动画时长<br>SpeedBased：If selected ,the duration will count as units/degreex<br>second;如果被选上，该时间作为单位时间。</p><p>（4）Delay：延时<br>（5）Ease：这是一个枚举，可以理解为动画播放速率曲线<br><img src="https://img-blog.csdn.net/20170426152601405?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>相关网址：<br><a href="http://dotween.demigiant.com/documentation.php" target="_blank" rel="noopener"> http://dotween.demigiant.com/documentation.php</a><br>以及： <a href="http://robertpenner.com/easing/easing_demo.html" target="_blank" rel="noopener"> http://robertpenner.com/easing/easing_demo.html</a></p><p>（6）Loops：循环次数，动画循环播放的次数<br>-1：表示 一直循环<br>0：表示只播放一次<br>当该值&gt;1时，检视面板出现LoopType，顾名思义就是指循环类型：<br>Restart：重新开始，后面的动画循环播放会从起点重新开始；<br>Yoyo：来回播放<br>Incremental：增加的，后面的path移动动画会在上一次循环的终点的基础上进行播放</p><p>（7）ID：动画ID<br>（8）UpdateType：这个枚举有三个值，指更新类型<br>Normal：正常更新，Update()<br>Late：晚于更新，LateUpdate()<br>Fixed：固定更新，FixedUpdate()</p><p>4、Path Tween Options<br>（1）Path Type：轨迹线类型<br>Linear：线型的<br>Catmull Rom：曲线<br>（2）Close Path：封闭曲线，将起点和终点相连<br>（3）Lock Rotation：锁旋转，xyzw</p><p>5、Path Editor Options：轨迹编辑参数，就不介绍了</p><p>6、ResetPath：重置轨迹<br>7、Events：<br>（1）OnStart：开始时<br>（2）OnPlay：播放时<br>（3）OnUpdate：更新时<br>（4）OnStep：单步完成时<br>（5）OnComplete：完成时<br>（6）OnCreated：动画创建时<br>事件顺序为：OnCreated-&gt;OnStart-&gt;OnPlay-&gt;OnUpdate（一直执行，直到完成），动画过程中单步完成时执行OnStep，整个动画完成后执行OnComplete</p><p>8、WayPoints：移动轨迹点<br>其中右边的Copy to clipboard，将坐标复制至剪贴板<br><img src="https://img-blog.csdn.net/20170426160635797?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>加减按钮即指增加减少坐标点</p><p>以上便是对于DOTweenPath组件的一个基本介绍。</p><p>接下来，DOTween对于轨迹移动提供的接口：<br>（1）DOPath：<br><img src="https://img-blog.csdn.net/20170426162319897?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>（2）DOLocalPath<br><img src="https://img-blog.csdn.net/20170426162640305?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>以上两个函数的参数再上面已经介绍过，这里就不再重复说明了。</p><p>DOTween插件，大家请自行下载。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity之MessageBox</title>
      <link href="/2017/04/25/unity-zhi-messagebox/"/>
      <url>/2017/04/25/unity-zhi-messagebox/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>先上示意图：<br><img src="https://img-blog.csdn.net/20170425112628114?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>从图中可以看出，这是标准的MessageBox样式。我采用的是UGUI，中间是文字内容，下面包括确定取消两个按钮，右上角一个关闭按钮。</p><p>那么模仿MFC呢，我写了一个枚举如下：</p><pre><code>public enum MessageType{    Confirm,            //确定    Cancel,             //取消    ConfirmCancel,      //确定取消    Yes,                //是    No,                 //否    YesNO,              //是否}</code></pre><p>从上可以看出，这是在定义按钮的样式，举例：Confirm指仅包括确定按钮。</p><p>接下来，直接上挂在该UI上的脚本代码：</p><pre><code>using System;using UnityEngine;using UnityEngine.EventSystems;using UnityEngine.UI;public class MessageBoxDialog : MonoBehaviour{    public GameObject CancelButton = null;          //取消按钮    public GameObject ConfirmButton = null;         //确定按钮    public GameObject CloseButton = null;           //关闭按钮    public Text MessageText = null;                 //提示文字    public Text ConfirmText = null;                 //确定文字    public Text CancelText = null;                  //取消文字    public Action OnCloseEvent = null;    public Action OnConfirmEvent = null;    // Use this for initialization    void Start()    {        AddListener();    }    // Update is called once per frame    void Update()    {    }    private void AddListener()    {        if (CancelButton != null)        {            EventTriggerListener.Get(CancelButton).onClick = OnCancelButtonClicked;        }        if (ConfirmButton != null)        {            EventTriggerListener.Get(ConfirmButton).onClick = OnConfirmButtonClicked;        }    }    private void OnConfirmButtonClicked(GameObject go, BaseEventData eventData)    {        if (OnConfirmEvent != null)        {            OnConfirmEvent();        }        else        {            OnCloseButtonClicked(null, null);        }    }    private void OnCancelButtonClicked(GameObject go, BaseEventData eventData)    {        if (OnCloseEvent != null)        {            OnCloseEvent();        }        else        {            OnCloseButtonClicked(null, null);        }    }    private void OnCloseButtonClicked(GameObject go, BaseEventData eventData)    {        GameObject.DestroyImmediate(gameObject);    }    public void UpdateButton(MessageType type)    {        switch (type)        {            case MessageType.ConfirmCancel:                break;            case MessageType.Cancel:                ConfirmButton.SetActive(false);                break;            case MessageType.Confirm:                CancelButton.SetActive(false);                break;            case MessageType.No:                ConfirmButton.SetActive(false);                CancelText.text = &quot;否&quot;;                break;            case MessageType.Yes:                CancelButton.SetActive(false);                ConfirmText.text = &quot;是&quot;;                break;            case MessageType.YesNO:                ConfirmText.text = &quot;是&quot;;                CancelText.text = &quot;否&quot;;                break;        }    }}</code></pre><p>接下来是该篇文章的重点代码了，</p><pre><code>using System;using UnityEngine;public class MessageBox{    private static GameObject _messageBoxPrefab = null;    private static GameObject _messageBox = null;    private static string _messageBoxPrefabPath = &quot;UI/MessageBox&quot;;    public static void Show(string info, MessageType type = MessageType.ConfirmCancel, Action cancelCallback = null,        Action confirmCallback = null)    {        if (_messageBoxPrefab == null)        {            _messageBoxPrefab = Resources.Load(_messageBoxPrefabPath) as GameObject;        }        _messageBox = GameObject.Instantiate(_messageBoxPrefab) as GameObject;        MessageBoxDialog msgbox = _messageBox.GetComponent&lt;MessageBoxDialog&gt;();        msgbox.UpdateButton(type);        msgbox.OnConfirmEvent += confirmCallback;        msgbox.OnCloseEvent += cancelCallback;        msgbox.MessageText.text = info;        //以下是在自己的场景管理的基础上写的，既然这里还没讲到我的场景管理，就暂时用比较low的方法了        //GameObject uiRoot = ScenesManager.Instance.CurScene.UiRoot.gameObject;        //_messageBox.transform.SetParent(uiRoot.transform, false);        GameObject canvas = GameObject.Find(&quot;Canvas&quot;);        if(canvas != null)        {            _messageBox.transform.SetParent(canvas.transform, false);        }    }}</code></pre><p>该段代码中，大家应该注意到三点：<br>1、MessageBox的预制件路径，修改为自己的路径；<br>2、加载该预制件的方法，我用的是Resources.Load，这里并没有将我的资源管理介绍出来，所以就用的这个；<br>3、实例化该UI，给该UI赋父物体的时候，用的是比较low的方法，注释已经解释了。</p><p>接下来，就直接上工程了，大家 如有疑问，请留言。<br>链接： <a href="http://pan.baidu.com/s/1kVibxQJ" target="_blank" rel="noopener"> http://pan.baidu.com/s/1kVibxQJ </a><br>密码：45ql</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Lua</title>
      <link href="/2017/04/25/lua/"/>
      <url>/2017/04/25/lua/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>两个连字符（–）在Lua中表示开始一条注释</p><p>Lua定义一个计算阶乘的函数：<br>–定义一个阶乘函数<br>function fact(n)<br>if n == 0 then<br>return 1<br>else<br>return n * fact(n-1)<br>end<br>end</p><p>–打印<br>print(“Hello World”)</p><p>–读取一个数字<br>a = io.read(“*number”)</p><p>Lua执行的 每段代码，例如一个源代码文件或在交互模式中输入的一行代码，都称为一个“程序块”，一个程序块也就是一连串的语句或命令。</p><p>几条连续的Lua语句之间并不需要分隔符，但也可以使用分号来分割语句。<br>代码中的换行不起任何作用<br>a = 1 b=a*2 –有点难看，但是合法</p><p>程序块可以是任意大小</p><h2 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h2><p>Lua的标识符可以是任意字母、数字和下画线构成的字符串，但不能以数字开头</p><p>Lua的保留字：<br>and break do else elseif<br>end false for function if<br>in local nil not or<br>repeat return then true unitl<br>while</p><p>Lua 是有大小写之分的</p><p>Lua注释：<br>可以在任何地方以两个连字符（–）开始一个“行注释”，该注释一直延伸到一行的结尾。<br>Lua也提供了“块注释”，以“–[[”开始，直至“–]]”，如果块注释包含的“–]]”并非是注释结尾，例如下面的例子</p><pre><code>--[[function fact(n)    if n == 0 then        return 1    else        return n * fact(n - 1)    endend--]]print(&quot;enter a number:&quot;)            --打印a = io.read(&quot;*number&quot;)              --读取一个数字print(fact(a))--]]</code></pre><p>如果代码中的第一个“–]]”并非是想要的块注释结尾，那么就改为以下依然合法</p><pre><code>--[=[function fact(n)    if n == 0 then        return 1    else        return n * fact(n - 1)    endend--]]print(&quot;enter a number:&quot;)            --打印a = io.read(&quot;*number&quot;)              --读取一个数字print(fact(a))--]=]</code></pre><p>Lua全局变量：<br>全局变量不需要声明。只需要将一个值赋予一个全局变量就可以创建了。在Lua中，访问一个未初始化的变量不会引发错误，访问结果是一个特殊的值nil。</p><pre><code>print(a)        --nila=10print(a)        --10</code></pre><p>删除一个全局变量，只需要将其赋值为nil</p><p>Lua类型与值：<br>Lua是一种动态类型的语言。在语言中没有类型定义的语法，每个值都“携带”了它本身的类型信息。<br>在Lua中有8种基础类型：nil（空），boolean（布尔），number（数字），string（字符串），userdata（自定义类型），function（函数），thread（线程），table（表）。函数type可根据一个值返回其类型名称。</p><pre><code>print(type(&quot;Hello world&quot;))      --stringprint(type(10.4 * 3))           --numberprint(type(print))              --functionprint(type(type))               --functionprint(type(true))               --booleanprint(type(nil))                --nilprint(type(type(X)))            --string</code></pre><p>最后一行将永远返回“string”，而无关乎X这个值的内容，这是因为type函数总是返回一个字符串。</p><p>变量没有预定义的类型，任何变量都可以包含任何类型的值：</p><pre><code>print(type(a))          --nila = 10print(type(a))          --numbera = &quot;a string&quot;print(type(a))          --stringa = printa(type(a))              --function</code></pre><p>将一个变量用于不同类型，通常会导致代码混乱，但有时明智地使用这种特性会带来便利。</p><h2 id="nil（空）"><a href="#nil（空）" class="headerlink" title="nil（空）"></a>nil（空）</h2><p>nil是一种类型，只有一个值nil，它的主要功能是用于区别其他任何值。一个全局变量在第一次赋值前的默认值就是nil，将nil赋予一个全局变量等同于删除它。Lua将nil用于表示一种无效值的情况，也就是没有任何有效值的情况。</p><h2 id="boolean（布尔）"><a href="#boolean（布尔）" class="headerlink" title="boolean（布尔）"></a>boolean（布尔）</h2><p>boolean类型有两个可选值：false和true，在Lua中任何值都可以表示一个条件。Lua将false和nil视为假，其他值全为真，Lua在条件测试中，将数字零和空字符串也都视为真</p><h2 id="number（数字）"><a href="#number（数字）" class="headerlink" title="number（数字）"></a>number（数字）</h2><p>number类型用于表示双精度浮点数，支持科学计数法：0.3e12</p><h2 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h2><p>Lua中的字符串通常表示“一个字符序列”。可以将任意二进制数据存储到一个字符串中。Lua的字符串是不可变的值，不能直接修改字符串的某个字符，而是根据修改要求来创建一个新的字符串。</p><pre><code>a=&quot;Hello world&quot;b=string.gsub(a,&quot;world&quot;,&quot;lua&quot;)      --修改字符串的一部分c=string.gsub(a,&quot;o&quot;,&quot;c&quot;)print(a)                            --Hello worldprint(b)                            --Hello luaprint(c)                            --Hellc wcrld</code></pre><p>string的gsub函数修改所有匹配到的子串。<br>Lua的字符串和其他Lua对象一样，都是自动内存管理机制所管理的对象。以一对匹配的单引号或者双引号来界定字符串，根据编程风格，应该坚持在程序中使用相同类型的引号，如果字符串本身包含引号，那么使用转义序列</p><p>![这里写图片描述](<a href="https://img-" target="_blank" rel="noopener">https://img-</a><br>blog.csdn.net/20170313192419753?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)<br>Lua字符串中的转义序列</p><p>还可以通过数值来指定字符串中的字符，数值以转义序列“\”给出，其中是一个至多3个十进制数字组成的序列。例如：<br>“alo\n123\””与字符串”\97lo\10\04923”是相同的，在ASCII中，’a’的ASCII编码是97，换行是10，’1’的编码是49.这里必须将49写成三个数字049，不然Lua会读取到数值492.</p><p>另外，可以用一对匹配的双方括号来界定一个字母字符串，就像写“块注释”那样，不过Lua不会解释其中的转义序列，并且会忽略第一个字符是换行字符的部分，这种写法对于书写那种含有程序代码的字符串尤为有用。</p><pre><code>page=[[&lt;html&gt;&lt;head&gt;&lt;title&gt;an html page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;http://www.lua.org&quot;&gt;lua&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;]]print(page)print(type(page))                   --string</code></pre><p>Lua提供了运行时的数字与字符串的自动转换。在一个字符串上应用算术操作时，Lua会尝试将这个字符串转换成一个数字:</p><pre><code>print(&quot;10&quot; + 1)         --11print(&quot;10+1&quot;)           --10+1print(&quot;hello&quot; + 1)      --报错，不能将string字符串转换成一个数字</code></pre><p>在Lua期望一个字符串但却得到一个数字时，它也会将数字转换成字符串：</p><pre><code>a=10 .. 20print(10 .. 20)         --1020print(a)                --1020print(type(a))          --string</code></pre><p>在Lua中，“..”是字符串连接操作符，记得该操作符与数字之间必须要用空格来分隔，不然Lua会将第一个点理解为一个小数点。</p>]]></content>
      
      
      <categories>
          
          <category> lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity之事件机制</title>
      <link href="/2016/12/29/unity-zhi-shi-jian-ji-zhi/"/>
      <url>/2016/12/29/unity-zhi-shi-jian-ji-zhi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>事件机制主要用于模块之间解耦和，事件机制将各个模块联系在一起，并且它们之间的耦合性非常低，特别适用于游戏产品的模块化开发。事件的类型可以通过枚举的形式来表示。事件机制的实现原理是将表示不同事件的枚举与其对应的回调函数通过AddListener函数加到定义好的表中，触发回调函数通过notify函数对已定义的事件枚举进行分类分发，从发触发已加载到内存的事件回调函数。等开发者不需要监听事件可通过RemoveListener函数移除监听即可。</p><p>下面给出一个Demo的UnityPackage的链接：<br>链接： <a href="http://pan.baidu.com/s/1c1LOD4O" target="_blank" rel="noopener"> http://pan.baidu.com/s/1c1LOD4O </a><br>密码：y4fv</p><p>链接如有失效，联系博主及时更新。</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity之私人订制Debug</title>
      <link href="/2016/12/14/unity-zhi-si-ren-ding-zhi-debug/"/>
      <url>/2016/12/14/unity-zhi-si-ren-ding-zhi-debug/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>其实原理很简单，这里用到的是富文本的知识，也许大家会觉得这种low定制反而显得麻烦了，那就直接跳过。。。</p><p>直接上代码：</p><pre><code>using UnityEngine;using System.Collections;using System;using System.Text;namespace Scripts.CoreScripts.Core.Helper{    public class Debugger    {        /// &lt;summary&gt;        /// 是否开启Debugger        /// &lt;/summary&gt;        static public bool Enable = true;        /// &lt;summary&gt;        /// 默认错误颜色：红色        /// &lt;/summary&gt;        static public string ErrorColor = &quot;red&quot;;        /// &lt;summary&gt;        /// 默认警告颜色：黄色        /// &lt;/summary&gt;        static public string WarningColor = &quot;yellow&quot;;        /// &lt;summary&gt;        /// 默认输出颜色：白色        /// &lt;/summary&gt;        static public string LogColor = &quot;white&quot;;        /// &lt;summary&gt;        /// 默认字号：20        /// &lt;/summary&gt;        static public int FontSize = 20;        /// &lt;summary&gt;        /// 默认颜色，默认字号输出        /// &lt;/summary&gt;        /// &lt;param name=&quot;message&quot;&gt;输出内容&lt;/param&gt;        static public void Log(object message)        {            if (Enable)            {                Debug.Log(&quot;&lt;color=&quot; + LogColor + &quot;&gt;&quot; + &quot;&lt;size=&quot; + FontSize + &quot;&gt;&quot; + message + &quot;&lt;/size&gt;&quot; + &quot;&lt;/color&gt;&quot;);            }        }        /// &lt;summary&gt;        /// 默认颜色，默认字号输出        /// &lt;/summary&gt;        /// &lt;param name=&quot;message&quot;&gt;输出内容&lt;/param&gt;        /// &lt;param name=&quot;context&quot;&gt;连接上下文&lt;/param&gt;        static public void Log(object message, UnityEngine.Object context)        {            if (Enable)            {                Debug.Log(&quot;&lt;color=&quot; + LogColor + &quot;&gt;&quot; + &quot;&lt;size=&quot; + FontSize + &quot;&gt;&quot; + message + &quot;&lt;/size&gt;&quot; + &quot;&lt;/color&gt;&quot;, context);            }        }        /// &lt;summary&gt;        /// 自定义颜色输出        /// &lt;/summary&gt;        /// &lt;param name=&quot;message&quot;&gt;输出内容&lt;/param&gt;        /// &lt;param name=&quot;color&quot;&gt;颜色&lt;/param&gt;        static public void Log(object message, Color32 color)        {            if (Enable)            {                Debug.Log(&quot;&lt;color=&quot; + FormatColor32(color) + &quot;&gt;&quot; + message + &quot;&lt;/color&gt;&quot;);            }        }        /// &lt;summary&gt;        /// 自定义颜色、默认字号输出        /// &lt;/summary&gt;        /// &lt;param name=&quot;message&quot;&gt;输出内容&lt;/param&gt;        /// &lt;param name=&quot;color&quot;&gt;颜色&lt;/param&gt;        /// &lt;param name=&quot;context&quot;&gt;连接上下文&lt;/param&gt;        static public void Log(object message, Color32 color, UnityEngine.Object context)        {            if (Enable)            {                Debug.Log(&quot;&lt;color=&quot; + FormatColor32(color) + &quot;&gt;&quot; + &quot;&lt;size=&quot; + FontSize + &quot;&gt;&quot; + message + &quot;&lt;/size&gt;&quot; + &quot;&lt;/color&gt;&quot;, context);            }        }        /// &lt;summary&gt;        /// 自定义字号输出        /// &lt;/summary&gt;        /// &lt;param name=&quot;message&quot;&gt;输出内容&lt;/param&gt;        /// &lt;param name=&quot;fontSize&quot;&gt;字号大小，汉字上限26，大写英文上限30，小写英文上限25，仅供参考&lt;/param&gt;        static public void Log(object message, int fontSize)        {            if (Enable)            {                Debug.Log(&quot;&lt;color=&quot; + LogColor + &quot;&gt;&quot; + &quot;&lt;size=&quot; + FontSize + &quot;&gt;&quot; + message + &quot;&lt;/size&gt;&quot; + &quot;&lt;/color&gt;&quot;);            }        }        /// &lt;summary&gt;        /// 自定义字号输出        /// &lt;/summary&gt;        /// &lt;param name=&quot;message&quot;&gt;输出内容&lt;/param&gt;        /// &lt;param name=&quot;fontSize&quot;&gt;字号&lt;/param&gt;        /// &lt;param name=&quot;context&quot;&gt;连接上下文&lt;/param&gt;        static public void Log(object message, int fontSize, UnityEngine.Object context)        {            if (Enable)            {                Debug.Log(&quot;&lt;size=&quot; + fontSize + &quot;&gt;&quot; + message + &quot;&lt;/size&gt;&quot;, context);            }        }        /// &lt;summary&gt;        /// 自定义字号、颜色输出        /// &lt;/summary&gt;        /// &lt;param name=&quot;message&quot;&gt;输出内容&lt;/param&gt;        /// &lt;param name=&quot;color&quot;&gt;颜色&lt;/param&gt;        /// &lt;param name=&quot;fontsize&quot;&gt;字号&lt;/param&gt;        static public void Log(object message, Color32 color, int fontsize)        {            if (Enable)            {                Debug.Log(&quot;&lt;color=&quot; + FormatColor32(color) + &quot;&gt;&quot; + &quot;&lt;size=&quot; + fontsize + &quot;&gt;&quot; + message + &quot;&lt;/size&gt;&quot; + &quot;&lt;/color&gt;&quot;);            }        }        /// &lt;summary&gt;        /// 自定义字号、颜色输出        /// &lt;/summary&gt;        /// &lt;param name=&quot;message&quot;&gt;输出内容&lt;/param&gt;        /// &lt;param name=&quot;color&quot;&gt;颜色&lt;/param&gt;        /// &lt;param name=&quot;fontSize&quot;&gt;字号&lt;/param&gt;        /// &lt;param name=&quot;context&quot;&gt;连接上下文&lt;/param&gt;        static public void Log(object message, Color32 color, int fontSize, UnityEngine.Object context)        {            if (Enable)            {                Debug.Log(&quot;&lt;color=&quot; + FormatColor32(color) + &quot;&gt;&quot; + &quot;&lt;size=&quot; + fontSize + &quot;&gt;&quot; + message + &quot;&lt;/size&gt;&quot; + &quot;&lt;/color&gt;&quot;, context);            }        }        static public void LogWarning(object message)        {            if (Enable)            {                Debug.LogWarning(&quot;&lt;color=&quot; + WarningColor + &quot;&gt;&quot; + message + &quot;&lt;/color&gt;&quot;);            }        }        static public void LogWarning(object message, UnityEngine.Object context)        {            if (Enable)            {                Debug.LogWarning(&quot;&lt;color=&quot; + WarningColor + &quot;&gt;&quot; + message + &quot;&lt;/color&gt;&quot;, context);            }        }        static public void LogError(object message)        {            if (Enable)            {                Debug.LogError(&quot;&lt;color=&quot; + ErrorColor + &quot;&gt;&quot; + message + &quot;&lt;/color&gt;&quot;);            }        }        static public void LogError(object message, UnityEngine.Object context)        {            if (Enable)            {                Debug.LogError(&quot;&lt;color=&quot; + ErrorColor + &quot;&gt;&quot; + message + &quot;&lt;/color&gt;&quot;, context);            }        }        /// &lt;summary&gt;        /// 将Color32转换为#FFFFFFFF格式        /// &lt;/summary&gt;        /// &lt;param name=&quot;color&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        static private string FormatColor32(Color32 color)        {            StringBuilder sb = new StringBuilder();            sb.Append(&quot;#&quot;);            sb.Append(color.r.ToString(&quot;x2&quot;));            sb.Append(color.g.ToString(&quot;x2&quot;));            sb.Append(color.b.ToString(&quot;x2&quot;));            sb.Append(color.a.ToString(&quot;x2&quot;));            return sb.ToString();        }    }}</code></pre><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity之Vector3D：重现Vector3</title>
      <link href="/2016/12/13/unity-zhi-vector3d-chong-xian-vector3/"/>
      <url>/2016/12/13/unity-zhi-vector3d-chong-xian-vector3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>直接上代码</p><pre><code>using System;using System.Text;using UnityEngine;public class Vector3D{    public static Vector3D back    {        get        {            return new Vector3D(0, 0, -1);        }    }    public static Vector3D down    {        get        {            return new Vector3D(0, -1, 0);        }    }    public static Vector3D forward    {        get        {            return new Vector3D(0, 0, 1);        }    }    public static Vector3D left    {        get        {            return new Vector3D(-1, 0, 0);        }    }    public static Vector3D right    {        get        {            return new Vector3D(1, 0, 0);        }    }    public static Vector3D up    {        get        {            return new Vector3D(0, 1, 0);        }    }    public static Vector3D one    {        get        {            return new Vector3D(1, 1, 1);        }    }    public static Vector3D zero    {        get        {            return new Vector3D(0, 0, 0);        }    }    /// &lt;summary&gt;    /// 向量的长度    /// &lt;/summary&gt;    public float magnitude    {        get        {            return (float)Math.Sqrt(sqrMagnitudfe);        }    }    /// &lt;summary&gt;    /// 向量的的长度的平方    /// &lt;/summary&gt;    public float sqrMagnitudfe    {        get        {            return x * x + y * y + z * z;        }    }    /// &lt;summary&gt;    /// 规范化    /// &lt;/summary&gt;    public Vector3D normalized    {        get        {            if (IsZero)            {                return Vector3D.zero;            }            else            {                Vector3D v = new Vector3D();                float length = magnitude;                v.x = this.x / length;                v.y = this.y / length;                v.z = this.z / length;                return v;            }        }    }    /// &lt;summary&gt;    /// 是否是零向量    /// &lt;/summary&gt;    public bool IsZero    {        get        {            return this.x == 0 &amp;&amp; this.y == 0 &amp;&amp; this.z == 0;        }    }    #region 操作符重载    /// &lt;summary&gt;    /// 两个向量相加    /// &lt;/summary&gt;    /// &lt;param name=&quot;a&quot;&gt;向量a&lt;/param&gt;    /// &lt;param name=&quot;b&quot;&gt;向量b&lt;/param&gt;    /// &lt;returns&gt;两个向量的和&lt;/returns&gt;    public static Vector3D operator +(Vector3D a,Vector3D b)    {        return new Vector3D(a.x + b.x, a.y + b.y, a.z + b.z);    }    /// &lt;summary&gt;    /// 两个向量相减    /// &lt;/summary&gt;    /// &lt;param name=&quot;a&quot;&gt;向量a&lt;/param&gt;    /// &lt;param name=&quot;b&quot;&gt;向量b&lt;/param&gt;    /// &lt;returns&gt;两个向量的差&lt;/returns&gt;    public static Vector3D operator -(Vector3D a,Vector3D b)    {        return new Vector3D(a.x - b.x, a.y - b.y, a.z - b.z);    }    /// &lt;summary&gt;    /// 向量取反    /// &lt;/summary&gt;    /// &lt;param name=&quot;a&quot;&gt;向量a&lt;/param&gt;    /// &lt;returns&gt;向量a的反向量&lt;/returns&gt;    public static Vector3D operator -(Vector3D a)    {        return new Vector3D(-a.x, -a.y, -a.z);    }    /// &lt;summary&gt;    /// 一个数乘以一个向量    /// &lt;/summary&gt;    /// &lt;param name=&quot;d&quot;&gt;一个数&lt;/param&gt;    /// &lt;param name=&quot;a&quot;&gt;一个向量&lt;/param&gt;    /// &lt;returns&gt;返回数与向量的乘积&lt;/returns&gt;    public static Vector3D operator *(float d, Vector3D a)    {        return new Vector3D(a.x * d, a.y * d, a.z * d);    }    /// &lt;summary&gt;    /// 一个向量乘以一个数    /// &lt;/summary&gt;    /// &lt;param name=&quot;a&quot;&gt;一个向量&lt;/param&gt;    /// &lt;param name=&quot;d&quot;&gt;一个数&lt;/param&gt;    /// &lt;returns&gt;返回向量与数的乘积&lt;/returns&gt;    public static Vector3D operator *(Vector3D a, float d)    {        return new Vector3D(a.x * d, a.y * d, a.z * d);    }    /// &lt;summary&gt;    /// 一个数除一个向量，向量a/数b    /// &lt;/summary&gt;    /// &lt;param name=&quot;a&quot;&gt;一个向量&lt;/param&gt;    /// &lt;param name=&quot;d&quot;&gt;一个数&lt;/param&gt;    /// &lt;returns&gt;返回向量a/d&lt;/returns&gt;    public static Vector3D operator /(Vector3D a,float d)    {        return new Vector3D(a.x / d, a.y / d, a.z / d);    }    /// &lt;summary&gt;    /// 两个向量是否相等    /// &lt;/summary&gt;    /// &lt;param name=&quot;lhs&quot;&gt;向量lhs&lt;/param&gt;    /// &lt;param name=&quot;rhs&quot;&gt;向量rhs&lt;/param&gt;    /// &lt;returns&gt;如果相等，则为true，否则为false&lt;/returns&gt;    public static bool operator ==(Vector3D lhs, Vector3D rhs)    {        bool x = Math.Abs(lhs.x - rhs.x) &lt; 0.00001f;        bool y = Math.Abs(lhs.y - rhs.y) &lt; 0.00001f;        bool z = Math.Abs(lhs.z - rhs.z) &lt; 0.00001f;        return x &amp;&amp; y &amp;&amp; z;    }    /// &lt;summary&gt;    /// 两个向量是否不等    /// &lt;/summary&gt;    /// &lt;param name=&quot;lhs&quot;&gt;向量lhs&lt;/param&gt;    /// &lt;param name=&quot;rhs&quot;&gt;向量rhs&lt;/param&gt;    /// &lt;returns&gt;如果不等，则为true，否则为false&lt;/returns&gt;    public static bool operator !=(Vector3D lhs, Vector3D rhs)    {        return !(lhs == rhs);    }    #endregion    public float x;    public float y;    public float z;    private float[] data = new float[3];    #region 构造器    public Vector3D()    {        this.x = 0.0f;        this.y = 0.0f;        this.z = 0.0f;        data[0] = 0.0f;        data[1] = 0.0f;        data[2] = 0.0f;    }    public Vector3D(float x, float y)    {        this.x = x;        this.y = y;        this.z = 1.0f;        data[0] = 0.0f;        data[1] = 0.0f;        data[2] = 1.0f;    }    public Vector3D(float x, float y, float z)    {        this.x = x;        this.y = y;        this.z = z;        data[0] = x;        data[1] = y;        data[2] = z;    }    #endregion    public float this[int index]    {        get        {            switch (index)            {                case 0:                    return this.x;                case 1:                    return this.y;                case 2:                    return this.z;                default:                    throw new Exception(&quot;index is out of array&quot;);            }        }        set        {            data[index] = value;            switch (index)            {                case 0:                    this.x = value;                    break;                case 1:                    this.y = value;                    break;                case 2:                    this.z = value;                    break;                default:                    break;            }        }    }    public override string ToString()    {        StringBuilder sb = new StringBuilder();        sb.Append(&quot;(&quot;);        sb.Append(this.x);        sb.Append(&quot;,&quot;);        sb.Append(this.y);        sb.Append(&quot;,&quot;);        sb.Append(this.z);        sb.Append(&quot;)&quot;);        return sb.ToString();    }    public void Set(float new_x, float new_y, float new_z)    {        this.x = new_x;        this.y = new_y;        this.z = new_z;        data[0] = new_x;        data[1] = new_y;        data[2] = new_z;    }    /// &lt;summary&gt;    /// 规范化，使向量长度为1    /// &lt;/summary&gt;    public void Normalize()    {        if (!IsZero)        {            this.x /= magnitude;            this.y /= magnitude;            this.z /= magnitude;        }    }    #region 静态函数    /// &lt;summary&gt;    /// 距离    /// &lt;/summary&gt;    /// &lt;param name=&quot;a&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;b&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;返回a和b之间的距离&lt;/returns&gt;    public static float Distance(Vector3D a, Vector3D b)    {        return (float)Math.Sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (a.z - b.z) * (a.z - b.z));    }    /// &lt;summary&gt;    /// 计算两个向量的点乘积    /// &lt;/summary&gt;    /// &lt;param name=&quot;lhs&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;rhs&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static float Dot(Vector3D lhs, Vector3D rhs)    {        return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;    }    /// &lt;summary&gt;    /// 计算两个向量的叉乘    /// &lt;/summary&gt;    /// &lt;param name=&quot;v1&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;v2&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static Vector3D Cross(Vector3D v1, Vector3D v2)    {        float x = v1.y * v2.z - v2.y * v1.z;        float y = v1.z * v2.x - v2.z * v1.x;        float z = v1.x * v2.y - v2.x * v1.y;        return new Vector3D(x, y, z);    }    /// &lt;summary&gt;    /// 限制长度    /// &lt;/summary&gt;    /// &lt;param name=&quot;v&quot;&gt;向量v&lt;/param&gt;    /// &lt;param name=&quot;maxLength&quot;&gt;最长长度&lt;/param&gt;    /// &lt;returns&gt;返回限制长度后的向量&lt;/returns&gt;    public static Vector3D ClampMagnitude(Vector3D v,float maxLength)    {        if (maxLength &gt;= v.magnitude)        {            return v;        }        return (maxLength / v.magnitude) * v;    }    /// &lt;summary&gt;    /// 计算两个向量的夹角    /// &lt;/summary&gt;    /// &lt;param name=&quot;from&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;to&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static float Angle(Vector3D from,Vector3D to)    {        float dot = Dot(from, to);        return (float)(180 * Math.Acos(dot / (from.magnitude * to.magnitude)) / Math.PI);    }    /// &lt;summary&gt;    /// 投射一个向量到另一个向量    /// &lt;/summary&gt;    /// &lt;param name=&quot;vector&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;onNormal&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;返回被投射到onNormal的vector&lt;/returns&gt;    public static Vector3D Project(Vector3D vector, Vector3D onNormal)    {        if (vector.IsZero || onNormal == Vector3D.zero)        {            return Vector3D.zero;        }        return Dot(vector, onNormal) / (onNormal.magnitude * onNormal.magnitude) * onNormal;    }    /// &lt;summary&gt;    /// 反射    /// &lt;/summary&gt;    /// &lt;param name=&quot;inDirection&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;inNormal&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static Vector3D Reflect(Vector3D inDirection,Vector3D inNormal)    {        return Vector3D.zero;    }    /// &lt;summary&gt;    /// 缩放    /// &lt;/summary&gt;    /// &lt;param name=&quot;scale&quot;&gt;&lt;/param&gt;    public void Scale(Vector3D scale)    {        this.x *= scale.x;        this.y *= scale.y;        this.z *= scale.z;    }    /// &lt;summary&gt;    /// 缩放    /// &lt;/summary&gt;    /// &lt;param name=&quot;a&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;b&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static Vector3D Scale(Vector3D a,Vector3D b)    {        return new Vector3D(a.x * b.x, a.y * b.y, a.z * b.z);    }    /// &lt;summary&gt;    /// 两个向量是否平行    /// &lt;/summary&gt;    /// &lt;param name=&quot;a&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;b&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static bool Parallel(Vector3D a, Vector3D b)    {        return Cross(a,b).IsZero;    }    /// &lt;summary&gt;    /// 两个向量之间的线性插值    /// &lt;/summary&gt;    /// &lt;param name=&quot;from&quot;&gt;向量from&lt;/param&gt;    /// &lt;param name=&quot;to&quot;&gt;向量to&lt;/param&gt;    /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static Vector3D Lerp(Vector3D from, Vector3D to, float t)    {        if (t &lt;= 0)        {            return from;        }        else if (t &gt;= 1)        {            return to;        }        return t * to + (1 - t) * from;    }    /// &lt;summary&gt;    /// 两个向量的球形插值    /// &lt;/summary&gt;    /// &lt;param name=&quot;a&quot;&gt;向量a&lt;/param&gt;    /// &lt;param name=&quot;b&quot;&gt;向量b&lt;/param&gt;    /// &lt;param name=&quot;t&quot;&gt;t的值在[0..1]&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static Vector3D Slerp(Vector3D a, Vector3D b, float t)    {        if (t &lt;= 0)        {            return a;        }        else if (t &gt;= 1)        {            return b;        }        Vector3D v = RotateTo(a, b, Vector3D.Angle(a, b) * t);        //向量的长度，跟线性插值一样计算        float length = b.magnitude * t + a.magnitude * (1 - t);        return v.normalized * length;    }    /// &lt;summary&gt;    /// 将向量from向向量to旋转角度angle    /// &lt;/summary&gt;    /// &lt;param name=&quot;from&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;to&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;angle&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static Vector3D RotateTo(Vector3D from, Vector3D to, float angle)    {        //如果两向量角度为0        if (Vector3D.Angle(from, to) == 0)        {            return from;        }        //旋转轴        Vector3D n = Vector3D.Cross(from, to);        n.Normalize();        //旋转矩阵        Matrix4x4 rotateMatrix = new Matrix4x4();        //旋转的弧度        double radian = angle * Math.PI / 180;        float cosAngle = (float)Math.Cos(radian);        float sinAngle = (float)Math.Sin(radian);        rotateMatrix.SetRow(0, new Vector4(n.x * n.x * (1 - cosAngle) + cosAngle, n.x * n.y * (1 - cosAngle) + n.z * sinAngle, n.x * n.z * (1 - cosAngle) - n.y * sinAngle, 0));        rotateMatrix.SetRow(1, new Vector4(n.x * n.y * (1 - cosAngle) - n.z * sinAngle, n.y * n.y * (1 - cosAngle) + cosAngle, n.y * n.z * (1 - cosAngle) + n.x * sinAngle, 0));        rotateMatrix.SetRow(2, new Vector4(n.x * n.z * (1 - cosAngle) + n.y * sinAngle, n.y * n.z * (1 - cosAngle) - n.x * sinAngle, n.z * n.z * (1 - cosAngle) + cosAngle, 0));        rotateMatrix.SetRow(3, new Vector4(0, 0, 0, 1));        Vector4 v = Vector3D.ToVector4(from);        Vector3D vector = new Vector3D();        for (int i = 0; i &lt; 3; ++i)        {            for (int j = 0; j &lt; 3; j++)            {                vector[i] += v[j] * rotateMatrix[j, i];            }        }        return vector;    }    /// &lt;summary&gt;    /// 将一个Vector3D转换为Vector4    /// &lt;/summary&gt;    /// &lt;param name=&quot;v&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static Vector4 ToVector4(Vector3D v)    {        return new Vector4(v.x, v.y, v.z, 0);    }    public Vector3 ToVector3()    {        return new Vector3(x, y, z);    }    #endregion}</code></pre><p>以上代码只是自己在学习过程中一点成果，希望对大家有帮助，当然跟Vector3比起来肯定差很多。</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity之Vector3.Lerp线性插值原理介绍</title>
      <link href="/2016/12/13/unity-zhi-vector3.lerp-xian-xing-cha-zhi-yuan-li-jie-shao/"/>
      <url>/2016/12/13/unity-zhi-vector3.lerp-xian-xing-cha-zhi-yuan-li-jie-shao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>先看下面这个图：<br><img src="https://img-blog.csdn.net/20161213114512329?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>画的比较潦草，大家将就看。。。</p><p>向量from 和 向量to在xy平面上，其实这并不影响讲解插值原理。</p><p>图中可以看出当t=0.5f时，插值向量就是中间那个向量，其x轴分量的计算图中已经给出了，y轴也同理，z轴也一样。。</p><p>下面看下函数：<br>public static Vector3 Lerp(Vector3 a, Vector3 b, float t);</p><p>其中a就是图中的from向量，b就是to向量。<br>t是夹在 [0…1]之间，当t = 0时，返回from，当t = 1时，返回to。当t = 0.5 返回from和to的平均数</p><p>所以具体实现代码如下：</p><pre><code>    /// &lt;summary&gt;    /// 两个向量之间的线性插值    /// &lt;/summary&gt;    /// &lt;param name=&quot;from&quot;&gt;向量from&lt;/param&gt;    /// &lt;param name=&quot;to&quot;&gt;向量to&lt;/param&gt;    /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static Vector3D Lerp(Vector3D from, Vector3D to, float t)    {        if (t &lt;= 0)        {            return from;        }        else if (t &gt;= 1)        {            return to;        }        return t * to + (1 - t) * from;    }</code></pre><p>线性插值比Slerp球形插值简单的多。</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity之Vector3.Slerp球形插值原理介绍</title>
      <link href="/2016/12/09/unity-zhi-vector3.slerp-qiu-xing-cha-zhi-yuan-li-jie-shao/"/>
      <url>/2016/12/09/unity-zhi-vector3.slerp-qiu-xing-cha-zhi-yuan-li-jie-shao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>先看API：<br>public static Vector3 Slerp(Vector3 a, Vector3 b, float t);<br>介绍：通过t数值在from和to之间插值。返回的向量的长度将被插值到from到to的长度之间。<br>先上一个示意图：<br><img src="https://img-blog.csdn.net/20161209112110583?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>上图的代码如下：</p><pre><code>    private Vector3 mStart = new Vector3(-1, 1, 0);    private Vector3 mEnd = new Vector3(1, 1, 0);    // Update is called once per frame    private void Update()    {        //绘制坐标轴        Debug.DrawLine(new Vector3(-100, 0, 0), new Vector3(100, 0, 0), Color.green);        Debug.DrawLine(new Vector3(0, -100, 0), new Vector3(0, 100, 0), Color.green);        Debug.DrawLine(new Vector3(0, 0, -100), new Vector3(0, 0, 100), Color.green);        Debug.DrawLine(Vector3.zero, mStart, Color.red);        Debug.DrawLine(Vector3.zero, mEnd, Color.red);        Debug.DrawLine(mStart, mEnd, Color.red);        for (int i = 1; i &lt; 10; ++i)        {            Vector3 drawVec = Vector3.Slerp(mStart, mEnd, 0.1f * i);            Debug.DrawLine(Vector3.zero, drawVec, Color.yellow);        }    }</code></pre><p>下面先做几次实验来验证下面两个猜想：<br>1、猜想一：插值的向量的长度是均匀线性变化的<br>2、猜想二：插值的向量之间的角度是一样大的</p><p>上图验证：<br>实验一：我们在上面代码的基础上加上输出：</p><pre><code>//加在for循环里Debug.Log(&quot;插值向量长度：&quot;+ drawVec.magnitude);Debug.Log(&quot;角度：&quot; + Vector3.Angle(drawVec, mStart) / i);</code></pre><p><img src="https://img-blog.csdn.net/20161209112850532?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>我们发现虽然有误差，但是猜想基本成立，我们修改mStart和mEnd两向量继续实验。</p><p>实验二：mStart = (-1,0,0) mEnd = (0,3,4)<br><img src="https://img-blog.csdn.net/20161209113159037?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>从上面可以看出两个猜想成立</p><p>这里额外要验证一个问题，就是当两个向量为平行向量时，结果如下，下面直接看图：<br>（1）mStart = (-1, 0, 0) mEnd = (1, 0, 0)<br><img src="https://img-blog.csdn.net/20161209114817399?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>（2）mStart = (-1, 1, 0) mEnd = (1, -1, 0)<br><img src="https://img-blog.csdn.net/20161209115239713?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>（3）mStart = (-1, 1, 1) mEnd = (1, -1, -1)<br><img src="https://img-blog.csdn.net/20161209134923381?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>那么现在就可以利用这几个结论来自实现Slerp插值了。</p><p>下面直接上代码：<br>代码关键内容如下：<br>（1）旋转向量函数<br>（2）旋转矩阵</p><pre><code>    /// &lt;summary&gt;    /// 两个向量的球形插值    /// &lt;/summary&gt;    /// &lt;param name=&quot;a&quot;&gt;向量a&lt;/param&gt;    /// &lt;param name=&quot;b&quot;&gt;向量b&lt;/param&gt;    /// &lt;param name=&quot;t&quot;&gt;t的值在[0..1]&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static Vector3D Slerp(Vector3D a, Vector3D b, float t)    {        if (t &lt;= 0)        {            return a;        }        else if (t &gt;= 1)        {            return b;        }        Vector3D v = RotateTo(a, b, Vector3D.Angle(a, b) * t);        //向量的长度，跟线性插值一样计算        float length = b.magnitude * t + a.magnitude * (1 - t);        return v.normalized * length;    }    /// &lt;summary&gt;    /// 将向量from向向量to旋转角度angle    /// &lt;/summary&gt;    /// &lt;param name=&quot;from&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;to&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;angle&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static Vector3D RotateTo(Vector3D from, Vector3D to, float angle)    {        //如果两向量角度为0        if (Vector3D.Angle(from, to) == 0)        {            return from;        }        //旋转轴        Vector3D n = Vector3D.Cross(from, to);        //旋转轴规范化        n.Normalize();        //旋转矩阵        Matrix4x4 rotateMatrix = new Matrix4x4();        //旋转的弧度        double radian = angle * Math.PI / 180;        float cosAngle = (float)Math.Cos(radian);        float sinAngle = (float)Math.Sin(radian);        //矩阵的数据        //这里看不懂的自行科普矩阵知识        rotateMatrix.SetRow(0, new Vector4(n.x * n.x * (1 - cosAngle) + cosAngle, n.x * n.y * (1 - cosAngle) + n.z * sinAngle, n.x * n.z * (1 - cosAngle) - n.y * sinAngle, 0));        rotateMatrix.SetRow(1, new Vector4(n.x * n.y * (1 - cosAngle) - n.z * sinAngle, n.y * n.y * (1 - cosAngle) + cosAngle, n.y * n.z * (1 - cosAngle) + n.x * sinAngle, 0));        rotateMatrix.SetRow(2, new Vector4(n.x * n.z * (1 - cosAngle) + n.y * sinAngle, n.y * n.z * (1 - cosAngle) - n.x * sinAngle, n.z * n.z * (1 - cosAngle) + cosAngle, 0));        rotateMatrix.SetRow(3, new Vector4(0, 0, 0, 1));        Vector4 v = Vector3D.ToVector4(from);        Vector3D vector = new Vector3D();        for (int i = 0; i &lt; 3; ++i)        {            for (int j = 0; j &lt; 3; j++)            {                vector[i] += v[j] * rotateMatrix[j, i];            }        }        return vector;    }    /// &lt;summary&gt;    /// 将一个Vector3D转换为Vector4    /// &lt;/summary&gt;    /// &lt;param name=&quot;v&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static Vector4 ToVector4(Vector3D v)    {        return new Vector4(v.x, v.y, v.z, 0);    }    public Vector3 ToVector3()    {        return new Vector3(x, y, z);    }</code></pre><p>这里暂时没有对两个向量共线反向的情况进行说明，不过主要实现已经给出来了。但是，我发现一点问题，看图：<br>（1）v1 = new Vector3(0, 2, 0);v2 = new Vector3(5, 0, 0);<br><img src="https://img-blog.csdn.net/20161211204127975?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>ok，正常</p><p>（2）v1 = new Vector3(3, 0, 0);v2 = new Vector3(0, 0, 5);<br><img src="https://img-blog.csdn.net/20161211204257397?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>ok，正常</p><p>（3）在RotateTo函数中，数据不精确导致存在误差，也就是我打印v1和v2的叉乘 （图中黄色） 与 （图中红色向量）的叉乘<br>存在误差，这样其实就是该函数的旋转轴不准确。</p><p>以上猜想以及代码实现 没有找到权威认证，如有异议，欢迎探讨。。。</p><p>补充：<br>自己无聊利用Slerp插值画了下面这个图，纯属娱乐。。。<br><img src="https://img-blog.csdn.net/20161212121854699?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UGUI之Aspect Ratio Fitter组件介绍</title>
      <link href="/2016/12/08/ugui-zhi-aspect-ratio-fitter-zu-jian-jie-shao/"/>
      <url>/2016/12/08/ugui-zhi-aspect-ratio-fitter-zu-jian-jie-shao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>组件截图如下：<br><img src="https://img-blog.csdn.net/20161130181516831" alt="这里写图片描述"></p><p>1、Aspect Mode：AspectMode枚举类型</p><pre><code>public enum AspectMode {                         //不使用适合的纵横比    None,    //让Height随着Width自动调节    WidthControlsHeight,    //让Width随着Height自动调节    HeightControlsWidth,    //宽度、高度、位置和锚点都会被自动调整，以使得该矩形拟合父物体的矩形内，同时保持宽高比例    FitInParent,    //宽度、高度、位置和锚点都会被自动调整，以使得该矩形覆盖父物体的整个区域，同时保持宽高比    EnvelopeParent}</code></pre><p>2、Aspect Ratio：宽高比例，width/height</p><p>下面根据实际情况来介绍一下该组件。在我的工作中，遇到一种情况，玩家获得一些奖励，做成一个通用的UI界面，该界面通常包括以下东西：标题、获得按钮、中间是一排物品item，显然中间的一排物品item会用到水平布局，并且居中显示，每一个item又包括一个icon和一个text（显示count），如果此时存在某一个icon比其他的大些，就会显得很突兀，这个时候我就用到了该组件</p><p>给item预制件 中的icon 添加一个父物体，然后给icon加一个Aspect Ratio<br>Fitter，AspectMode选用FitInParent，Aspect Ratio的值需要在代码中计算，因为我们在做这个UI的时候<br>，肯定是根据数据来动态实例化这些item的，每一个icon的宽高比不一样，所以需要在代码中计算，代码如下：</p><pre><code>Rect rect = GetComponent&lt;Image&gt;().sprite.rect;AspectRatioFitter fitter = GetComponent&lt;AspectRatioFitter&gt;();fitter.aspectRatio = rect.width / rect.height;</code></pre><p>这种做法就会保持icon的大小基本一致，当然如果美术团队出的物品图片资源都一致大小，咱们也就省去了这一步。</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI之布局实战——聊天系统</title>
      <link href="/2016/11/30/ugui-zhi-bu-ju-shi-zhan-liao-tian-xi-tong/"/>
      <url>/2016/11/30/ugui-zhi-bu-ju-shi-zhan-liao-tian-xi-tong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="聊天系统中的UGUI布局"><a href="#聊天系统中的UGUI布局" class="headerlink" title="聊天系统中的UGUI布局"></a>聊天系统中的UGUI布局</h2><p>常用的聊天系统内容包括以下几点：<br>1、发言内容；<br>2、发言人头像<br>3、发言人名称<br>4、语言聊天（本文不考虑该功能，与布局无关）<br>5、表情（本文暂不考虑该功能，后续补充）<br>（4.1）表情与文字混排，比如：PC端的QQ聊天<br>（4.2）表情与文字分开，比如：移动端的QQ<br>6、聊天模式：文本模式、气泡模式<br>（5.1）文本模式：参与聊天的所有人均在左边<br>（5.2）气泡模式：自己的气泡在左边，其余玩家的气泡在右边，如下图：<br><img src="https://img-blog.csdn.net/20161130170008725" alt="这里写图片描述"></p><p><img src="https://img-blog.csdn.net/20161130170129242" alt="这里写图片描述"></p><p>这里以气泡模式为例进行讲解：<br>先上类似效果图：<br><img src="https://img-blog.csdn.net/20161130170902322" alt="这里写图片描述"></p><p>先简单分析一下：<br>这里分为三个预制件：<br>（1）整个对话框作为一个预制件a<br>（2）玩家自己的气泡作为一个预制件b<br>（3）其余玩家的气泡作为一个预制件c<br>然后预制件a对气泡用了垂直布局；预制件b和c做法类似，大小一致；预制件b和c中的气泡背景图片要随着文字内容变化而自动缩放，因此背景图片身上挂上一个Vertical<br>Layout Group组件和Content Size Fitter组件，相关设置如下：<br><img src="https://img-blog.csdn.net/20161130173138099" alt="这里写图片描述"><br>然后将文字内容物体作为背景图片的子物体，并添加组件Content Size Fitter<br>相关设置如下：<br><img src="https://img-blog.csdn.net/20161130173402647" alt="这里写图片描述"></p><p>预制件b和c还有一点区别就是b（玩家自己）的Pivot为（1,1），预制件c（其他玩家）的Pivot为（0,1）</p><p>这样描述可能不太好理解，最后会直接给大家提供一个工程下载地址。</p><p>然后聊天框还支持滚动翻阅浏览前面的聊天记录，因此还需要Scroll Rect、Mask等组件<br><img src="https://img-blog.csdn.net/20161130175154983" alt="这里写图片描述"></p><p><img src="https://img-blog.csdn.net/20161130175312655" alt="这里写图片描述"></p><p>由于聊天窗口下方几个按钮和输入框不是布局的重点，这里就不做介绍，如有需要，后续给大家提供一个工程下载地址。</p><p>那么，布局实战——聊天系统就介绍到这里。</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p><hr><p>更新：<br>Demo示意图如下：<br><img src="https://img-blog.csdn.net/20170114224142012?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>此时图中是空的聊天窗口，每发送或者收到一条聊天记录，只需要生成一个相应 的预制件并作为Content的子物体</p><p><img src="https://img-blog.csdn.net/20170114224522158?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>关于聊天系统的布局呢，根据设计不同布局也就不同，这里是将我工作中的一个聊天系统讲解给大家，具体详情如有兴趣欢迎点击链接： <a href="http://pan.baidu.com/s/1hrMxwf6" target="_blank" rel="noopener"><br>http://pan.baidu.com/s/1hrMxwf6 </a> 密码：6bss<br>下载工程</p><p>我用的unity版本是5.3.7，工程所用美术资源非本人原创，请不要商用，仅限学习使用，如因此出现版权问题，与本人无关。</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI之Grid Layout Group组件介绍</title>
      <link href="/2016/11/30/ugui-zhi-grid-layout-group-zu-jian-jie-shao/"/>
      <url>/2016/11/30/ugui-zhi-grid-layout-group-zu-jian-jie-shao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>Grid Layout Group是LayoutGroup的子类</p><p>脚本属性截图如下：<br><img src="https://img-blog.csdn.net/20161130135310391" alt="这里写图片描述"></p><p>1、Padding：RectOffset类型，矩形偏移，详解请戳 <a href="http://blog.csdn.net/qq_26999509/article/details/53406107" target="_blank" rel="noopener"> UGUI之Horizontal Layout Group组件介绍</a></p><p>2、Cell Size：Vector2类型，默认值为(100,100)，网格中的每个单元格的大小</p><pre><code>[SerializeField] protected Vector2 m_CellSize = new Vector2(100, 100);public Vector2 cellSize { get { return m_CellSize; } set { SetProperty(ref m_CellSize, value); } }</code></pre><p>3、Spacing：这里的Spacing不同于水平布局、垂直布局，是Vector2类型，既然是网格布局，当然存在水平方向的间隔和垂直方向的间隔，这里也不做过多的介绍。</p><p>3、Start Corner：Corner枚举类型</p><pre><code>public enum Corner {     UpperLeft = 0,      //左上角    UpperRight = 1,     //右上角    LowerLeft = 2,      //左下角    LowerRight = 3      //右下角}</code></pre><p>第一个单元格放在哪个角落，默认为UpperLeft左上角</p><p>4、Start Axis：Axis枚举类型</p><pre><code>public enum Axis {     Horizontal = 0,     //水平    Vertical = 1        //垂直}</code></pre><p>（1）Horizontal：水平<br>优先水平排列单元格<br>（2）Vertical：垂直<br>优先垂直排列单元格</p><p>5、Child Alignment：TextAnchor枚举类型，文本锚点，详解请戳 <a href="http://blog.csdn.net/qq_26999509/article/details/53406107" target="_blank" rel="noopener"> UGUI之Horizontal Layout Group组件介绍</a></p><p>6、Constraint：Constraint枚举类型</p><pre><code>public enum Constraint {     Flexible = 0,              //不限制行数和列数    FixedColumnCount = 1,      //约束指定数量的列数    FixedRowCount = 2          //约束指定数量的行数}</code></pre><p>下面以几个截图来看看上面几个设置具体是怎样的作用：<br>以下单元格物体加了一个Text来表示其编号，并且Hierarchy面板中的层级关系并未调整</p><p>图一：默认情况<br><img src="https://img-blog.csdn.net/20161130144209367" alt="这里写图片描述"></p><p>图二：设置Start Corner为Upper Right<br><img src="https://img-blog.csdn.net/20161130163937264" alt="这里写图片描述"></p><p>图三：设置Start Axis为Vertical<br><img src="https://img-blog.csdn.net/20161130164106471" alt="这里写图片描述"></p><p>图四：设置Start Corner为Lower Left、Start Axis为Vertical<br><img src="https://img-blog.csdn.net/20161130164300577" alt="这里写图片描述"></p><p>从以上图中不难看出这两个设置的使用用途。</p><p>实际开发中，我常与Content Size Fitter组件一起使用<br><img src="https://img-blog.csdn.net/20161130164549547" alt="这里写图片描述"></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI之Vertical Layout Group组件介绍</title>
      <link href="/2016/11/30/ugui-zhi-vertical-layout-group-zu-jian-jie-shao/"/>
      <url>/2016/11/30/ugui-zhi-vertical-layout-group-zu-jian-jie-shao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>VerticalLayoutGroup也是HorizontalOrVerticalLayoutGroup的子类，HorizontalOrVerticalLayoutGroup是LayoutGroup的子类，下面从源码中进行对比</p><pre><code>namespace UnityEngine.UI{    [AddComponentMenu(&quot;Layout/Horizontal Layout Group&quot;, 150)]    public class HorizontalLayoutGroup : HorizontalOrVerticalLayoutGroup    {        protected HorizontalLayoutGroup()        {}        public override void CalculateLayoutInputHorizontal()        {            base.CalculateLayoutInputHorizontal();            CalcAlongAxis(0, false);        }        public override void CalculateLayoutInputVertical()        {            CalcAlongAxis(1, false);        }        public override void SetLayoutHorizontal()        {            SetChildrenAlongAxis(0, false);        }        public override void SetLayoutVertical()        {            SetChildrenAlongAxis(1, false);        }    }}namespace UnityEngine.UI{    [AddComponentMenu(&quot;Layout/Vertical Layout Group&quot;, 151)]    public class VerticalLayoutGroup : HorizontalOrVerticalLayoutGroup    {        protected VerticalLayoutGroup()        {}        public override void CalculateLayoutInputHorizontal()        {            base.CalculateLayoutInputHorizontal();            CalcAlongAxis(0, true);        }        public override void CalculateLayoutInputVertical()        {            CalcAlongAxis(1, true);        }        public override void SetLayoutHorizontal()        {            SetChildrenAlongAxis(0, true);        }        public override void SetLayoutVertical()        {            SetChildrenAlongAxis(1, true);        }    }}</code></pre><p>可以看出，唯一的区别就是四个重写的基方法里的调用的CalcAlongAxis、SetChildrenAlongAxis一个是false，一个是true，那么显然true表示是vertical，false表示horizontal</p><p>所以在这就不过多的对Vertical Layout Group组件做过多的介绍，用法跟 Horizontal Layout<br>Group组件一样的用，如果对Horizontal Layout Group组件有不了解的，详情请点击这里 <a href="http://blog.csdn.net/qq_26999509/article/details/53406107" target="_blank" rel="noopener"> Horizontal Layout<br>Group组件介绍 </a></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI之Horizontal Layout Group组件介绍</title>
      <link href="/2016/11/30/ugui-zhi-horizontal-layout-group-zu-jian-jie-shao/"/>
      <url>/2016/11/30/ugui-zhi-horizontal-layout-group-zu-jian-jie-shao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>Horizontal Layout<br>Group是HorizontalOrVerticalLayoutGroup的子类，HorizontalOrVerticalLayoutGroup又是LayoutGroup的子类</p><p>脚本截图如下：<br><img src="https://img-blog.csdn.net/20161130105302623" alt="这里写图片描述"></p><p>图中包括以下属性：<br>1、Padding：RectOffset类型，矩形偏移<br>源码如下：</p><pre><code>public sealed class RectOffset{    public RectOffset();    public RectOffset(int left, int right, int top, int bottom);    ~RectOffset();    public int bottom { get; set; }       //底边缘    public int horizontal { get; }        //水平    public int left { get; set; }         //左边缘    public int right { get; set; }        //右边缘    public int top { get; set; }          //顶边缘    public int vertical { get; }          //垂直    public Rect Add(Rect rect);           //向一个Rect添加边框偏移    public Rect Remove(Rect rect);        //从一个Rect移除边框偏移    public override string ToString();      }</code></pre><p>如下面几个图中：<br>图一：默认情况</p><p><img src="https://img-blog.csdn.net/20161130112111669" alt="这里写图片描述"></p><p>图二：只改变Padding</p><p><img src="https://img-blog.csdn.net/20161130112316107" alt="这里写图片描述"></p><p>当Padding中的边缘大小过大时，会自动缩放布局元素以保持布局元素均在边框内，从下图可以看出<br>图三<br><img src="https://img-blog.csdn.net/20161130113434288" alt="这里写图片描述"></p><p>2、Spacing：float类型<br>布局元素之间的间隔</p><p>图四：只改变Spacing</p><p><img src="https://img-blog.csdn.net/20161130112521843" alt="这里写图片描述"></p><p>当Spacing过大，会自动缩放布局元素以保持布局元素均在边框内，从下图可以看出布局元素宽度缩小了<br>图五：</p><p><img src="https://img-blog.csdn.net/20161130112740875" alt="这里写图片描述"></p><p>3、Child Alignment：TextAnchor枚举类型，文本锚点<br>源码如下：</p><pre><code>public enum TextAnchor{    UpperLeft = 0,           //上左    UpperCenter = 1,         //上中    UpperRight = 2,          //上右    MiddleLeft = 3,          //中左    MiddleCenter = 4,        //中中    MiddleRight = 5,         //中右    LowerLeft = 6,           //下左    LowerCenter = 7,         //下中    LowerRight = 8           //下右}</code></pre><p>4、Child Force Expand：有两个可选<br>（1）Width：是否强行扩大布局元素宽度以填补额外可用的空间<br>（2）Height：是否强行扩大布局元素高度以填补额外可用的空间<br>下面结合截图来说明：<br>图六：勾选Width，填补宽度<br><img src="https://img-blog.csdn.net/20161130113918270" alt="这里写图片描述"></p><p>图七：勾选Height，填补高度<br><img src="https://img-blog.csdn.net/20161130114007873" alt="这里写图片描述"></p><p>图八：勾选Width和Height，填补宽度和高度<br><img src="https://img-blog.csdn.net/20161130114047546" alt="这里写图片描述"></p><p>从以上三图结合图一默认图可以看出其具体效果</p><p>实际开发中，我经常结合Content Size Fitter组件一起使用<br><img src="https://img-blog.csdn.net/20161130114433364" alt="这里写图片描述"></p><p>关于UI布局，大家开发的多了，就熟练了。</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI之Content Size Fitter组件</title>
      <link href="/2016/11/29/ugui-zhi-content-size-fitter-zu-jian/"/>
      <url>/2016/11/29/ugui-zhi-content-size-fitter-zu-jian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>具体属性截图：<br><img src="https://img-blog.csdn.net/20161129161134457" alt="这里写图片描述"></p><p>Horizontal Fit和Vertical<br>Fit均为UI.ContentSizeFitter.FitMode枚举类型，有三个值可选：Unconstrained，MinSize，PreferredSize</p><p>Unconstrained：不执行任何调整<br>MinSize：调整内容的最小大小<br>PreferredSize：调整内容的首选大小，也就是会自动根据内容来调整大小</p><p>使用Content Size Fitter组件，RectTransform组件会发生响应的变化<br>默认情况下RectTransform组件的Width 和 Height 可以在编辑模式下就行修改，当Horizontal<br>Fit不为Unconstrained时，Width不可修改，同理，Vertical Fit不为Unconstrained时，Height不可修改。</p><p>代码中，如果需要获取这个gameobject的Width 和Height，下图中提供了Preferred Height和Preferred<br>Width的获取方式<br><img src="https://img-blog.csdn.net/20161129163322107" alt="这里写图片描述"></p><p>右下角可以看出数据的Source是Text组件，那么我们就可以通过GetComponent().PreferredWidth和PreferredHeight来获得。</p><p>当然不是所有情况，这两个数据的source都是Text！！！</p><p>关于Content Size Fitter介绍暂时就到这里，后续完善</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI之Outline轮廓组件</title>
      <link href="/2016/11/29/ugui-zhi-outline-lun-kuo-zu-jian/"/>
      <url>/2016/11/29/ugui-zhi-outline-lun-kuo-zu-jian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>属性图如下：<br><img src="https://img-blog.csdn.net/20161129150337459" alt="这里写图片描述"></p><p>从源码中可以看出，其实Outline是Shadow的子类，只不过Outline脚本在四个方向上调用了Shadow的ApplyShadowZeroAlloc函数而已，具体源码如下：</p><pre><code>using System.Collections.Generic;namespace UnityEngine.UI{    [AddComponentMenu(&quot;UI/Effects/Outline&quot;, 15)]    public class Outline : Shadow    {        protected Outline()        {}        public override void ModifyMesh(VertexHelper vh)        {            if (!IsActive())                return;            var verts = ListPool&lt;UIVertex&gt;.Get();            vh.GetUIVertexStream(verts);            var neededCpacity = verts.Count * 5;            if (verts.Capacity &lt; neededCpacity)                verts.Capacity = neededCpacity;            var start = 0;            var end = verts.Count;            ApplyShadowZeroAlloc(verts, effectColor, start, verts.Count, effectDistance.x, effectDistance.y);            start = end;            end = verts.Count;            ApplyShadowZeroAlloc(verts, effectColor, start, verts.Count, effectDistance.x, -effectDistance.y);            start = end;            end = verts.Count;            ApplyShadowZeroAlloc(verts, effectColor, start, verts.Count, -effectDistance.x, effectDistance.y);            start = end;            end = verts.Count;            ApplyShadowZeroAlloc(verts, effectColor, start, verts.Count, -effectDistance.x, -effectDistance.y);            vh.Clear();            vh.AddUIVertexTriangleStream(verts);            ListPool&lt;UIVertex&gt;.Release(verts);        }    }}</code></pre><p>这里不再赘述Outline组件的属性了，跟Shadow组件一样用，关于Shadow组件的介绍请戳这里 <a href="http://blog.csdn.net/qq_26999509/article/details/53392472" target="_blank" rel="noopener"> UGUI之Shadow阴影组件</a></p><p>相应的，使用Outline组件，顶点数加了四倍<br><img src="https://img-blog.csdn.net/20161129151642745" alt="这里写图片描述"></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI之Shadow阴影组件</title>
      <link href="/2016/11/29/ugui-zhi-shadow-yin-ying-zu-jian/"/>
      <url>/2016/11/29/ugui-zhi-shadow-yin-ying-zu-jian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>基本属性图如下：<br><img src="https://img-blog.csdn.net/20161129135448227" alt="这里写图片描述"></p><p>1、Effect Color：阴影的颜色<br>2、Effect Distance：阴影的偏移距离<br>（1）x轴水平方向：当x=0时，阴影在水平方向上中间；当x&gt;0时，阴影在右方；当x&lt;0时，阴影在左方<br>（2）y轴垂直方向：当y=0时，阴影在垂直方向上中间；当y&gt;0时，阴影在上方；当y&lt;0时，阴影在下方<br>从上图中可见其效果，另外从源码中可以看出x、y的范围均为[-600,600]，当然实际应用中这个范围是绝对足够用的<br>源码如下：</p><pre><code>public Vector2 effectDistance        {            get { return m_EffectDistance; }            set            {                if (value.x &gt; 600)                    value.x = 600;                if (value.x &lt; -600)                    value.x = -600;                if (value.y &gt; 600)                    value.y = 600;                if (value.y &lt; -600)                    value.y = -600;                if (m_EffectDistance == value)                    return;                m_EffectDistance = value;                if (graphic != null)                    graphic.SetVerticesDirty();            }        }</code></pre><p>3、Use Graphic Alpha：是否使用Graphic中的Alpha透明度<br>（1）勾选：阴影的透明度会根据Graphic的透明度变化而变化<br>注意看下面两个图中的颜色Alpha值以及左边的Text透明度变化<br><img src="https://img-blog.csdn.net/20161129141244514" alt="这里写图片描述"><br>图一</p><p><img src="https://img-blog.csdn.net/20161129141513365" alt="这里写图片描述"><br>图二</p><p>从以上可以看出勾选Use Graphic Alpha的效果<br>（2）不勾选：阴影的透明度不会根据Graphic的透明度变化而变化<br>在图二的基础上，去掉Use Graphic Alpha的勾选，结果如下：<br><img src="https://img-blog.csdn.net/20161129142217738" alt="这里写图片描述"><br>阴影部分透明度并没有受到Graphic的影响<br>源码部分：<br>如果Use Graphic<br>Alpha被勾选，m_UseGraphicAlpha为true，否则为false，从源码中可以如果m_UseGraphicAlpha为true，阴影的alpha经过了以下运算：newColor.a<br>= (byte)((newColor.a * verts[i].color.a) / 255)；</p><pre><code>protected void ApplyShadowZeroAlloc(List&lt;UIVertex&gt; verts, Color32 color, int start, int end, float x, float y)        {            UIVertex vt;            var neededCpacity = verts.Count * 2;            if (verts.Capacity &lt; neededCpacity)                verts.Capacity = neededCpacity;            for (int i = start; i &lt; end; ++i)            {                vt = verts[i];                verts.Add(vt);                Vector3 v = vt.position;                v.x += x;                v.y += y;                vt.position = v;                var newColor = color;                if (m_UseGraphicAlpha)                    newColor.a = (byte)((newColor.a * verts[i].color.a) / 255);                vt.color = newColor;                verts[i] = vt;            }        }</code></pre><p>以上为Shadow结合Text组件的使用介绍，下面看一下Shadow结合Image组件的使用：<br><img src="https://img-blog.csdn.net/20161129143409977" alt="这里写图片描述"></p><p>这里不再过多介绍，大家有兴趣，可以深入研究源码。</p><p>另外，使用Shadow会导致顶点数翻倍：</p><p><img src="https://img-blog.csdn.net/20161129143927273" alt="这里写图片描述"></p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI之Text组件详解</title>
      <link href="/2016/11/29/ugui-zhi-text-zu-jian-xiang-jie/"/>
      <url>/2016/11/29/ugui-zhi-text-zu-jian-xiang-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>基本属性如下图：</p><p><img src="https://img-blog.csdn.net/20161129115729933" alt="这里写图片描述"></p><p>Character：<br>1、Font：字体<br>2、Font Style：<br>（1）Normal：正常<br>（2）Bold：粗体<br>（3）Italic：斜体<br>（4）Bold And Italic：粗体+斜体<br>3、Font Size：字体大小<br>4、Line Spacing：行间距（注：Text组件没有提供修改字间距的属性，在前面写过修改字间距的脚本）<br>5、Rich Text：富文本<br><img src="https://img-blog.csdn.net/20161129121858435" alt="这里写图片描述"><br>支持多组合的语法例如下面例子：<br><img src="https://img-blog.csdn.net/20161129122131670" alt="这里写图片描述"></p><p>Paragraph：<br>1、Alignment： <img src="https://img-blog.csdn.net/20161129120344802" alt="这里写图片描述"><br>前面三个按钮是水平方向（分别为左对齐、居中、右对齐），后面三个按钮是垂直方向（分别为顶对齐，居中，底对齐）</p><p>2、Align By Geometry：<br>官方解释：<br>Use the extents of glyph geometry to perform horizontal alignment rather than<br>glyph metrics.<br>This can result in better fitting left and right alignment, but may result in<br>incorrect positioning when attempting to overlay multiple fonts (such as a<br>specialized outline font) on top of each other.<br>使用区段的字形几何执行水平对齐,而不是字形指标。<br>这可以导致更好的拟合左和右对齐,但可能会导致不正确的定位当试图覆盖多个字体(如专业轮廓字体)上。</p><p>3、Horizontal Overflow：水平溢出<br>（1）Wrap：文本将自动换行，当达到水平边界<br>（2）Overflow：文本可以超出水平边界，继续显示<br>4、Vertical Overflow：垂直溢出<br>（1）Truncate：文本不显示超出垂直边界的部分<br>（2）Overflow：文本可以超出垂直边界，继续显示<br>5、Best Fit：勾选之后，编辑器发生变化，显示Min Size和Max Size<br>（1）Min Size：最小大小<br>（2）Max Size：最大大小<br>当边框很大时，文字最大显示Max Size字体大小；当边框很小时，文字最小显示Min Size字体大小，边框显示不了MinSize字体大小就不再显示文字了。</p><p>Color：颜色</p><p>Material：材质</p><p>Raycast Target：来自类Graphic，当该项为false时，消息会透传</p>]]></content>
      
      
      <categories>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI之Text对齐至格子</title>
      <link href="/2016/08/06/ugui-zhi-text-dui-qi-zhi-ge-zi/"/>
      <url>/2016/08/06/ugui-zhi-text-dui-qi-zhi-ge-zi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="UGUI之Text对齐至格子"><a href="#UGUI之Text对齐至格子" class="headerlink" title="UGUI之Text对齐至格子"></a>UGUI之Text对齐至格子</h2><p>背景：前几天有个需求：玩家输入的6位房间ID号，要对齐至背景格子图中，故将前面写的调整Text字间距勉强给boss用了</p><p>大致效果如图：<br><img src="https://img-blog.csdn.net/20160806112851169" alt="这里写图片描述"></p><p>具体脚本代码如下:</p><pre><code>using UnityEngine;using System.Collections;using UnityEngine.UI;using System;using System.Collections.Generic;[AddComponentMenu(&quot;UI/Effects/TextAlignToGrid&quot;)]public class TextAlignToGrid : BaseMeshEffect{    public RectTransform _gridBg;          //格子背景    public int _gridNum;                  //我的格子数为6    private Vector2 _gridSize;          //格子大小    private Vector3[] _targetFocusPos;  //目标中心点，也就是对应的格子中心点    public override void ModifyMesh(VertexHelper vh)    {        if (!IsActive() || vh.currentVertCount == 0)        {            return;        }        if (_gridBg == null)        {            Debug.Log(&quot;Missing Grid Background&quot;);            return;        }        Text text = GetComponent&lt;Text&gt;();        if (text == null)        {            Debug.Log(&quot;Missing Text component&quot;);            return;        }        _gridSize = _gridBg.sizeDelta;        int textLen = text.text.Length;        Vector3[] textFocusPos = new Vector3[textLen];        List&lt;UIVertex&gt; vertexs = new List&lt;UIVertex&gt;();        _targetFocusPos = new Vector3[textLen];        vh.GetUIVertexStream(vertexs);        //计算text各文字中心点坐标        for (int i = 0; i &lt; textLen; i++)        {            float x = (vertexs[i * 6].position.x + vertexs[i * 6 + 1].position.x) / 2;            float y = (vertexs[i * 6 + 1].position.y + vertexs[i * 6 + 2].position.y) / 2;            textFocusPos[i] = new Vector3(x, y, 0);        }        //根据格子大小_gridSize计算目标中心点        float xOffset = _gridSize.x / _gridNum;        for (int i = 0; i &lt; textLen; i++)        {            float x = (float)(-_gridSize.x / 2 + xOffset * (i + 0.5));            _targetFocusPos[i] = new Vector3(x, 0, 0);        }        //计算text各顶点新坐标        UIVertex v = new UIVertex();        for (int i = 0; i &lt; vh.currentVertCount; i++)        {            vh.PopulateUIVertex(ref v, i);            float x = v.position.x + _targetFocusPos[i / 4].x - textFocusPos[i / 4].x;            float y = v.position.y + _targetFocusPos[i / 4].y - textFocusPos[i / 4].y;            v.position = new Vector3(x, y, 0);            vh.SetUIVertex(v, i);        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI之修改Text字间距</title>
      <link href="/2016/07/13/ugui-zhi-xiu-gai-text-zi-jian-ju/"/>
      <url>/2016/07/13/ugui-zhi-xiu-gai-text-zi-jian-ju/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="UGUI之修改Text字间距"><a href="#UGUI之修改Text字间距" class="headerlink" title="UGUI之修改Text字间距"></a>UGUI之修改Text字间距</h2><h2 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h2><p>先看效果图：</p><p><img src="https://img-blog.csdn.net/20160713233614704" alt="间距为10时"></p><p><img src="https://img-blog.csdn.net/20160713233555078" alt="间距为30时"></p><p>思路是修改顶点坐标</p><p>脚本TextSpacing代码如下：</p><pre><code>using UnityEngine;using System.Collections;using UnityEngine.UI;using System;using System.Collections.Generic;[AddComponentMenu(&quot;UI/Effects/TextSpacing&quot;)]public class TextSpacing : BaseMeshEffect {    public float _textSpacing = 1f;    public override void ModifyMesh(VertexHelper vh)    {        if (!IsActive() || vh.currentVertCount == 0)        {            return;        }        List&lt;UIVertex&gt; vertexs = new List&lt;UIVertex&gt;();        vh.GetUIVertexStream(vertexs);        int indexCount = vh.currentIndexCount;        UIVertex vt;        for (int i = 6; i &lt; indexCount; i++)        {            //第一个字不用改变位置            vt = vertexs[i];            vt.position += new Vector3(_textSpacing * (i / 6), 0, 0);            vertexs[i] = vt;            //以下注意点与索引的对应关系            if (i % 6 &lt;= 2)            {                vh.SetUIVertex(vt, (i / 6) * 4 + i % 6);            }            if (i % 6 == 4)            {                vh.SetUIVertex(vt, (i / 6) * 4 + i % 6 - 1);            }        }    }}</code></pre><h2 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h2><p>在第一版的基础上，解决了换行之后存在的问题<br>先看第二版的效果图：<br><img src="https://img-blog.csdn.net/20170508115729311?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjY5OTk1MDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>直接上源码：</p><pre><code>using UnityEngine;using System.Collections;using UnityEngine.UI;using System;using System.Collections.Generic;public class Line{    private int _startVertexIndex = 0;    /// &lt;summary&gt;    /// 起点索引    /// &lt;/summary&gt;    public int StartVertexIndex    {        get        {            return _startVertexIndex;        }    }    private int _endVertexIndex = 0;    /// &lt;summary&gt;    /// 终点索引    /// &lt;/summary&gt;    public int EndVertexIndex    {        get        {            return _endVertexIndex;        }    }    private int _vertexCount = 0;    /// &lt;summary&gt;    /// 该行占的点数目    /// &lt;/summary&gt;    public int VertexCount    {        get        {            return _vertexCount;        }    }    public Line(int startVertexIndex,int length)    {        _startVertexIndex = startVertexIndex;        _endVertexIndex = length * 6 - 1 + startVertexIndex;        _vertexCount = length * 6;    }}[AddComponentMenu(&quot;UI/Effects/TextSpacing&quot;)]public class TextSpacing : BaseMeshEffect{    public float _textSpacing = 1f;    public override void ModifyMesh(VertexHelper vh)    {        if (!IsActive() || vh.currentVertCount == 0)        {            return;        }        Text text = GetComponent&lt;Text&gt;();        if (text == null)        {            Debug.LogError(&quot;Missing Text component&quot;);            return;        }        List&lt;UIVertex&gt; vertexs = new List&lt;UIVertex&gt;();        vh.GetUIVertexStream(vertexs);        int indexCount = vh.currentIndexCount;        string[] lineTexts = text.text.Split(&#39;\n&#39;);        Line[] lines = new Line[lineTexts.Length];        //根据lines数组中各个元素的长度计算每一行中第一个点的索引，每个字、字母、空母均占6个点        for (int i = 0; i &lt; lines.Length; i++)        {            //除最后一行外，vertexs对于前面几行都有回车符占了6个点            if (i == 0)            {                lines[i] = new Line(0, lineTexts[i].Length + 1);            }            else if(i &gt; 0 &amp;&amp; i &lt; lines.Length - 1)            {                lines[i] = new Line(lines[i - 1].EndVertexIndex + 1, lineTexts[i].Length + 1);            }            else            {                lines[i] = new Line(lines[i - 1].EndVertexIndex + 1, lineTexts[i].Length);            }        }        UIVertex vt;        for (int i = 0; i &lt; lines.Length; i++)        {            for (int j = lines[i].StartVertexIndex + 6; j &lt;= lines[i].EndVertexIndex; j++)            {                if (j &lt; 0 || j &gt;= vertexs.Count)                {                    continue;                }                vt = vertexs[j];                vt.position += new Vector3(_textSpacing * ((j - lines[i].StartVertexIndex) / 6), 0, 0);                vertexs[j] = vt;                //以下注意点与索引的对应关系                if (j % 6 &lt;= 2)                {                    vh.SetUIVertex(vt, (j / 6) * 4 + j % 6);                }                if (j % 6 == 4)                {                    vh.SetUIVertex(vt, (j / 6) * 4 + j % 6 - 1);                }            }        }    }}</code></pre><p>思路是在第一版的基础上，对每一行都顶点坐标做处理。</p><p>以上知识分享，如有错误，欢迎指出，共同学习，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
            <tag> Unity </tag>
            
            <tag> Text </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI之Text镜像效果</title>
      <link href="/2016/07/11/ugui-zhi-text-jing-xiang-xiao-guo/"/>
      <url>/2016/07/11/ugui-zhi-text-jing-xiang-xiao-guo/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="UGUI之Text镜像效果"><a href="#UGUI之Text镜像效果" class="headerlink" title="UGUI之Text镜像效果"></a>UGUI之Text镜像效果</h2><p>先上效果图：<br><img src="https://img-blog.csdn.net/20160711212005282" alt="这里写图片描述"></p><p>脚本Mirror直接挂在Text下，distance是镜像距离</p><p>Mirror脚本如下：</p><pre><code>using UnityEngine;using System.Collections;using UnityEngine.UI;using System;using System.Collections.Generic;[AddComponentMenu(&quot;UI/Effects/Mirror&quot;)]public class Mirror : BaseMeshEffect{    //距离，限制范围0-30    [Range(0,30)]    public float distance;    public override void ModifyMesh(VertexHelper vh)    {        if (!IsActive() || vh.currentVertCount == 0)        {            return;        }        List&lt;UIVertex&gt; vertexs = new List&lt;UIVertex&gt;();        vh.GetUIVertexStream(vertexs);        UIVertex vt;        int count = vertexs.Count;        float miny = vertexs[0].position.y;        float maxy = vertexs[0].position.y;        for (int i = 1; i &lt; count; i++)        {            if (vertexs[i].position.y &lt; miny)            {                miny = vertexs[i].position.y;            }            else if (vertexs[i].position.y &gt; maxy)            {                maxy = vertexs[i].position.y;            }        }        float uiElementHeight = maxy - miny;        float mirrorMinY = -maxy + 2 * miny - distance;        Color32 top = GetComponent&lt;Text&gt;().color;        Color32 bottom = new Color(top.r, top.g, top.b, 0);        for (int i = 0; i &lt; count; i++)        {            vt = vertexs[i];            vertexs.Add(vt);            Vector3 v = vt.position;            v.y = -v.y + 2 * miny - distance;            vt.position = v;            //透明度效果            vt.color = Color32.Lerp(bottom, top, (vt.position.y - mirrorMinY) / uiElementHeight);            vertexs[i + count] = vt;        }        vh.Clear();        vh.AddUIVertexTriangleStream(vertexs);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI之Text彩虹字</title>
      <link href="/2016/07/08/ugui-zhi-text-cai-hong-zi/"/>
      <url>/2016/07/08/ugui-zhi-text-cai-hong-zi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="UGUI之Text彩虹字"><a href="#UGUI之Text彩虹字" class="headerlink" title="UGUI之Text彩虹字"></a>UGUI之Text彩虹字</h1><p>脚本Rainbow直接挂在Text下</p><p><img src="https://img-blog.csdn.net/20160708180449086" alt="这里写图片描述"></p><p>使得每个字母或者汉字均为一种随机颜色</p><p><img src="https://img-blog.csdn.net/20160708180636650" alt="这里写图片描述"></p><p>Rainbow脚本如下：</p><pre><code>using UnityEngine;using System.Collections;using UnityEngine.UI;using System.Collections.Generic;[AddComponentMenu(&quot;UI/Effects/Gradient&quot;)]public class Rainbow : BaseMeshEffect{    private Color32[] colors;    public override void ModifyMesh(VertexHelper vh)    {        if (!IsActive() || vh.currentVertCount == 0)        {            return;        }        List&lt;UIVertex&gt; vertices = new List&lt;UIVertex&gt;();        vh.GetUIVertexStream(vertices);        int count = vertices.Count;        colors = new Color32[count / 6];        for (int i = 0; i &lt; colors.Length; i++)        {            //随机颜色            float r = Random.value;            float g = Random.value;            float b = Random.value;            colors[i] = new Color(r, g, b);        }        UIVertex v = new UIVertex();        for (int i = 0; i &lt; vh.currentVertCount; i++)        {            vh.PopulateUIVertex(ref v, i);            v.color = colors[i / 4];            vh.SetUIVertex(v, i);        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
